"use strict";
/*
 * Copyright (c) "Neo4j"
 * Neo4j Sweden AB [http://neo4j.com]
 *
 * This file is part of Neo4j.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __rest = (this && this.__rest) || function (s, e) {
    var t = {};
    for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)
        t[p] = s[p];
    if (s != null && typeof Object.getOwnPropertySymbols === "function")
        for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
            if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))
                t[p[i]] = s[p[i]];
        }
    return t;
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const debug_1 = __importDefault(require("debug"));
const graphql_1 = require("graphql");
const schema_1 = require("@graphql-tools/schema");
const graphql_parse_resolve_info_1 = require("graphql-parse-resolve-info");
const schema_2 = require("../schema");
const utils_1 = require("../utils");
const index_1 = require("../auth/index");
const constants_1 = require("../constants");
const debug = debug_1.default(constants_1.DEBUG_GRAPHQL);
class Neo4jGraphQL {
    constructor(input) {
        const { config = {}, driver } = input, schemaDefinition = __rest(input, ["config", "driver"]);
        const { nodes, schema } = schema_2.makeAugmentedSchema(schemaDefinition, { enableRegex: config.enableRegex });
        this.driver = driver;
        this.config = config;
        this.nodes = nodes;
        this.schema = this.createWrappedSchema({ schema, config });
        this.document = graphql_1.parse(graphql_1.printSchema(schema));
    }
    createWrappedSchema({ schema, config, }) {
        return schema_1.addSchemaLevelResolver(schema, (_obj, _args, context, resolveInfo) => {
            const { driverConfig } = config;
            if (debug.enabled) {
                const query = graphql_1.print(resolveInfo.operation);
                debug("%s", `Incoming GraphQL:\nQuery:\n${query}\nVariables:\n${JSON.stringify(resolveInfo.variableValues, null, 2)}`);
            }
            /*
                Deleting this property ensures that we call this function more than once,
                See https://github.com/ardatan/graphql-tools/issues/353#issuecomment-499569711
            */
            // @ts-ignore: Deleting private property from object
            delete resolveInfo.operation.__runAtMostOnce; // eslint-disable-line no-param-reassign,no-underscore-dangle
            if (!(context === null || context === void 0 ? void 0 : context.driver)) {
                if (!this.driver) {
                    throw new Error("A Neo4j driver instance must either be passed to Neo4jGraphQL on construction, or passed as context.driver in each request.");
                }
                context.driver = this.driver;
            }
            if (!(context === null || context === void 0 ? void 0 : context.driverConfig)) {
                context.driverConfig = driverConfig;
            }
            context.neoSchema = this;
            context.resolveTree = graphql_parse_resolve_info_1.parseResolveInfo(resolveInfo);
            context.jwt = index_1.getJWT(context);
        });
    }
    checkNeo4jCompat(input = {}) {
        var _a;
        return __awaiter(this, void 0, void 0, function* () {
            const driver = input.driver || this.driver;
            const driverConfig = input.driverConfig || ((_a = this.config) === null || _a === void 0 ? void 0 : _a.driverConfig);
            if (!driver) {
                throw new Error("neo4j-driver Driver missing");
            }
            return utils_1.checkNeo4jCompat({ driver, driverConfig });
        });
    }
}
exports.default = Neo4jGraphQL;
//# sourceMappingURL=Neo4jGraphQL.js.map