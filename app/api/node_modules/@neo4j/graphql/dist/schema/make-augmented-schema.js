"use strict";
/*
 * Copyright (c) "Neo4j"
 * Neo4j Sweden AB [http://neo4j.com]
 *
 * This file is part of Neo4j.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
var __rest = (this && this.__rest) || function (s, e) {
    var t = {};
    for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)
        t[p] = s[p];
    if (s != null && typeof Object.getOwnPropertySymbols === "function")
        for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
            if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))
                t[p[i]] = s[p[i]];
        }
    return t;
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const merge_1 = require("@graphql-tools/merge");
const schema_1 = require("@graphql-tools/schema");
const camelcase_1 = __importDefault(require("camelcase"));
const graphql_1 = require("graphql");
const graphql_compose_1 = require("graphql-compose");
const pluralize_1 = __importDefault(require("pluralize"));
const classes_1 = require("../classes");
const get_auth_1 = __importDefault(require("./get-auth"));
const utils_1 = require("../utils");
const resolvers_1 = require("./resolvers");
const check_node_implements_interfaces_1 = __importDefault(require("./check-node-implements-interfaces"));
const Scalars = __importStar(require("./scalars"));
const parse_exclude_directive_1 = __importDefault(require("./parse-exclude-directive"));
const wrap_custom_resolvers_1 = __importDefault(require("./wrap-custom-resolvers"));
const get_custom_resolvers_1 = __importDefault(require("./get-custom-resolvers"));
const get_obj_field_meta_1 = __importDefault(require("./get-obj-field-meta"));
const point = __importStar(require("./point"));
const to_compose_1 = require("./to-compose");
// import validateTypeDefs from "./validation";
function makeAugmentedSchema(_a, { enableRegex } = {}) {
    var { typeDefs, resolvers } = _a, schemaDefinition = __rest(_a, ["typeDefs", "resolvers"]);
    const document = merge_1.mergeTypeDefs(Array.isArray(typeDefs) ? typeDefs : [typeDefs]);
    /*
        Issue caused by a combination of GraphQL Compose removing types and
        that we are not adding Points to the validation schema. This should be a
        temporary fix and does not detriment usability of the library.
    */
    // validateTypeDefs(document);
    const composer = new graphql_compose_1.SchemaComposer();
    // graphql-compose will break if the Point and CartesianPoint types are created but not used,
    // because it will purge the unused types but leave behind orphaned field resolvers
    //
    // These are flags to check whether the types are used and then create them if they are
    let pointInTypeDefs = false;
    let cartesianPointInTypeDefs = false;
    composer.createObjectTC({
        name: "DeleteInfo",
        fields: {
            nodesDeleted: "Int!",
            relationshipsDeleted: "Int!",
        },
    });
    const queryOptions = composer.createInputTC({
        name: "QueryOptions",
        fields: {
            skip: "Int",
            limit: "Int",
        },
    });
    const sortDirection = composer.createEnumTC({
        name: "SortDirection",
        values: {
            ASC: {
                value: "ASC",
                description: "Sort by field values in ascending order.",
            },
            DESC: {
                value: "DESC",
                description: "Sort by field values in descending order.",
            },
        },
    });
    const customResolvers = get_custom_resolvers_1.default(document);
    const scalars = document.definitions.filter((x) => x.kind === "ScalarTypeDefinition");
    const objectNodes = document.definitions.filter((x) => x.kind === "ObjectTypeDefinition" && !["Query", "Mutation", "Subscription"].includes(x.name.value));
    const enums = document.definitions.filter((x) => x.kind === "EnumTypeDefinition");
    const inputs = document.definitions.filter((x) => x.kind === "InputObjectTypeDefinition");
    const interfaces = document.definitions.filter((x) => x.kind === "InterfaceTypeDefinition");
    const directives = document.definitions.filter((x) => x.kind === "DirectiveDefinition");
    const unions = document.definitions.filter((x) => x.kind === "UnionTypeDefinition");
    const nodes = objectNodes.map((definition) => {
        var _a;
        check_node_implements_interfaces_1.default(definition, interfaces);
        const otherDirectives = (definition.directives || []).filter((x) => !["auth", "exclude"].includes(x.name.value));
        const authDirective = (definition.directives || []).find((x) => x.name.value === "auth");
        const excludeDirective = (definition.directives || []).find((x) => x.name.value === "exclude");
        const nodeInterfaces = [...(definition.interfaces || [])];
        let auth;
        if (authDirective) {
            auth = get_auth_1.default(authDirective);
        }
        let exclude;
        if (excludeDirective) {
            exclude = parse_exclude_directive_1.default(excludeDirective);
        }
        const nodeFields = get_obj_field_meta_1.default({
            obj: definition,
            enums,
            interfaces,
            scalars,
            unions,
            objects: objectNodes,
        });
        const node = new classes_1.Node(Object.assign(Object.assign({ name: definition.name.value, interfaces: nodeInterfaces, otherDirectives }, nodeFields), { 
            // @ts-ignore we can be sure its defined
            auth,
            // @ts-ignore we can be sure its defined
            exclude, description: (_a = definition.description) === null || _a === void 0 ? void 0 : _a.value }));
        return node;
    });
    const nodeNames = nodes.map((x) => x.name);
    nodes.forEach((node) => {
        var _a, _b, _c, _d;
        const nodeFields = to_compose_1.objectFieldsToComposeFields([
            ...node.primitiveFields,
            ...node.cypherFields,
            ...node.enumFields,
            ...node.scalarFields,
            ...node.interfaceFields,
            ...node.objectFields,
            ...node.unionFields,
            ...node.dateTimeFields,
            ...node.pointFields,
            ...node.ignoredFields,
        ]);
        const composeNode = composer.createObjectTC({
            name: node.name,
            fields: nodeFields,
            description: node.description,
            extensions: {
                directives: to_compose_1.graphqlDirectivesToCompose(node.otherDirectives),
            },
            interfaces: node.interfaces.map((x) => x.name.value),
        });
        const sortFields = [
            ...node.primitiveFields,
            ...node.enumFields,
            ...node.scalarFields,
            ...node.dateTimeFields,
            ...node.pointFields,
        ].reduce((res, f) => {
            return f.typeMeta.array
                ? Object.assign({}, res) : Object.assign(Object.assign({}, res), { [f.fieldName]: sortDirection.getTypeName() });
        }, {});
        if (Object.keys(sortFields).length) {
            const sortInput = composer.createInputTC({
                name: `${node.name}Sort`,
                fields: sortFields,
                description: `Fields to sort ${pluralize_1.default(node.name)} by. The order in which sorts are applied is not guaranteed when specifying many fields in one ${`${node.name}Sort`} object.`,
            });
            composer.createInputTC({
                name: `${node.name}Options`,
                fields: {
                    sort: {
                        description: `Specify one or more ${`${node.name}Sort`} objects to sort ${pluralize_1.default(node.name)} by. The sorts will be applied in the order in which they are arranged in the array.`,
                        type: sortInput.List,
                    },
                    limit: "Int",
                    skip: "Int",
                },
            });
        }
        else {
            composer.createInputTC({
                name: `${node.name}Options`,
                fields: { limit: "Int", skip: "Int" },
            });
        }
        const queryFields = Object.assign(Object.assign({ OR: `[${node.name}Where!]`, AND: `[${node.name}Where!]` }, node.scalarFields.reduce((res, f) => {
            res[f.fieldName] = f.typeMeta.array ? `[${f.typeMeta.name}]` : f.typeMeta.name;
            return res;
        }, {})), [...node.primitiveFields, ...node.dateTimeFields, ...node.enumFields, ...node.pointFields].reduce((res, f) => {
            // This is the only sensible place to flag whether Point and CartesianPoint are used
            if (f.typeMeta.name === "Point") {
                pointInTypeDefs = true;
            }
            else if (f.typeMeta.name === "CartesianPoint") {
                cartesianPointInTypeDefs = true;
            }
            res[f.fieldName] = f.typeMeta.input.where.pretty;
            res[`${f.fieldName}_NOT`] = f.typeMeta.input.where.pretty;
            if (f.typeMeta.name === "Boolean") {
                return res;
            }
            if (f.typeMeta.array) {
                res[`${f.fieldName}_INCLUDES`] = f.typeMeta.input.where.type;
                res[`${f.fieldName}_NOT_INCLUDES`] = f.typeMeta.input.where.type;
                return res;
            }
            res[`${f.fieldName}_IN`] = `[${f.typeMeta.input.where.pretty}]`;
            res[`${f.fieldName}_NOT_IN`] = `[${f.typeMeta.input.where.pretty}]`;
            if (["Float", "Int", "BigInt", "DateTime"].includes(f.typeMeta.name)) {
                ["_LT", "_LTE", "_GT", "_GTE"].forEach((comparator) => {
                    res[`${f.fieldName}${comparator}`] = f.typeMeta.name;
                });
                return res;
            }
            if (["Point", "CartesianPoint"].includes(f.typeMeta.name)) {
                ["_DISTANCE", "_LT", "_LTE", "_GT", "_GTE"].forEach((comparator) => {
                    res[`${f.fieldName}${comparator}`] = `${f.typeMeta.name}Distance`;
                });
                return res;
            }
            if (["String", "ID"].includes(f.typeMeta.name)) {
                if (enableRegex) {
                    res[`${f.fieldName}_MATCHES`] = "String";
                }
                [
                    "_CONTAINS",
                    "_NOT_CONTAINS",
                    "_STARTS_WITH",
                    "_NOT_STARTS_WITH",
                    "_ENDS_WITH",
                    "_NOT_ENDS_WITH",
                ].forEach((comparator) => {
                    res[`${f.fieldName}${comparator}`] = f.typeMeta.name;
                });
                return res;
            }
            return res;
        }, {}));
        const whereInput = composer.createInputTC({
            name: `${node.name}Where`,
            fields: queryFields,
        });
        const nodeInput = composer.createInputTC({
            name: `${node.name}CreateInput`,
            fields: [
                ...node.primitiveFields,
                ...node.scalarFields,
                ...node.enumFields,
                ...node.dateTimeFields.filter((x) => !x.timestamps),
                ...node.pointFields,
            ].reduce((res, f) => {
                var _a, _b, _c;
                if ((_a = f) === null || _a === void 0 ? void 0 : _a.autogenerate) {
                    return res;
                }
                if (((_b = f) === null || _b === void 0 ? void 0 : _b.defaultValue) !== undefined) {
                    const field = {
                        type: f.typeMeta.input.create.pretty,
                        defaultValue: (_c = f) === null || _c === void 0 ? void 0 : _c.defaultValue,
                    };
                    res[f.fieldName] = field;
                }
                else {
                    res[f.fieldName] = f.typeMeta.input.create.pretty;
                }
                return res;
            }, {}),
        });
        const nodeUpdateInput = composer.createInputTC({
            name: `${node.name}UpdateInput`,
            fields: [
                ...node.primitiveFields,
                ...node.scalarFields,
                ...node.enumFields,
                ...node.dateTimeFields.filter((x) => !x.timestamps),
                ...node.pointFields,
            ].reduce((res, f) => {
                var _a;
                return f.readonly || ((_a = f) === null || _a === void 0 ? void 0 : _a.autogenerate)
                    ? res
                    : Object.assign(Object.assign({}, res), { [f.fieldName]: f.typeMeta.input.update.pretty });
            }, {}),
        });
        const nodeDeleteInput = composer.createInputTC({
            name: `${node.name}DeleteInput`,
            fields: {},
        });
        ["Create", "Update"].map((operation) => composer.createObjectTC({
            name: `${operation}${pluralize_1.default(node.name)}MutationResponse`,
            fields: {
                [pluralize_1.default(camelcase_1.default(node.name))]: `[${node.name}!]!`,
            },
        }));
        let nodeConnectInput = undefined;
        let nodeDisconnectInput = undefined;
        let nodeRelationInput = undefined;
        if (node.relationFields.length) {
            [nodeConnectInput, nodeDisconnectInput, nodeRelationInput] = [
                "ConnectInput",
                "DisconnectInput",
                "RelationInput",
            ].map((type) => composer.createInputTC({
                name: `${node.name}${type}`,
                fields: {},
            }));
        }
        composer.createInputTC({
            name: `${node.name}ConnectFieldInput`,
            fields: Object.assign({ where: `${node.name}Where` }, (node.relationFields.length ? { connect: nodeConnectInput } : {})),
        });
        composer.createInputTC({
            name: `${node.name}DisconnectFieldInput`,
            fields: Object.assign({ where: `${node.name}Where` }, (node.relationFields.length ? { disconnect: nodeDisconnectInput } : {})),
        });
        if (!composer.has(`${node.name}DeleteFieldInput`)) {
            composer.createInputTC({
                name: `${node.name}DeleteFieldInput`,
                fields: Object.assign({ where: `${node.name}Where` }, (node.relationFields.length ? { delete: nodeDeleteInput } : {})),
            });
        }
        node.relationFields.forEach((rel) => {
            if (rel.union) {
                const refNodes = nodes.filter((x) => { var _a, _b; return (_b = (_a = rel.union) === null || _a === void 0 ? void 0 : _a.nodes) === null || _b === void 0 ? void 0 : _b.includes(x.name); });
                composeNode.addFields({
                    [rel.fieldName]: {
                        type: rel.typeMeta.pretty,
                        args: {
                            options: queryOptions.getTypeName(),
                        },
                    },
                });
                refNodes.forEach((n) => {
                    const concatFieldName = `${rel.fieldName}_${n.name}`;
                    const createField = rel.typeMeta.array ? `[${n.name}CreateInput!]` : `${n.name}CreateInput`;
                    const updateField = `${n.name}UpdateInput`;
                    const nodeFieldInputName = `${node.name}${utils_1.upperFirstLetter(rel.fieldName)}${n.name}FieldInput`;
                    const nodeFieldUpdateInputName = `${node.name}${utils_1.upperFirstLetter(rel.fieldName)}${n.name}UpdateFieldInput`;
                    const nodeFieldDeleteInputName = `${node.name}${utils_1.upperFirstLetter(rel.fieldName)}${n.name}DeleteFieldInput`;
                    const connectField = rel.typeMeta.array
                        ? `[${n.name}ConnectFieldInput!]`
                        : `${n.name}ConnectFieldInput`;
                    const disconnectField = rel.typeMeta.array
                        ? `[${n.name}DisconnectFieldInput!]`
                        : `${n.name}DisconnectFieldInput`;
                    const deleteField = rel.typeMeta.array
                        ? `[${n.name}DeleteFieldInput!]`
                        : `${n.name}DeleteFieldInput`;
                    composeNode.addFieldArgs(rel.fieldName, {
                        [n.name]: `${n.name}Where`,
                    });
                    composer.createInputTC({
                        name: nodeFieldUpdateInputName,
                        fields: {
                            where: `${n.name}Where`,
                            update: updateField,
                            connect: connectField,
                            disconnect: disconnectField,
                            create: createField,
                            delete: deleteField,
                        },
                    });
                    composer.createInputTC({
                        name: nodeFieldInputName,
                        fields: {
                            create: createField,
                            connect: connectField,
                        },
                    });
                    composer.createInputTC({
                        name: nodeFieldDeleteInputName,
                        fields: Object.assign({ where: `${n.name}Where` }, (n.relationFields.length
                            ? {
                                delete: `${n.name}DeleteInput`,
                            }
                            : {})),
                    });
                    nodeRelationInput.addFields({
                        [concatFieldName]: createField,
                    });
                    nodeInput.addFields({
                        [concatFieldName]: nodeFieldInputName,
                    });
                    nodeUpdateInput.addFields({
                        [concatFieldName]: rel.typeMeta.array
                            ? `[${nodeFieldUpdateInputName}!]`
                            : nodeFieldUpdateInputName,
                    });
                    nodeDeleteInput.addFields({
                        [concatFieldName]: rel.typeMeta.array
                            ? `[${nodeFieldDeleteInputName}!]`
                            : nodeFieldDeleteInputName,
                    });
                    nodeConnectInput.addFields({
                        [concatFieldName]: connectField,
                    });
                    nodeDisconnectInput.addFields({
                        [concatFieldName]: disconnectField,
                    });
                });
                return;
            }
            const n = nodes.find((x) => x.name === rel.typeMeta.name);
            const createField = rel.typeMeta.array ? `[${n.name}CreateInput!]` : `${n.name}CreateInput`;
            const updateField = `${n.name}UpdateInput`;
            const nodeFieldInputName = `${node.name}${utils_1.upperFirstLetter(rel.fieldName)}FieldInput`;
            const nodeFieldUpdateInputName = `${node.name}${utils_1.upperFirstLetter(rel.fieldName)}UpdateFieldInput`;
            const nodeFieldDeleteInputName = `${node.name}${utils_1.upperFirstLetter(rel.fieldName)}DeleteFieldInput`;
            const connectField = rel.typeMeta.array ? `[${n.name}ConnectFieldInput!]` : `${n.name}ConnectFieldInput`;
            const disconnectField = rel.typeMeta.array
                ? `[${n.name}DisconnectFieldInput!]`
                : `${n.name}DisconnectFieldInput`;
            const deleteField = rel.typeMeta.array ? `[${n.name}DeleteFieldInput!]` : `${n.name}DeleteFieldInput`;
            whereInput.addFields(Object.assign({ [rel.fieldName]: `${n.name}Where`, [`${rel.fieldName}_NOT`]: `${n.name}Where` }, (rel.typeMeta.array
                ? {}
                : {
                    [`${rel.fieldName}_IN`]: `[${n.name}Where!]`,
                    [`${rel.fieldName}_NOT_IN`]: `[${n.name}Where!]`,
                })));
            composeNode.addFields({
                [rel.fieldName]: {
                    type: rel.typeMeta.pretty,
                    args: {
                        where: `${rel.typeMeta.name}Where`,
                        options: `${rel.typeMeta.name}Options`,
                    },
                },
            });
            composer.createInputTC({
                name: nodeFieldUpdateInputName,
                fields: {
                    where: `${n.name}Where`,
                    update: updateField,
                    connect: connectField,
                    disconnect: disconnectField,
                    create: createField,
                    delete: deleteField,
                },
            });
            composer.createInputTC({
                name: nodeFieldInputName,
                fields: {
                    create: createField,
                    connect: connectField,
                },
            });
            if (!composer.has(nodeFieldDeleteInputName)) {
                composer.createInputTC({
                    name: nodeFieldDeleteInputName,
                    fields: Object.assign({ where: `${n.name}Where` }, (n.relationFields.length
                        ? {
                            delete: `${n.name}DeleteInput`,
                        }
                        : {})),
                });
            }
            nodeRelationInput.addFields({
                [rel.fieldName]: createField,
            });
            nodeInput.addFields({
                [rel.fieldName]: nodeFieldInputName,
            });
            nodeUpdateInput.addFields({
                [rel.fieldName]: rel.typeMeta.array ? `[${nodeFieldUpdateInputName}!]` : nodeFieldUpdateInputName,
            });
            nodeDeleteInput.addFields({
                [rel.fieldName]: rel.typeMeta.array ? `[${nodeFieldDeleteInputName}!]` : nodeFieldDeleteInputName,
            });
            nodeConnectInput.addFields({
                [rel.fieldName]: connectField,
            });
            nodeDisconnectInput.addFields({
                [rel.fieldName]: disconnectField,
            });
        });
        if (!((_a = node.exclude) === null || _a === void 0 ? void 0 : _a.operations.includes("read"))) {
            composer.Query.addFields({
                [pluralize_1.default(camelcase_1.default(node.name))]: resolvers_1.findResolver({ node }),
            });
        }
        if (!((_b = node.exclude) === null || _b === void 0 ? void 0 : _b.operations.includes("create"))) {
            composer.Mutation.addFields({
                [`create${pluralize_1.default(node.name)}`]: resolvers_1.createResolver({ node }),
            });
        }
        if (!((_c = node.exclude) === null || _c === void 0 ? void 0 : _c.operations.includes("delete"))) {
            composer.Mutation.addFields({
                [`delete${pluralize_1.default(node.name)}`]: resolvers_1.deleteResolver({ node }),
            });
        }
        if (!((_d = node.exclude) === null || _d === void 0 ? void 0 : _d.operations.includes("update"))) {
            composer.Mutation.addFields({
                [`update${pluralize_1.default(node.name)}`]: resolvers_1.updateResolver({ node }),
            });
        }
    });
    ["Mutation", "Query"].forEach((type) => {
        const objectComposer = composer[type];
        const cypherType = customResolvers[`customCypher${type}`];
        if (cypherType) {
            const objectFields = get_obj_field_meta_1.default({
                obj: cypherType,
                scalars,
                enums,
                interfaces,
                unions,
                objects: objectNodes,
            });
            const objectComposeFields = to_compose_1.objectFieldsToComposeFields([
                ...objectFields.enumFields,
                ...objectFields.interfaceFields,
                ...objectFields.primitiveFields,
                ...objectFields.relationFields,
                ...objectFields.scalarFields,
                ...objectFields.unionFields,
                ...objectFields.objectFields,
                ...objectFields.dateTimeFields,
            ]);
            objectComposer.addFields(objectComposeFields);
            objectFields.cypherFields.forEach((field) => {
                const customResolver = resolvers_1.cypherResolver({
                    field,
                    statement: field.statement,
                });
                const composedField = to_compose_1.objectFieldsToComposeFields([field])[field.fieldName];
                objectComposer.addFields({ [field.fieldName]: Object.assign(Object.assign({}, composedField), customResolver) });
            });
        }
    });
    const extraDefinitions = [
        ...enums,
        ...scalars,
        ...directives,
        ...inputs,
        ...unions,
        ...[
            customResolvers.customQuery,
            customResolvers.customMutation,
            customResolvers.customSubscription,
        ],
    ].filter(Boolean);
    if (extraDefinitions.length) {
        composer.addTypeDefs(graphql_1.print({ kind: "Document", definitions: extraDefinitions }));
    }
    interfaces.forEach((inter) => {
        const objectFields = get_obj_field_meta_1.default({ obj: inter, scalars, enums, interfaces, unions, objects: objectNodes });
        const objectComposeFields = to_compose_1.objectFieldsToComposeFields(Object.values(objectFields).reduce((acc, x) => [...acc, ...x], []));
        composer.createInterfaceTC({
            name: inter.name.value,
            fields: objectComposeFields,
            extensions: {
                directives: to_compose_1.graphqlDirectivesToCompose((inter.directives || []).filter((x) => x.name.value !== "auth")),
            },
        });
    });
    Object.keys(Scalars).forEach((scalar) => composer.addTypeDefs(`scalar ${scalar}`));
    if (pointInTypeDefs) {
        // Every field (apart from CRS) in Point needs a custom resolver
        // to deconstruct the point objects we fetch from the database
        composer.createObjectTC(point.point);
        composer.createInputTC(point.pointInput);
        composer.createInputTC(point.pointDistance);
    }
    if (cartesianPointInTypeDefs) {
        // Every field (apart from CRS) in CartesianPoint needs a custom resolver
        // to deconstruct the point objects we fetch from the database
        composer.createObjectTC(point.cartesianPoint);
        composer.createInputTC(point.cartesianPointInput);
        composer.createInputTC(point.cartesianPointDistance);
    }
    if (!Object.values(composer.Mutation.getFields()).length) {
        composer.delete("Mutation");
    }
    const generatedTypeDefs = composer.toSDL();
    let generatedResolvers = Object.assign(Object.assign({}, composer.getResolveMethods()), Object.entries(Scalars).reduce((res, [name, scalar]) => {
        if (generatedTypeDefs.includes(`scalar ${name}`)) {
            res[name] = scalar;
        }
        return res;
    }, {}));
    if (resolvers) {
        generatedResolvers = wrap_custom_resolvers_1.default({
            generatedResolvers,
            nodeNames,
            resolvers,
        });
    }
    unions.forEach((union) => {
        // eslint-disable-next-line no-underscore-dangle
        generatedResolvers[union.name.value] = { __resolveType: (root) => root.__resolveType };
    });
    const schema = schema_1.makeExecutableSchema(Object.assign(Object.assign({}, schemaDefinition), { typeDefs: generatedTypeDefs, resolvers: generatedResolvers }));
    return {
        nodes,
        schema,
    };
}
exports.default = makeAugmentedSchema;
//# sourceMappingURL=make-augmented-schema.js.map