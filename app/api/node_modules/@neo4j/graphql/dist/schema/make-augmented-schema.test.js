"use strict";
/*
 * Copyright (c) "Neo4j"
 * Neo4j Sweden AB [http://neo4j.com]
 *
 * This file is part of Neo4j.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const camelcase_1 = __importDefault(require("camelcase"));
const graphql_1 = require("graphql");
const graphql_compose_1 = require("graphql-compose");
const make_augmented_schema_1 = __importDefault(require("./make-augmented-schema"));
const classes_1 = require("../classes");
describe("makeAugmentedSchema", () => {
    test("should be a function", () => {
        expect(make_augmented_schema_1.default).toBeInstanceOf(Function);
    });
    test("should return the correct schema", () => {
        const typeDefs = `
            type Actor {
                name: String
                movies: [Movie] @relationship(type: "ACTED_IN", direction: OUT)
            }

            type Movie {
                title: String!
                actors: [Actor] @relationship(type: "ACTED_IN", direction: IN)
            }
        `;
        const neoSchema = make_augmented_schema_1.default({ typeDefs });
        const document = graphql_1.parse(graphql_1.printSchema(neoSchema.schema));
        const queryObject = document.definitions.find((x) => x.kind === "ObjectTypeDefinition" && x.name.value === "Query");
        ["Actor", "Movie"].forEach((type) => {
            var _a;
            const node = neoSchema.nodes.find((x) => x.name === type);
            expect(node).toBeInstanceOf(classes_1.Node);
            const nodeObject = document.definitions.find((x) => x.kind === "ObjectTypeDefinition" && x.name.value === type);
            expect(nodeObject).toBeTruthy();
            // Find
            const nodeFindQuery = (_a = queryObject.fields) === null || _a === void 0 ? void 0 : _a.find((x) => x.name.value === graphql_compose_1.pluralize(camelcase_1.default(type)));
            const nodeFindQueryType = (nodeFindQuery === null || nodeFindQuery === void 0 ? void 0 : nodeFindQuery.type).type
                .type;
            expect(nodeFindQueryType.name.value).toEqual(type);
            // Options
            const options = document.definitions.find((x) => x.kind === "InputObjectTypeDefinition" && x.name.value === `${type}Options`);
            expect(options).toBeTruthy();
            // Where
            const where = document.definitions.find((x) => x.kind === "InputObjectTypeDefinition" && x.name.value === `${type}Where`);
            expect(where).toBeTruthy();
            // SORT
            const sort = document.definitions.find((x) => x.kind === "InputObjectTypeDefinition" && x.name.value === `${type}Sort`);
            expect(sort).toBeTruthy();
        });
    });
    test("should throw cannot have interface on relationship", () => {
        const typeDefs = `
                interface Node {
                    id: ID
                }

                type Movie {
                    title: String!
                    nodes: [Node] @relationship(type: "NODE", direction: IN)
                }
            `;
        expect(() => make_augmented_schema_1.default({ typeDefs })).toThrow("cannot have interface on relationship");
    });
    test("should throw type X does not implement interface X correctly", () => {
        const typeDefs = `
            interface Node @auth(rules: [{operations: [READ]}]) {
                id: ID
                relation: [Movie] @relationship(type: "SOME_TYPE", direction: OUT)
                cypher: [Movie] @cypher(statement: "MATCH (a) RETURN a")
            }

            type Movie implements Node {
                title: String!
            }
            `;
        expect(() => make_augmented_schema_1.default({ typeDefs })).toThrow("type Movie does not implement interface Node correctly");
    });
    test("should throw cannot auto-generate a non ID field", () => {
        const typeDefs = `
            type Movie  {
                name: String! @id
            }
        `;
        expect(() => make_augmented_schema_1.default({ typeDefs })).toThrow("cannot auto-generate a non ID field");
    });
    test("should throw cannot auto-generate an array", () => {
        const typeDefs = `
                type Movie  {
                    name: [ID] @id
                }
            `;
        expect(() => make_augmented_schema_1.default({ typeDefs })).toThrow("cannot auto-generate an array");
    });
    test("should throw cannot timestamp on array of DateTime", () => {
        const typeDefs = `
                type Movie  {
                    name: [DateTime] @timestamp(operations: [CREATE])
                }
            `;
        expect(() => make_augmented_schema_1.default({ typeDefs })).toThrow("cannot auto-generate an array");
    });
    /*
        Removal of validateTypeDefs function
    */
    // test("should throw timestamp operations must be an array", () => {
    //     const typeDefs = `
    //             type Movie  {
    //                 name: DateTime @timestamp(operations: "read")
    //             }
    //         `;
    //     expect(() => makeAugmentedSchema({ typeDefs })).toThrow('Argument "operations" has invalid value "read".');
    // });
    // test("should throw timestamp operations[0] invalid", () => {
    //     const typeDefs = `
    //             type Movie  {
    //                 name: DateTime @timestamp(operations: ["read"])
    //             }
    //         `;
    //     expect(() => makeAugmentedSchema({ typeDefs })).toThrow('Argument "operations" has invalid value ["read"].');
    // });
    test("should throw cannot have auth directive on a relationship", () => {
        const typeDefs = `
                type Node {
                    node: Node @relationship(type: "NODE", direction: OUT) @auth(rules: [{operations: [CREATE]}])
                }
            `;
        expect(() => make_augmented_schema_1.default({ typeDefs })).toThrow("cannot have auth directive on a relationship");
    });
    describe("REGEX", () => {
        test("should remove the MATCHES filter by default", () => {
            var _a;
            const typeDefs = `
                    type Node {
                        name: String
                    }
                `;
            const neoSchema = make_augmented_schema_1.default({ typeDefs });
            const document = graphql_1.parse(graphql_1.printSchema(neoSchema.schema));
            const nodeWhereInput = document.definitions.find((x) => x.kind === "InputObjectTypeDefinition" && x.name.value === "NodeWhere");
            const matchesField = (_a = nodeWhereInput.fields) === null || _a === void 0 ? void 0 : _a.find((x) => x.name.value.endsWith("_MATCHES"));
            expect(matchesField).toBeUndefined();
        });
        test("should add the MATCHES filter when NEO4J_GRAPHQL_ENABLE_REGEX is set", () => {
            var _a;
            const typeDefs = `
                    type Node {
                        name: String
                    }
                `;
            const neoSchema = make_augmented_schema_1.default({ typeDefs }, { enableRegex: true });
            const document = graphql_1.parse(graphql_1.printSchema(neoSchema.schema));
            const nodeWhereInput = document.definitions.find((x) => x.kind === "InputObjectTypeDefinition" && x.name.value === "NodeWhere");
            const matchesField = (_a = nodeWhereInput.fields) === null || _a === void 0 ? void 0 : _a.find((x) => x.name.value.endsWith("_MATCHES"));
            expect(matchesField).not.toBeUndefined();
        });
    });
    describe("issues", () => {
        test("158", () => {
            // https://github.com/neo4j/graphql/issues/158
            const typeDefs = `
                type Node {
                    createdAt: DateTime
                }
              
                type Query {
                  nodes: [Node] @cypher(statement: "")
                }
            `;
            const neoSchema = make_augmented_schema_1.default({ typeDefs });
            const document = graphql_1.parse(graphql_1.printSchema(neoSchema.schema));
            // make sure the schema constructs
            expect(document.kind).toEqual("Document");
        });
    });
});
//# sourceMappingURL=make-augmented-schema.test.js.map