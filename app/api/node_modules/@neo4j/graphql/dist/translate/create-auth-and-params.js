"use strict";
/*
 * Copyright (c) "Neo4j"
 * Neo4j Sweden AB [http://neo4j.com]
 *
 * This file is part of Neo4j.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const dot_prop_1 = __importDefault(require("dot-prop"));
const constants_1 = require("../constants");
function createRolesStr({ roles, escapeQuotes }) {
    const quote = escapeQuotes ? `\\"` : `"`;
    const joined = roles.map((r) => `${quote}${r}${quote}`).join(", ");
    return `ANY(r IN [${joined}] WHERE ANY(rr IN $auth.roles WHERE r = rr))`;
}
function createAuthPredicate({ rule, node, varName, context, chainStr, kind, }) {
    if (!rule[kind]) {
        return ["", {}];
    }
    const { jwt } = context;
    const result = Object.entries(rule[kind]).reduce((res, [key, value]) => {
        if (key === "AND" || key === "OR") {
            const inner = [];
            value.forEach((v, i) => {
                const authPredicate = createAuthPredicate({
                    rule: { [kind]: v },
                    varName,
                    node,
                    chainStr: `${chainStr}_${key}${i}`,
                    context,
                    kind,
                });
                inner.push(authPredicate[0]);
                res.params = Object.assign(Object.assign({}, res.params), authPredicate[1]);
            });
            res.strs.push(`(${inner.join(` ${key} `)})`);
        }
        const authableField = node.authableFields.find((field) => field.fieldName === key);
        if (authableField) {
            const [, jwtPath] = value.split("$jwt.");
            const [, ctxPath] = value.split("$context.");
            let paramValue = value;
            if (jwtPath) {
                paramValue = dot_prop_1.default.get({ value: jwt }, `value.${jwtPath}`);
            }
            else if (ctxPath) {
                paramValue = dot_prop_1.default.get({ value: context }, `value.${ctxPath}`);
            }
            const param = `${chainStr}_${key}`;
            res.params[param] = paramValue;
            res.strs.push(`EXISTS(${varName}.${key}) AND ${varName}.${key} = $${param}`);
        }
        const relationField = node.relationFields.find((x) => key === x.fieldName);
        if (relationField) {
            const refNode = context.neoSchema.nodes.find((x) => x.name === relationField.typeMeta.name);
            const inStr = relationField.direction === "IN" ? "<-" : "-";
            const outStr = relationField.direction === "OUT" ? "->" : "-";
            const relTypeStr = `[:${relationField.type}]`;
            const relationVarName = relationField.fieldName;
            let resultStr = [
                `EXISTS((${varName})${inStr}${relTypeStr}${outStr}(:${relationField.typeMeta.name}))`,
                `AND ${kind === "allow" ? "ANY" : "ALL"}(${relationVarName} IN [(${varName})${inStr}${relTypeStr}${outStr}(${relationVarName}:${relationField.typeMeta.name}) | ${relationVarName}] WHERE `,
            ].join(" ");
            Object.entries(value).forEach(([k, v]) => {
                const authPredicate = createAuthPredicate({
                    node: refNode,
                    context,
                    chainStr: `${chainStr}_${key}`,
                    varName: relationVarName,
                    rule: { [kind]: { [k]: v } },
                    kind,
                });
                resultStr += authPredicate[0];
                resultStr += ")"; // close ALL
                res.params = Object.assign(Object.assign({}, res.params), authPredicate[1]);
                res.strs.push(resultStr);
            });
        }
        return res;
    }, { params: {}, strs: [] });
    return [result.strs.join(" AND "), result.params];
}
function createAuthAndParams({ entity, operation, skipRoles, skipIsAuthenticated, allow, context, escapeQuotes, bind, where, }) {
    if (!entity.auth) {
        return ["", {}];
    }
    let authRules = [];
    if (operation) {
        authRules = entity === null || entity === void 0 ? void 0 : entity.auth.rules.filter((r) => { var _a; return !r.operations || ((_a = r.operations) === null || _a === void 0 ? void 0 : _a.includes(operation)); });
    }
    else {
        authRules = entity === null || entity === void 0 ? void 0 : entity.auth.rules;
    }
    if (where) {
        const subPredicates = authRules.reduce((res, authRule, index) => {
            if (!authRule.where) {
                return res;
            }
            const authWhere = createAuthPredicate({
                rule: { where: authRule.where },
                context,
                node: where.node,
                varName: where.varName,
                chainStr: `${where.chainStr || where.varName}_auth_where${index}`,
                kind: "where",
            });
            return {
                strs: [...res.strs, authWhere[0]],
                params: Object.assign(Object.assign({}, res.params), authWhere[1]),
            };
        }, { strs: [], params: {} });
        const joined = subPredicates.strs.filter(Boolean).join(" OR ");
        return [joined, subPredicates.params];
    }
    function createSubPredicate({ authRule, index, chainStr, }) {
        const thisPredicates = [];
        let thisParams = {};
        if (!skipRoles && authRule.roles) {
            thisPredicates.push(createRolesStr({ roles: authRule.roles, escapeQuotes }));
        }
        if (!skipIsAuthenticated && (authRule.isAuthenticated === true || authRule.isAuthenticated === false)) {
            thisPredicates.push(`apoc.util.validatePredicate(NOT($auth.isAuthenticated = ${Boolean(authRule.isAuthenticated)}), "${constants_1.AUTH_UNAUTHENTICATED_ERROR}", [0])`);
        }
        if (allow && authRule.allow) {
            const allowAndParams = createAuthPredicate({
                context,
                node: allow.parentNode,
                varName: allow.varName,
                rule: authRule,
                chainStr: `${allow.chainStr || allow.varName}${chainStr || ""}_auth_allow${index}`,
                kind: "allow",
            });
            if (allowAndParams[0]) {
                thisPredicates.push(allowAndParams[0]);
                thisParams = Object.assign(Object.assign({}, thisParams), allowAndParams[1]);
            }
        }
        ["AND", "OR"].forEach((key) => {
            const value = authRule[key];
            if (!value) {
                return;
            }
            const predicates = [];
            let predicateParams = {};
            value.forEach((v, i) => {
                const [str, par] = createSubPredicate({
                    authRule: v,
                    index: i,
                    chainStr: chainStr ? `${chainStr}${key}${i}` : `${key}${i}`,
                });
                if (!str) {
                    return;
                }
                predicates.push(str);
                predicateParams = Object.assign(Object.assign({}, predicateParams), par);
            });
            thisPredicates.push(predicates.join(` ${key} `));
            thisParams = Object.assign(Object.assign({}, thisParams), predicateParams);
        });
        if (bind && authRule.bind) {
            const allowAndParams = createAuthPredicate({
                context,
                node: bind.parentNode,
                varName: bind.varName,
                rule: authRule,
                chainStr: `${bind.chainStr || bind.varName}${chainStr || ""}_auth_bind${index}`,
                kind: "bind",
            });
            if (allowAndParams[0]) {
                thisPredicates.push(allowAndParams[0]);
                thisParams = Object.assign(Object.assign({}, thisParams), allowAndParams[1]);
            }
        }
        return [thisPredicates.join(" AND "), thisParams];
    }
    const subPredicates = authRules.reduce((res, authRule, index) => {
        const [str, par] = createSubPredicate({ authRule, index });
        return {
            strs: [...res.strs, str],
            params: Object.assign(Object.assign({}, res.params), par),
        };
    }, { strs: [], params: {} });
    return [subPredicates.strs.filter(Boolean).join(" OR "), subPredicates.params];
}
exports.default = createAuthAndParams;
//# sourceMappingURL=create-auth-and-params.js.map