"use strict";
/*
 * Copyright (c) "Neo4j"
 * Neo4j Sweden AB [http://neo4j.com]
 *
 * This file is part of Neo4j.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const create_where_and_params_1 = __importDefault(require("./create-where-and-params"));
const create_auth_and_params_1 = __importDefault(require("./create-auth-and-params"));
const constants_1 = require("../constants");
function createDisconnectAndParams({ withVars, value, varName, relationField, parentVar, refNode, context, labelOverride, parentNode, insideDoWhen, }) {
    function reducer(res, disconnect, index) {
        const _varName = `${varName}${index}`;
        const inStr = relationField.direction === "IN" ? "<-" : "-";
        const outStr = relationField.direction === "OUT" ? "->" : "-";
        const relVarName = `${_varName}_rel`;
        const relTypeStr = `[${relVarName}:${relationField.type}]`;
        if (parentNode.auth) {
            const whereAuth = create_auth_and_params_1.default({
                operation: "DISCONNECT",
                entity: parentNode,
                context,
                where: { varName: parentVar, node: parentNode },
            });
            if (whereAuth[0]) {
                res.disconnects.push(`WITH ${withVars.join(", ")}`);
                res.disconnects.push(`WHERE ${whereAuth[0]}`);
                res.params = Object.assign(Object.assign({}, res.params), whereAuth[1]);
            }
        }
        res.disconnects.push(`WITH ${withVars.join(", ")}`);
        res.disconnects.push(`OPTIONAL MATCH (${parentVar})${inStr}${relTypeStr}${outStr}(${_varName}:${labelOverride || relationField.typeMeta.name})`);
        const whereStrs = [];
        if (disconnect.where) {
            const where = create_where_and_params_1.default({
                varName: _varName,
                whereInput: disconnect.where,
                node: refNode,
                context,
                recursing: true,
            });
            if (where[0]) {
                whereStrs.push(where[0]);
                res.params = Object.assign(Object.assign({}, res.params), where[1]);
            }
        }
        if (refNode.auth) {
            const whereAuth = create_auth_and_params_1.default({
                operation: "DISCONNECT",
                entity: refNode,
                context,
                where: { varName: _varName, node: refNode },
            });
            if (whereAuth[0]) {
                whereStrs.push(whereAuth[0]);
                res.params = Object.assign(Object.assign({}, res.params), whereAuth[1]);
            }
        }
        if (whereStrs.length) {
            res.disconnects.push(`WHERE ${whereStrs.join(" AND ")}`);
        }
        const preAuth = [parentNode, refNode].reduce((result, node, i) => {
            if (!node.auth) {
                return result;
            }
            const [str, params] = create_auth_and_params_1.default({
                entity: node,
                operation: "DISCONNECT",
                context,
                escapeQuotes: Boolean(insideDoWhen),
                allow: { parentNode: node, varName: _varName, chainStr: `${_varName}${node.name}${i}_allow` },
            });
            if (!str) {
                return result;
            }
            result.disconnects.push(str);
            result.params = Object.assign(Object.assign({}, result.params), params);
            return result;
        }, { disconnects: [], params: {} });
        if (preAuth.disconnects.length) {
            const quote = insideDoWhen ? `\\"` : `"`;
            res.disconnects.push(`WITH ${[...withVars, _varName, relVarName].join(", ")}`);
            res.disconnects.push(`CALL apoc.util.validate(NOT(${preAuth.disconnects.join(" AND ")}), ${quote}${constants_1.AUTH_FORBIDDEN_ERROR}${quote}, [0])`);
            res.params = Object.assign(Object.assign({}, res.params), preAuth.params);
        }
        /*
           Replace with subclauses https://neo4j.com/developer/kb/conditional-cypher-execution/
           https://neo4j.slack.com/archives/C02PUHA7C/p1603458561099100
        */
        res.disconnects.push(`FOREACH(_ IN CASE ${_varName} WHEN NULL THEN [] ELSE [1] END | `);
        res.disconnects.push(`DELETE ${_varName}_rel`);
        res.disconnects.push(`)`); // close FOREACH
        if (disconnect.disconnect) {
            const disconnects = (Array.isArray(disconnect.disconnect)
                ? disconnect.disconnect
                : [disconnect.disconnect]);
            disconnects.forEach((c) => {
                const reduced = Object.entries(c).reduce((r, [k, v]) => {
                    const relField = refNode.relationFields.find((x) => k.startsWith(x.fieldName));
                    let newRefNode;
                    if (relationField.union) {
                        const [modelName] = k.split(`${relationField.fieldName}_`).join("").split("_");
                        newRefNode = context.neoSchema.nodes.find((x) => x.name === modelName);
                    }
                    else {
                        newRefNode = context.neoSchema.nodes.find((x) => x.name === relField.typeMeta.name);
                    }
                    const recurse = createDisconnectAndParams({
                        withVars: [...withVars, _varName],
                        value: v,
                        varName: `${_varName}_${k}`,
                        relationField: relField,
                        parentVar: _varName,
                        context,
                        refNode: newRefNode,
                        parentNode: refNode,
                    });
                    r.disconnects.push(recurse[0]);
                    r.params = Object.assign(Object.assign({}, r.params), recurse[1]);
                    return r;
                }, { disconnects: [], params: {} });
                res.disconnects.push(reduced.disconnects.join("\n"));
                res.params = Object.assign(Object.assign({}, res.params), reduced.params);
            });
        }
        const postAuth = [parentNode, refNode].reduce((result, node, i) => {
            if (!node.auth) {
                return result;
            }
            const [str, params] = create_auth_and_params_1.default({
                entity: node,
                operation: "DISCONNECT",
                context,
                escapeQuotes: Boolean(insideDoWhen),
                skipRoles: true,
                skipIsAuthenticated: true,
                bind: { parentNode: node, varName: _varName, chainStr: `${_varName}${node.name}${i}_bind` },
            });
            if (!str) {
                return result;
            }
            result.disconnects.push(str);
            result.params = Object.assign(Object.assign({}, result.params), params);
            return result;
        }, { disconnects: [], params: {} });
        if (postAuth.disconnects.length) {
            const quote = insideDoWhen ? `\\"` : `"`;
            res.disconnects.push(`WITH ${[...withVars, _varName].join(", ")}`);
            res.disconnects.push(`CALL apoc.util.validate(NOT(${postAuth.disconnects.join(" AND ")}), ${quote}${constants_1.AUTH_FORBIDDEN_ERROR}${quote}, [0])`);
            res.params = Object.assign(Object.assign({}, res.params), postAuth.params);
        }
        return res;
    }
    const { disconnects, params } = (relationField.typeMeta.array ? value : [value]).reduce(reducer, {
        disconnects: [],
        params: {},
    });
    return [disconnects.join("\n"), params];
}
exports.default = createDisconnectAndParams;
//# sourceMappingURL=create-disconnect-and-params.js.map