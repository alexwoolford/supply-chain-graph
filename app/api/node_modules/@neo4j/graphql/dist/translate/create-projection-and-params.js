"use strict";
/*
 * Copyright (c) "Neo4j"
 * Neo4j Sweden AB [http://neo4j.com]
 *
 * This file is part of Neo4j.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
var __rest = (this && this.__rest) || function (s, e) {
    var t = {};
    for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)
        t[p] = s[p];
    if (s != null && typeof Object.getOwnPropertySymbols === "function")
        for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
            if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))
                t[p[i]] = s[p[i]];
        }
    return t;
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const create_where_and_params_1 = __importDefault(require("./create-where-and-params"));
const create_auth_and_params_1 = __importDefault(require("./create-auth-and-params"));
const constants_1 = require("../constants");
function createSkipLimitStr({ skip, limit }) {
    const hasSkip = typeof skip !== "undefined";
    const hasLimit = typeof limit !== "undefined";
    let skipLimitStr = "";
    if (hasSkip && !hasLimit) {
        skipLimitStr = `[${skip}..]`;
    }
    if (hasLimit && !hasSkip) {
        skipLimitStr = `[..${limit}]`;
    }
    if (hasLimit && hasSkip) {
        skipLimitStr = `[${skip}..${limit}]`;
    }
    return skipLimitStr;
}
function createNodeWhereAndParams({ whereInput, varName, context, node, authValidateStrs, chainStr, }) {
    const whereStrs = [];
    let params = {};
    if (whereInput) {
        const whereAndParams = create_where_and_params_1.default({
            context,
            node,
            varName,
            whereInput,
            chainStr,
            recursing: true,
        });
        if (whereAndParams[0]) {
            whereStrs.push(whereAndParams[0]);
            params = Object.assign(Object.assign({}, params), whereAndParams[1]);
        }
    }
    const whereAuth = create_auth_and_params_1.default({
        entity: node,
        operation: "READ",
        context,
        where: {
            varName,
            chainStr,
            node,
        },
    });
    if (whereAuth[0]) {
        whereStrs.push(whereAuth[0]);
        params = Object.assign(Object.assign({}, params), whereAuth[1]);
    }
    const preAuth = create_auth_and_params_1.default({
        entity: node,
        operation: "READ",
        context,
        allow: {
            parentNode: node,
            varName,
            chainStr,
        },
    });
    if (preAuth[0]) {
        whereStrs.push(`apoc.util.validatePredicate(NOT(${preAuth[0]}), "${constants_1.AUTH_FORBIDDEN_ERROR}", [0])`);
        params = Object.assign(Object.assign({}, params), preAuth[1]);
    }
    if (authValidateStrs === null || authValidateStrs === void 0 ? void 0 : authValidateStrs.length) {
        whereStrs.push(`apoc.util.validatePredicate(NOT(${authValidateStrs.join(" AND ")}), "${constants_1.AUTH_FORBIDDEN_ERROR}", [0])`);
    }
    return [whereStrs.join(" AND "), params];
}
function createProjectionAndParams({ fieldsByTypeName, node, context, chainStr, varName, }) {
    function reducer(res, [k, field]) {
        var _a, _b, _c, _d, _e;
        let key = k;
        const alias = field.alias !== field.name ? field.alias : undefined;
        if (alias) {
            key = field.name;
        }
        let param = "";
        if (chainStr) {
            param = `${chainStr}_${key}`;
        }
        else {
            param = `${varName}_${key}`;
        }
        const whereInput = field.args.where;
        const optionsInput = field.args.options;
        const fieldFields = field.fieldsByTypeName;
        const cypherField = node.cypherFields.find((x) => x.fieldName === key);
        const relationField = node.relationFields.find((x) => x.fieldName === key);
        const pointField = node.pointFields.find((x) => x.fieldName === key);
        const dateTimeField = node.dateTimeFields.find((x) => x.fieldName === key);
        const authableField = node.authableFields.find((x) => x.fieldName === key);
        if (authableField) {
            if (authableField.auth) {
                const allowAndParams = create_auth_and_params_1.default({
                    entity: authableField,
                    operation: "READ",
                    context,
                    allow: { parentNode: node, varName, chainStr: param },
                });
                if (allowAndParams[0]) {
                    if (!res.meta) {
                        res.meta = { authValidateStrs: [] };
                    }
                    (_b = (_a = res.meta) === null || _a === void 0 ? void 0 : _a.authValidateStrs) === null || _b === void 0 ? void 0 : _b.push(allowAndParams[0]);
                    res.params = Object.assign(Object.assign({}, res.params), allowAndParams[1]);
                }
            }
        }
        if (cypherField) {
            let projectionAuthStr = "";
            let projectionStr = "";
            const isPrimitive = ["ID", "String", "Boolean", "Float", "Int", "DateTime", "BigInt"].includes(cypherField.typeMeta.name);
            const isEnum = context.neoSchema.document.definitions.find((x) => x.kind === "EnumTypeDefinition" && x.name.value === cypherField.typeMeta.name);
            const referenceNode = context.neoSchema.nodes.find((x) => x.name === cypherField.typeMeta.name);
            if (referenceNode) {
                const recurse = createProjectionAndParams({
                    fieldsByTypeName: fieldFields,
                    node: referenceNode || node,
                    context,
                    varName: `${varName}_${key}`,
                    chainStr: param,
                });
                [projectionStr] = recurse;
                res.params = Object.assign(Object.assign({}, res.params), recurse[1]);
                if ((_d = (_c = recurse[2]) === null || _c === void 0 ? void 0 : _c.authValidateStrs) === null || _d === void 0 ? void 0 : _d.length) {
                    projectionAuthStr = recurse[2].authValidateStrs.join(" AND ");
                }
            }
            const apocParams = Object.entries(field.args).reduce((r, entry) => {
                const argName = `${param}_${entry[0]}`;
                return {
                    strs: [...r.strs, `${entry[0]}: $${argName}`],
                    params: Object.assign(Object.assign({}, r.params), { [argName]: entry[1] }),
                };
            }, { strs: ["auth: $auth"], params: {} });
            res.params = Object.assign(Object.assign({}, res.params), apocParams.params);
            const expectMultipleValues = referenceNode && cypherField.typeMeta.array ? "true" : "false";
            const apocWhere = `${projectionAuthStr
                ? `WHERE apoc.util.validatePredicate(NOT(${projectionAuthStr}), "${constants_1.AUTH_FORBIDDEN_ERROR}", [0])`
                : ""}`;
            const apocParamsStr = `{this: ${chainStr || varName}${apocParams.strs.length ? `, ${apocParams.strs.join(", ")}` : ""}}`;
            const apocStr = `${!isPrimitive && !isEnum ? `${param} IN` : ""} apoc.cypher.runFirstColumn("${cypherField.statement}", ${apocParamsStr}, ${expectMultipleValues}) ${apocWhere} ${projectionStr ? `| ${param} ${projectionStr}` : ""}`;
            if (cypherField.typeMeta.array) {
                res.projection.push(`${key}: [${apocStr}]`);
                return res;
            }
            if (isPrimitive || isEnum) {
                res.projection.push(`${key}: ${apocStr}`);
                return res;
            }
            res.projection.push(`${key}: head([${apocStr}])`);
            return res;
        }
        if (relationField) {
            const referenceNode = context.neoSchema.nodes.find((x) => x.name === relationField.typeMeta.name);
            const nodeMatchStr = `(${chainStr || varName})`;
            const inStr = relationField.direction === "IN" ? "<-" : "-";
            const relTypeStr = `[:${relationField.type}]`;
            const outStr = relationField.direction === "OUT" ? "->" : "-";
            const nodeOutStr = `(${param}:${referenceNode === null || referenceNode === void 0 ? void 0 : referenceNode.name})`;
            const isArray = relationField.typeMeta.array;
            if (relationField.union) {
                const referenceNodes = context.neoSchema.nodes.filter((x) => { var _a, _b; return (_b = (_a = relationField.union) === null || _a === void 0 ? void 0 : _a.nodes) === null || _b === void 0 ? void 0 : _b.includes(x.name); });
                const unionStrs = [
                    `${key}: ${!isArray ? "head(" : ""} [(${chainStr || varName})${inStr}${relTypeStr}${outStr}(${param})`,
                    `WHERE ${referenceNodes.map((x) => `"${x.name}" IN labels(${param})`).join(" OR ")}`,
                    `| head(`,
                ];
                const headStrs = referenceNodes.map((refNode) => {
                    var _a;
                    const innerHeadStr = [
                        `[ ${param} IN [${param}] WHERE "${refNode.name}" IN labels (${param})`,
                    ];
                    if (field.fieldsByTypeName[refNode.name]) {
                        const recurse = createProjectionAndParams({
                            // @ts-ignore
                            fieldsByTypeName: field.fieldsByTypeName,
                            node: refNode,
                            context,
                            varName: param,
                        });
                        const nodeWhereAndParams = createNodeWhereAndParams({
                            whereInput: field.args[refNode.name],
                            context,
                            node: refNode,
                            varName: param,
                            chainStr: `${param}_${refNode.name}`,
                            authValidateStrs: (_a = recurse[2]) === null || _a === void 0 ? void 0 : _a.authValidateStrs,
                        });
                        if (nodeWhereAndParams[0]) {
                            innerHeadStr.push(`AND ${nodeWhereAndParams[0]}`);
                            res.params = Object.assign(Object.assign({}, res.params), nodeWhereAndParams[1]);
                        }
                        innerHeadStr.push([
                            `| ${param} { __resolveType: "${refNode.name}", `,
                            ...recurse[0].replace("{", "").split(""),
                        ].join(""));
                        res.params = Object.assign(Object.assign({}, res.params), recurse[1]);
                    }
                    else {
                        innerHeadStr.push(`| ${param} { __resolveType: "${refNode.name}" } `);
                    }
                    innerHeadStr.push(`]`);
                    return innerHeadStr.join(" ");
                });
                unionStrs.push(headStrs.join(" + "));
                unionStrs.push(") ]");
                if (optionsInput) {
                    const skipLimit = createSkipLimitStr({ skip: optionsInput.skip, limit: optionsInput.limit });
                    if (skipLimit) {
                        unionStrs.push(skipLimit);
                    }
                }
                unionStrs.push(`${!isArray ? ")" : ""}`);
                res.projection.push(unionStrs.join(" "));
                return res;
            }
            let projectionStr = "";
            const recurse = createProjectionAndParams({
                fieldsByTypeName: fieldFields,
                node: referenceNode || node,
                context,
                varName: `${varName}_${key}`,
                chainStr: param,
            });
            [projectionStr] = recurse;
            res.params = Object.assign(Object.assign({}, res.params), recurse[1]);
            let whereStr = "";
            const nodeWhereAndParams = createNodeWhereAndParams({
                whereInput,
                varName: `${varName}_${key}`,
                node: referenceNode,
                context,
                authValidateStrs: (_e = recurse[2]) === null || _e === void 0 ? void 0 : _e.authValidateStrs,
            });
            if (nodeWhereAndParams[0]) {
                whereStr = `WHERE ${nodeWhereAndParams[0]}`;
                res.params = Object.assign(Object.assign({}, res.params), nodeWhereAndParams[1]);
            }
            const pathStr = `${nodeMatchStr}${inStr}${relTypeStr}${outStr}${nodeOutStr}`;
            const innerStr = `${pathStr}  ${whereStr} | ${param} ${projectionStr}`;
            let nestedQuery;
            if (optionsInput) {
                const skipLimit = createSkipLimitStr({ skip: optionsInput.skip, limit: optionsInput.limit });
                if (optionsInput.sort) {
                    const sorts = optionsInput.sort.reduce((s, sort) => {
                        return [
                            ...s,
                            ...Object.entries(sort).map(([fieldName, direction]) => {
                                if (direction === "DESC") {
                                    return `'${fieldName}'`;
                                }
                                return `'^${fieldName}'`;
                            }),
                        ];
                    }, []);
                    nestedQuery = `${key}: apoc.coll.sortMulti([ ${innerStr} ], [${sorts.join(", ")}])${skipLimit}`;
                }
                else {
                    nestedQuery = `${key}: ${!isArray ? "head(" : ""}[ ${innerStr} ]${skipLimit}${!isArray ? ")" : ""}`;
                }
            }
            else {
                nestedQuery = `${key}: ${!isArray ? "head(" : ""}[ ${innerStr} ]${!isArray ? ")" : ""}`;
            }
            res.projection.push(nestedQuery);
            return res;
        }
        if (pointField) {
            const isArray = pointField.typeMeta.array;
            const _f = fieldFields[pointField.typeMeta.name], { crs } = _f, point = __rest(_f, ["crs"]);
            const fields = [];
            // Sadly need to select the whole point object due to the risk of height/z
            // being selected on a 2D point, to which the database will throw an error
            if (point) {
                fields.push(isArray ? "point:p" : `point: ${varName}.${key}`);
            }
            if (crs) {
                fields.push(isArray ? "crs: p.crs" : `crs: ${varName}.${key}.crs`);
            }
            res.projection.push(isArray
                ? `${key}: [p in ${varName}.${key} | { ${fields.join(", ")} }]`
                : `${key}: { ${fields.join(", ")} }`);
        }
        else if (dateTimeField) {
            res.projection.push(dateTimeField.typeMeta.array
                ? `${key}: [ dt in ${varName}.${key} | apoc.date.convertFormat(toString(dt), "iso_zoned_date_time", "iso_offset_date_time") ]`
                : `${key}: apoc.date.convertFormat(toString(${varName}.${key}), "iso_zoned_date_time", "iso_offset_date_time")`);
        }
        else {
            res.projection.push(`.${key}`);
        }
        return res;
    }
    const { projection, params, meta } = Object.entries(fieldsByTypeName[node.name]).reduce(reducer, {
        projection: [],
        params: {},
    });
    return [`{ ${projection.join(", ")} }`, params, meta];
}
exports.default = createProjectionAndParams;
//# sourceMappingURL=create-projection-and-params.js.map