"use strict";
/*
 * Copyright (c) "Neo4j"
 * Neo4j Sweden AB [http://neo4j.com]
 *
 * This file is part of Neo4j.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
Object.defineProperty(exports, "__esModule", { value: true });
function createWhereAndParams({ whereInput, varName, chainStr, node, context, recursing, }) {
    if (!Object.keys(whereInput).length) {
        return ["", {}];
    }
    function reducer(res, [key, value]) {
        var _a, _b, _c, _d, _e, _f, _g, _h, _j, _k, _l, _m, _o, _p, _q, _r;
        let param = "";
        if (chainStr) {
            param = `${chainStr}_${key}`;
        }
        else {
            param = `${varName}_${key}`;
        }
        const pointField = node.pointFields.find((x) => key.startsWith(x.fieldName));
        if (key.endsWith("_NOT")) {
            const [fieldName] = key.split("_NOT");
            const relationField = node.relationFields.find((x) => fieldName === x.fieldName);
            const coalesceValue = (_a = [...node.primitiveFields, ...node.dateTimeFields].find((f) => fieldName === f.fieldName)) === null || _a === void 0 ? void 0 : _a.coalesceValue;
            const property = coalesceValue !== undefined
                ? `coalesce(${varName}.${fieldName}, ${coalesceValue})`
                : `${varName}.${fieldName}`;
            if (relationField) {
                const refNode = context.neoSchema.nodes.find((x) => x.name === relationField.typeMeta.name);
                const inStr = relationField.direction === "IN" ? "<-" : "-";
                const outStr = relationField.direction === "OUT" ? "->" : "-";
                const relTypeStr = `[:${relationField.type}]`;
                if (value === null) {
                    res.clauses.push(`EXISTS((${varName})${inStr}${relTypeStr}${outStr}(:${relationField.typeMeta.name}))`);
                    return res;
                }
                let resultStr = [
                    `EXISTS((${varName})${inStr}${relTypeStr}${outStr}(:${relationField.typeMeta.name}))`,
                    `AND NONE(${param} IN [(${varName})${inStr}${relTypeStr}${outStr}(${param}:${relationField.typeMeta.name}) | ${param}] INNER_WHERE `,
                ].join(" ");
                const recurse = createWhereAndParams({
                    whereInput: value,
                    varName: param,
                    chainStr: param,
                    node: refNode,
                    context,
                    recursing: true,
                });
                resultStr += recurse[0];
                resultStr += ")"; // close ALL
                res.clauses.push(resultStr);
                res.params = Object.assign(Object.assign({}, res.params), recurse[1]);
                return res;
            }
            if (value === null) {
                res.clauses.push(`${varName}.${fieldName} IS NOT NULL`);
                return res;
            }
            if (pointField) {
                if (pointField.typeMeta.array) {
                    res.clauses.push(`(NOT ${varName}.${fieldName} = [p in $${param} | point(p)])`);
                }
                else {
                    res.clauses.push(`(NOT ${varName}.${fieldName} = point($${param}))`);
                }
            }
            else {
                res.clauses.push(`(NOT ${property} = $${param})`);
            }
            res.params[param] = value;
            return res;
        }
        if (key.endsWith("_NOT_IN")) {
            const [fieldName] = key.split("_NOT_IN");
            const relationField = node.relationFields.find((x) => fieldName === x.fieldName);
            const coalesceValue = (_b = [...node.primitiveFields, ...node.dateTimeFields].find((f) => fieldName === f.fieldName)) === null || _b === void 0 ? void 0 : _b.coalesceValue;
            const property = coalesceValue !== undefined
                ? `coalesce(${varName}.${fieldName}, ${coalesceValue})`
                : `${varName}.${fieldName}`;
            if (relationField) {
                const refNode = context.neoSchema.nodes.find((x) => x.name === relationField.typeMeta.name);
                const inStr = relationField.direction === "IN" ? "<-" : "-";
                const outStr = relationField.direction === "OUT" ? "->" : "-";
                const relTypeStr = `[:${relationField.type}]`;
                let resultStr = [
                    `EXISTS((${varName})${inStr}${relTypeStr}${outStr}(:${relationField.typeMeta.name}))`,
                    `AND ALL(${param} IN [(${varName})${inStr}${relTypeStr}${outStr}(${param}:${relationField.typeMeta.name}) | ${param}] INNER_WHERE NOT(`,
                ].join(" ");
                const inner = [];
                value.forEach((v, i) => {
                    const recurse = createWhereAndParams({
                        whereInput: v,
                        varName: param,
                        chainStr: `${param}${i}`,
                        node: refNode,
                        context,
                        recursing: true,
                    });
                    inner.push(recurse[0]);
                    res.params = Object.assign(Object.assign({}, res.params), recurse[1]);
                });
                resultStr += inner.join(" OR ");
                resultStr += ")"; // close NOT
                resultStr += ")"; // close ALL
                res.clauses.push(resultStr);
            }
            else if (pointField) {
                res.clauses.push(`(NOT ${varName}.${fieldName} IN [p in $${param} | point(p)])`);
                res.params[param] = value;
            }
            else {
                res.clauses.push(`(NOT ${property} IN $${param})`);
                res.params[param] = value;
            }
            return res;
        }
        if (key.endsWith("_IN")) {
            const [fieldName] = key.split("_IN");
            const relationField = node.relationFields.find((x) => fieldName === x.fieldName);
            const coalesceValue = (_c = [...node.primitiveFields, ...node.dateTimeFields].find((f) => fieldName === f.fieldName)) === null || _c === void 0 ? void 0 : _c.coalesceValue;
            const property = coalesceValue !== undefined
                ? `coalesce(${varName}.${fieldName}, ${coalesceValue})`
                : `${varName}.${fieldName}`;
            if (relationField) {
                const refNode = context.neoSchema.nodes.find((x) => x.name === relationField.typeMeta.name);
                const inStr = relationField.direction === "IN" ? "<-" : "-";
                const outStr = relationField.direction === "OUT" ? "->" : "-";
                const relTypeStr = `[:${relationField.type}]`;
                let resultStr = [
                    `EXISTS((${varName})${inStr}${relTypeStr}${outStr}(:${relationField.typeMeta.name}))`,
                    `AND ALL(${param} IN [(${varName})${inStr}${relTypeStr}${outStr}(${param}:${relationField.typeMeta.name}) | ${param}] INNER_WHERE `,
                ].join(" ");
                const inner = [];
                value.forEach((v, i) => {
                    const recurse = createWhereAndParams({
                        whereInput: v,
                        varName: param,
                        chainStr: `${param}${i}`,
                        node: refNode,
                        context,
                        recursing: true,
                    });
                    inner.push(recurse[0]);
                    res.params = Object.assign(Object.assign({}, res.params), recurse[1]);
                });
                resultStr += inner.join(" OR ");
                resultStr += ")"; // close ALL
                res.clauses.push(resultStr);
            }
            else if (pointField) {
                res.clauses.push(`${varName}.${fieldName} IN [p in $${param} | point(p)]`);
                res.params[param] = value;
            }
            else {
                res.clauses.push(`${property} IN $${param}`);
                res.params[param] = value;
            }
            return res;
        }
        if (key.endsWith("_NOT_INCLUDES")) {
            const [fieldName] = key.split("_NOT_INCLUDES");
            const coalesceValue = (_d = [...node.primitiveFields, ...node.dateTimeFields].find((f) => fieldName === f.fieldName)) === null || _d === void 0 ? void 0 : _d.coalesceValue;
            const property = coalesceValue !== undefined
                ? `coalesce(${varName}.${fieldName}, ${coalesceValue})`
                : `${varName}.${fieldName}`;
            if (pointField) {
                res.clauses.push(`(NOT point($${param}) IN ${varName}.${fieldName})`);
                res.params[param] = value;
            }
            else {
                res.clauses.push(`(NOT $${param} IN ${property})`);
                res.params[param] = value;
            }
            return res;
        }
        if (key.endsWith("_INCLUDES")) {
            const [fieldName] = key.split("_INCLUDES");
            const coalesceValue = (_e = [...node.primitiveFields, ...node.dateTimeFields].find((f) => fieldName === f.fieldName)) === null || _e === void 0 ? void 0 : _e.coalesceValue;
            const property = coalesceValue !== undefined
                ? `coalesce(${varName}.${fieldName}, ${coalesceValue})`
                : `${varName}.${fieldName}`;
            if (pointField) {
                res.clauses.push(`point($${param}) IN ${varName}.${fieldName}`);
                res.params[param] = value;
            }
            else {
                res.clauses.push(`$${param} IN ${property}`);
                res.params[param] = value;
            }
            return res;
        }
        const equalityRelation = node.relationFields.find((x) => key === x.fieldName);
        if (equalityRelation) {
            const refNode = context.neoSchema.nodes.find((x) => x.name === equalityRelation.typeMeta.name);
            const inStr = equalityRelation.direction === "IN" ? "<-" : "-";
            const outStr = equalityRelation.direction === "OUT" ? "->" : "-";
            const relTypeStr = `[:${equalityRelation.type}]`;
            if (value === null) {
                res.clauses.push(`NOT EXISTS((${varName})${inStr}${relTypeStr}${outStr}(:${equalityRelation.typeMeta.name}))`);
                return res;
            }
            let resultStr = [
                `EXISTS((${varName})${inStr}${relTypeStr}${outStr}(:${equalityRelation.typeMeta.name}))`,
                `AND ALL(${param} IN [(${varName})${inStr}${relTypeStr}${outStr}(${param}:${equalityRelation.typeMeta.name}) | ${param}] INNER_WHERE `,
            ].join(" ");
            const recurse = createWhereAndParams({
                whereInput: value,
                varName: param,
                chainStr: param,
                node: refNode,
                context,
                recursing: true,
            });
            resultStr += recurse[0];
            resultStr += ")"; // close ALL
            res.clauses.push(resultStr);
            res.params = Object.assign(Object.assign({}, res.params), recurse[1]);
            return res;
        }
        if (key.endsWith("_MATCHES")) {
            const [fieldName] = key.split("_MATCHES");
            const coalesceValue = (_f = node.primitiveFields.find((f) => fieldName === f.fieldName)) === null || _f === void 0 ? void 0 : _f.coalesceValue;
            const property = coalesceValue !== undefined
                ? `coalesce(${varName}.${fieldName}, ${coalesceValue})`
                : `${varName}.${fieldName}`;
            res.clauses.push(`${property} =~ $${param}`);
            res.params[param] = value;
            return res;
        }
        if (key.endsWith("_NOT_CONTAINS")) {
            const [fieldName] = key.split("_NOT_CONTAINS");
            const coalesceValue = (_g = node.primitiveFields.find((f) => fieldName === f.fieldName)) === null || _g === void 0 ? void 0 : _g.coalesceValue;
            const property = coalesceValue !== undefined
                ? `coalesce(${varName}.${fieldName}, ${coalesceValue})`
                : `${varName}.${fieldName}`;
            res.clauses.push(`(NOT ${property} CONTAINS $${param})`);
            res.params[param] = value;
            return res;
        }
        if (key.endsWith("_CONTAINS")) {
            const [fieldName] = key.split("_CONTAINS");
            const coalesceValue = (_h = node.primitiveFields.find((f) => fieldName === f.fieldName)) === null || _h === void 0 ? void 0 : _h.coalesceValue;
            const property = coalesceValue !== undefined
                ? `coalesce(${varName}.${fieldName}, ${coalesceValue})`
                : `${varName}.${fieldName}`;
            res.clauses.push(`${property} CONTAINS $${param}`);
            res.params[param] = value;
            return res;
        }
        if (key.endsWith("_NOT_STARTS_WITH")) {
            const [fieldName] = key.split("_NOT_STARTS_WITH");
            const coalesceValue = (_j = node.primitiveFields.find((f) => fieldName === f.fieldName)) === null || _j === void 0 ? void 0 : _j.coalesceValue;
            const property = coalesceValue !== undefined
                ? `coalesce(${varName}.${fieldName}, ${coalesceValue})`
                : `${varName}.${fieldName}`;
            res.clauses.push(`(NOT ${property} STARTS WITH $${param})`);
            res.params[param] = value;
            return res;
        }
        if (key.endsWith("_STARTS_WITH")) {
            const [fieldName] = key.split("_STARTS_WITH");
            const coalesceValue = (_k = node.primitiveFields.find((f) => fieldName === f.fieldName)) === null || _k === void 0 ? void 0 : _k.coalesceValue;
            const property = coalesceValue !== undefined
                ? `coalesce(${varName}.${fieldName}, ${coalesceValue})`
                : `${varName}.${fieldName}`;
            res.clauses.push(`${property} STARTS WITH $${param}`);
            res.params[param] = value;
            return res;
        }
        if (key.endsWith("_NOT_ENDS_WITH")) {
            const [fieldName] = key.split("_NOT_ENDS_WITH");
            const coalesceValue = (_l = node.primitiveFields.find((f) => fieldName === f.fieldName)) === null || _l === void 0 ? void 0 : _l.coalesceValue;
            const property = coalesceValue !== undefined
                ? `coalesce(${varName}.${fieldName}, ${coalesceValue})`
                : `${varName}.${fieldName}`;
            res.clauses.push(`(NOT ${property} ENDS WITH $${param})`);
            res.params[param] = value;
            return res;
        }
        if (key.endsWith("_ENDS_WITH")) {
            const [fieldName] = key.split("_ENDS_WITH");
            const coalesceValue = (_m = node.primitiveFields.find((f) => fieldName === f.fieldName)) === null || _m === void 0 ? void 0 : _m.coalesceValue;
            const property = coalesceValue !== undefined
                ? `coalesce(${varName}.${fieldName}, ${coalesceValue})`
                : `${varName}.${fieldName}`;
            res.clauses.push(`${property} ENDS WITH $${param}`);
            res.params[param] = value;
            return res;
        }
        if (key.endsWith("_LT")) {
            const [fieldName] = key.split("_LT");
            const coalesceValue = (_o = [...node.primitiveFields, ...node.dateTimeFields].find((f) => fieldName === f.fieldName)) === null || _o === void 0 ? void 0 : _o.coalesceValue;
            const property = coalesceValue !== undefined
                ? `coalesce(${varName}.${fieldName}, ${coalesceValue})`
                : `${varName}.${fieldName}`;
            res.clauses.push(pointField
                ? `distance(${varName}.${fieldName}, point($${param}.point)) < $${param}.distance`
                : `${property} < $${param}`);
            res.params[param] = value;
            return res;
        }
        if (key.endsWith("_LTE")) {
            const [fieldName] = key.split("_LTE");
            const coalesceValue = (_p = [...node.primitiveFields, ...node.dateTimeFields].find((f) => fieldName === f.fieldName)) === null || _p === void 0 ? void 0 : _p.coalesceValue;
            const property = coalesceValue !== undefined
                ? `coalesce(${varName}.${fieldName}, ${coalesceValue})`
                : `${varName}.${fieldName}`;
            res.clauses.push(pointField
                ? `distance(${varName}.${fieldName}, point($${param}.point)) <= $${param}.distance`
                : `${property} <= $${param}`);
            res.params[param] = value;
            return res;
        }
        if (key.endsWith("_GT")) {
            const [fieldName] = key.split("_GT");
            const coalesceValue = (_q = [...node.primitiveFields, ...node.dateTimeFields].find((f) => fieldName === f.fieldName)) === null || _q === void 0 ? void 0 : _q.coalesceValue;
            const property = coalesceValue !== undefined
                ? `coalesce(${varName}.${fieldName}, ${coalesceValue})`
                : `${varName}.${fieldName}`;
            res.clauses.push(pointField
                ? `distance(${varName}.${fieldName}, point($${param}.point)) > $${param}.distance`
                : `${property} > $${param}`);
            res.params[param] = value;
            return res;
        }
        if (key.endsWith("_GTE")) {
            const [fieldName] = key.split("_GTE");
            const coalesceValue = (_r = [...node.primitiveFields, ...node.dateTimeFields].find((f) => fieldName === f.fieldName)) === null || _r === void 0 ? void 0 : _r.coalesceValue;
            const property = coalesceValue !== undefined
                ? `coalesce(${varName}.${fieldName}, ${coalesceValue})`
                : `${varName}.${fieldName}`;
            res.clauses.push(pointField
                ? `distance(${varName}.${fieldName}, point($${param}.point)) >= $${param}.distance`
                : `${property} >= $${param}`);
            res.params[param] = value;
            return res;
        }
        if (key.endsWith("_DISTANCE")) {
            const [fieldName] = key.split("_DISTANCE");
            res.clauses.push(`distance(${varName}.${fieldName}, point($${param}.point)) = $${param}.distance`);
            res.params[param] = value;
            return res;
        }
        if (["AND", "OR"].includes(key)) {
            const innerClauses = [];
            value.forEach((v, i) => {
                const recurse = createWhereAndParams({
                    whereInput: v,
                    varName,
                    chainStr: `${param}${i > 0 ? i : ""}`,
                    node,
                    context,
                    recursing: true,
                });
                innerClauses.push(`${recurse[0]}`);
                res.params = Object.assign(Object.assign({}, res.params), recurse[1]);
            });
            res.clauses.push(`(${innerClauses.join(` ${key} `)})`);
            return res;
        }
        if (value === null) {
            res.clauses.push(`${varName}.${key} IS NULL`);
            return res;
        }
        if (pointField) {
            if (pointField.typeMeta.array) {
                res.clauses.push(`${varName}.${key} = [p in $${param} | point(p)]`);
            }
            else {
                res.clauses.push(`${varName}.${key} = point($${param})`);
            }
        }
        else {
            const field = [...node.primitiveFields, ...node.dateTimeFields].find((f) => key === f.fieldName);
            const property = (field === null || field === void 0 ? void 0 : field.coalesceValue) !== undefined
                ? `coalesce(${varName}.${field.fieldName}, ${field.coalesceValue})`
                : `${varName}.${key}`;
            res.clauses.push(`${property} = $${param}`);
        }
        res.params[param] = value;
        return res;
    }
    const { clauses, params } = Object.entries(whereInput).reduce(reducer, { clauses: [], params: {} });
    let where = `${!recursing ? "WHERE " : ""}`;
    where += clauses.join(" AND ").replace(/INNER_WHERE/gi, "WHERE");
    return [where, params];
}
exports.default = createWhereAndParams;
//# sourceMappingURL=create-where-and-params.js.map