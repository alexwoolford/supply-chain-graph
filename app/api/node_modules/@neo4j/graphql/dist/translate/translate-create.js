"use strict";
/*
 * Copyright (c) "Neo4j"
 * Neo4j Sweden AB [http://neo4j.com]
 *
 * This file is part of Neo4j.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const camelcase_1 = __importDefault(require("camelcase"));
const pluralize_1 = __importDefault(require("pluralize"));
const create_projection_and_params_1 = __importDefault(require("./create-projection-and-params"));
const create_create_and_params_1 = __importDefault(require("./create-create-and-params"));
const constants_1 = require("../constants");
function translateCreate({ context, node }) {
    var _a, _b;
    const { resolveTree } = context;
    const { fieldsByTypeName } = resolveTree.fieldsByTypeName[`Create${pluralize_1.default(node.name)}MutationResponse`][pluralize_1.default(camelcase_1.default(node.name))];
    const { createStrs, params } = resolveTree.args.input.reduce((res, input, index) => {
        const varName = `this${index}`;
        const create = [`CALL {`];
        const createAndParams = create_create_and_params_1.default({
            input,
            node,
            context,
            varName,
            withVars: [varName],
        });
        create.push(`${createAndParams[0]}`);
        create.push(`RETURN ${varName}`);
        create.push(`}`);
        res.createStrs.push(create.join("\n"));
        res.params = Object.assign(Object.assign({}, res.params), createAndParams[1]);
        return res;
    }, { createStrs: [], params: {}, withVars: [] });
    /* so projection params don't conflict with create params. We only need to call createProjectionAndParams once. */
    let projAuth = "";
    const projection = create_projection_and_params_1.default({
        node,
        context,
        fieldsByTypeName,
        varName: "REPLACE_ME",
    });
    if ((_b = (_a = projection[2]) === null || _a === void 0 ? void 0 : _a.authValidateStrs) === null || _b === void 0 ? void 0 : _b.length) {
        projAuth = `CALL apoc.util.validate(NOT(${projection[2].authValidateStrs.join(" AND ")}), "${constants_1.AUTH_FORBIDDEN_ERROR}", [0])`;
    }
    const replacedProjectionParams = Object.entries(projection[1]).reduce((res, [key, value]) => {
        return Object.assign(Object.assign({}, res), { [key.replace("REPLACE_ME", "projection")]: value });
    }, {});
    const projectionStr = createStrs
        .map((_, i) => `\nthis${i} ${projection[0]
        .replace(/\$REPLACE_ME/g, "$projection")
        .replace(/REPLACE_ME/g, `this${i}`)} AS this${i}`)
        .join(", ");
    const authCalls = createStrs
        .map((_, i) => projAuth.replace(/\$REPLACE_ME/g, "$projection").replace(/REPLACE_ME/g, `this${i}`))
        .join("\n");
    const cypher = [`${createStrs.join("\n")}`, authCalls, `\nRETURN ${projectionStr}`];
    return [cypher.filter(Boolean).join("\n"), Object.assign(Object.assign({}, params), replacedProjectionParams)];
}
exports.default = translateCreate;
//# sourceMappingURL=translate-create.js.map