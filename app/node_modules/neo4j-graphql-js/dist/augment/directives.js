"use strict";

var _interopRequireDefault = require("@babel/runtime-corejs2/helpers/interopRequireDefault");

var _Object$defineProperty = require("@babel/runtime-corejs2/core-js/object/define-property");

var _Object$defineProperties = require("@babel/runtime-corejs2/core-js/object/define-properties");

var _Object$getOwnPropertyDescriptors = require("@babel/runtime-corejs2/core-js/object/get-own-property-descriptors");

var _Object$getOwnPropertyDescriptor = require("@babel/runtime-corejs2/core-js/object/get-own-property-descriptor");

var _Object$getOwnPropertySymbols = require("@babel/runtime-corejs2/core-js/object/get-own-property-symbols");

var _Object$keys = require("@babel/runtime-corejs2/core-js/object/keys");

_Object$defineProperty(exports, "__esModule", {
  value: true
});

exports.augmentDirectives = exports.getDirectiveArgument = exports.getDirective = exports.getRelationName = exports.getRelationDirection = exports.useAuthDirective = exports.buildAuthScopeDirective = exports.buildMutationMetaDirective = exports.augmentDirectiveDefinitions = exports.validateFieldDirectives = exports.isIndexedField = exports.isUniqueField = exports.isPrimaryKeyField = exports.isRelationField = exports.isIgnoredField = exports.isCypherField = exports.DirectiveDefinition = void 0;

var _typeof2 = _interopRequireDefault(require("@babel/runtime-corejs2/helpers/typeof"));

var _slicedToArray2 = _interopRequireDefault(require("@babel/runtime-corejs2/helpers/slicedToArray"));

var _defineProperty2 = _interopRequireDefault(require("@babel/runtime-corejs2/helpers/defineProperty"));

var _entries = _interopRequireDefault(require("@babel/runtime-corejs2/core-js/object/entries"));

var _graphql = require("graphql");

var _fields = require("./fields");

var _ast = require("./ast");

var _apolloServerErrors = require("apollo-server-errors");

var _AuthDirectiveDefinit, _directiveDefinitionB;

function ownKeys(object, enumerableOnly) { var keys = _Object$keys(object); if (_Object$getOwnPropertySymbols) { var symbols = _Object$getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return _Object$getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }

function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(Object(source), true).forEach(function (key) { (0, _defineProperty2["default"])(target, key, source[key]); }); } else if (_Object$getOwnPropertyDescriptors) { _Object$defineProperties(target, _Object$getOwnPropertyDescriptors(source)); } else { ownKeys(Object(source)).forEach(function (key) { _Object$defineProperty(target, key, _Object$getOwnPropertyDescriptor(source, key)); }); } } return target; }

/**
 * An enum describing the names of directive definitions and instances
 * used by this integration
 */
var DirectiveDefinition = {
  CYPHER: 'cypher',
  RELATION: 'relation',
  MUTATION_META: 'MutationMeta',
  NEO4J_IGNORE: 'neo4j_ignore',
  IS_AUTHENTICATED: 'isAuthenticated',
  HAS_ROLE: 'hasRole',
  HAS_SCOPE: 'hasScope',
  ADDITIONAL_LABELS: 'additionalLabels',
  ID: 'id',
  UNIQUE: 'unique',
  INDEX: 'index',
  SEARCH: 'search'
}; // The name of Role type used in authorization logic

exports.DirectiveDefinition = DirectiveDefinition;
var ROLE_TYPE = process.env.AUTH_ROLE_ENUM_NAME || 'Role';
/**
 * Enum for the names of directed fields on relationship types
 */

var RelationshipDirectionField = {
  FROM: 'from',
  TO: 'to'
};

var isCypherField = function isCypherField(_ref) {
  var _ref$directives = _ref.directives,
      directives = _ref$directives === void 0 ? [] : _ref$directives;
  return getDirective({
    directives: directives,
    name: DirectiveDefinition.CYPHER
  });
};

exports.isCypherField = isCypherField;

var isIgnoredField = function isIgnoredField(_ref2) {
  var _ref2$directives = _ref2.directives,
      directives = _ref2$directives === void 0 ? [] : _ref2$directives;
  return getDirective({
    directives: directives,
    name: DirectiveDefinition.NEO4J_IGNORE
  });
};

exports.isIgnoredField = isIgnoredField;

var isRelationField = function isRelationField(_ref3) {
  var _ref3$directives = _ref3.directives,
      directives = _ref3$directives === void 0 ? [] : _ref3$directives;
  return getDirective({
    directives: directives,
    name: DirectiveDefinition.RELATION
  });
};

exports.isRelationField = isRelationField;

var isPrimaryKeyField = function isPrimaryKeyField(_ref4) {
  var _ref4$directives = _ref4.directives,
      directives = _ref4$directives === void 0 ? [] : _ref4$directives;
  return getDirective({
    directives: directives,
    name: DirectiveDefinition.ID
  });
};

exports.isPrimaryKeyField = isPrimaryKeyField;

var isUniqueField = function isUniqueField(_ref5) {
  var _ref5$directives = _ref5.directives,
      directives = _ref5$directives === void 0 ? [] : _ref5$directives;
  return getDirective({
    directives: directives,
    name: DirectiveDefinition.UNIQUE
  });
};

exports.isUniqueField = isUniqueField;

var isIndexedField = function isIndexedField(_ref6) {
  var _ref6$directives = _ref6.directives,
      directives = _ref6$directives === void 0 ? [] : _ref6$directives;
  return getDirective({
    directives: directives,
    name: DirectiveDefinition.INDEX
  });
};

exports.isIndexedField = isIndexedField;

var validateFieldDirectives = function validateFieldDirectives(_ref7) {
  var _ref7$fields = _ref7.fields,
      fields = _ref7$fields === void 0 ? [] : _ref7$fields,
      _ref7$directives = _ref7.directives,
      directives = _ref7$directives === void 0 ? [] : _ref7$directives;
  var primaryKeyFields = fields.filter(function (field) {
    return isPrimaryKeyField({
      directives: field.directives
    });
  });
  if (primaryKeyFields.length > 1) throw new _apolloServerErrors.ApolloError("The @id directive can only be used once per node type.");
  var isPrimaryKey = isPrimaryKeyField({
    directives: directives
  });
  var isUnique = isUniqueField({
    directives: directives
  });
  var isIndex = isIndexedField({
    directives: directives
  });
  var isComputed = isCypherField({
    directives: directives
  });

  if (isComputed) {
    if (isPrimaryKey) throw new _apolloServerErrors.ApolloError("The @id directive cannot be used with the @cypher directive because computed fields are not stored as properties.");
    if (isUnique) throw new _apolloServerErrors.ApolloError("The @unique directive cannot be used with the @cypher directive because computed fields are not stored as properties.");
    if (isIndex) throw new _apolloServerErrors.ApolloError("The @index directive cannot used with the @cypher directive because computed fields are not stored as properties.");
  }

  if (isPrimaryKey && isUnique) throw new _apolloServerErrors.ApolloError("The @id and @unique directive combined are redunant. The @id directive already sets a unique property constraint and an index.");
  if (isPrimaryKey && isIndex) throw new _apolloServerErrors.ApolloError("The @id and @index directive combined are redundant. The @id directive already sets a unique property constraint and an index.");
  if (isUnique && isIndex) throw new _apolloServerErrors.ApolloError("The @unique and @index directive combined are redunant. The @unique directive sets both a unique property constraint and an index.");
};
/**
 * The main export for augmenting directive definitions
 */


exports.validateFieldDirectives = validateFieldDirectives;

var augmentDirectiveDefinitions = function augmentDirectiveDefinitions(_ref8) {
  var _ref8$typeDefinitionM = _ref8.typeDefinitionMap,
      typeDefinitionMap = _ref8$typeDefinitionM === void 0 ? {} : _ref8$typeDefinitionM,
      _ref8$directiveDefini = _ref8.directiveDefinitionMap,
      directiveDefinitionMap = _ref8$directiveDefini === void 0 ? {} : _ref8$directiveDefini,
      _ref8$config = _ref8.config,
      config = _ref8$config === void 0 ? {} : _ref8$config;
  // For each directive definition used by the integration
  (0, _entries["default"])(_objectSpread(_objectSpread({}, directiveDefinitionBuilderMap), AuthDirectiveDefinitionMap)).forEach(function (_ref9) {
    var _ref10 = (0, _slicedToArray2["default"])(_ref9, 2),
        name = _ref10[0],
        buildDefinition = _ref10[1];

    // If directive definition not provided
    if (!directiveDefinitionMap[name]) {
      // Try to build a config object for building the definition
      // AST node for this directive
      var astNodeConfig = buildDefinition({
        typeDefinitionMap: typeDefinitionMap,
        config: config
      });

      if (astNodeConfig) {
        if (astNodeConfig.args) {
          astNodeConfig.args = astNodeConfig.args.map(function (arg) {
            return (0, _ast.buildInputValue)({
              name: (0, _ast.buildName)({
                name: arg.name
              }),
              type: (0, _ast.buildNamedType)(arg.type)
            });
          });
        } // Build and map a new AST node for this directive


        directiveDefinitionMap[name] = (0, _ast.buildDirectiveDefinition)({
          name: (0, _ast.buildName)({
            name: name
          }),
          args: astNodeConfig.args,
          locations: astNodeConfig.locations.map(function (name) {
            return (0, _ast.buildName)({
              name: name
            });
          })
        });
      }
    }
  });
  var relationshipDirectionEnumName = '_RelationDirections';
  typeDefinitionMap[relationshipDirectionEnumName] = (0, _ast.buildEnumType)({
    name: (0, _ast.buildName)({
      name: relationshipDirectionEnumName
    }),
    values: [(0, _ast.buildEnumValue)({
      name: (0, _ast.buildName)({
        name: 'IN'
      })
    }), (0, _ast.buildEnumValue)({
      name: (0, _ast.buildName)({
        name: 'OUT'
      })
    })]
  });
  return [typeDefinitionMap, directiveDefinitionMap];
};
/**
 * Builds a MutationMeta directive for translating relationship mutations
 */


exports.augmentDirectiveDefinitions = augmentDirectiveDefinitions;

var buildMutationMetaDirective = function buildMutationMetaDirective(_ref11) {
  var relationshipName = _ref11.relationshipName,
      fromType = _ref11.fromType,
      toType = _ref11.toType;
  return (0, _ast.buildDirective)({
    name: (0, _ast.buildName)({
      name: DirectiveDefinition.MUTATION_META
    }),
    args: [(0, _ast.buildDirectiveArgument)({
      name: (0, _ast.buildName)({
        name: 'relationship'
      }),
      value: {
        kind: _graphql.Kind.STRING,
        value: relationshipName
      }
    }), (0, _ast.buildDirectiveArgument)({
      name: (0, _ast.buildName)({
        name: RelationshipDirectionField.FROM
      }),
      value: {
        kind: _graphql.Kind.STRING,
        value: fromType
      }
    }), (0, _ast.buildDirectiveArgument)({
      name: (0, _ast.buildName)({
        name: RelationshipDirectionField.TO
      }),
      value: {
        kind: _graphql.Kind.STRING,
        value: toType
      }
    })]
  });
};
/**
 * Builds the hasScope directive used in API authorization logic
 */


exports.buildMutationMetaDirective = buildMutationMetaDirective;

var buildAuthScopeDirective = function buildAuthScopeDirective(_ref12) {
  var _ref12$scopes = _ref12.scopes,
      scopes = _ref12$scopes === void 0 ? [] : _ref12$scopes;
  return (0, _ast.buildDirective)({
    name: (0, _ast.buildName)({
      name: DirectiveDefinition.HAS_SCOPE
    }),
    args: [(0, _ast.buildDirectiveArgument)({
      name: (0, _ast.buildName)({
        name: 'scopes'
      }),
      value: {
        kind: _graphql.Kind.LIST,
        values: scopes.flatMap(function (scope) {
          return [{
            kind: _graphql.Kind.STRING,
            value: "".concat(scope.typeName, ": ").concat(scope.mutation)
          }, {
            kind: _graphql.Kind.STRING,
            value: "".concat(scope.mutation, ":").concat(scope.typeName).toLowerCase()
          }];
        })
      }
    })]
  });
};
/**
 * A map of the AST configurations for directive definitions
 * used in API authorization logic
 */


exports.buildAuthScopeDirective = buildAuthScopeDirective;
var AuthDirectiveDefinitionMap = (_AuthDirectiveDefinit = {}, (0, _defineProperty2["default"])(_AuthDirectiveDefinit, DirectiveDefinition.IS_AUTHENTICATED, function (_ref13) {
  var config = _ref13.config;

  if (useAuthDirective(config, DirectiveDefinition.IS_AUTHENTICATED)) {
    return {
      name: DirectiveDefinition.IS_AUTHENTICATED,
      locations: [_graphql.DirectiveLocation.OBJECT, _graphql.DirectiveLocation.FIELD_DEFINITION]
    };
  }
}), (0, _defineProperty2["default"])(_AuthDirectiveDefinit, DirectiveDefinition.HAS_ROLE, function (_ref14) {
  var typeDefinitionMap = _ref14.typeDefinitionMap,
      config = _ref14.config;

  if (useAuthDirective(config, DirectiveDefinition.HAS_ROLE)) {
    var roleEnumType = typeDefinitionMap[ROLE_TYPE];
    if (!roleEnumType) throw new Error("A Role enum type is required for the @hasRole auth directive.");
    if (roleEnumType && roleEnumType.kind !== _graphql.Kind.ENUM_TYPE_DEFINITION) throw new Error("The Role type must be an Enum type");
    return {
      name: DirectiveDefinition.HAS_ROLE,
      args: [{
        name: 'roles',
        type: {
          name: ROLE_TYPE,
          wrappers: (0, _defineProperty2["default"])({}, _fields.TypeWrappers.LIST_TYPE, true)
        }
      }],
      locations: [_graphql.DirectiveLocation.OBJECT, _graphql.DirectiveLocation.FIELD_DEFINITION]
    };
  }
}), (0, _defineProperty2["default"])(_AuthDirectiveDefinit, DirectiveDefinition.HAS_SCOPE, function (_ref15) {
  var config = _ref15.config;

  if (useAuthDirective(config, DirectiveDefinition.HAS_SCOPE)) {
    return {
      name: DirectiveDefinition.HAS_SCOPE,
      args: [{
        name: 'scopes',
        type: {
          name: _graphql.GraphQLString,
          wrappers: (0, _defineProperty2["default"])({}, _fields.TypeWrappers.LIST_TYPE, true)
        }
      }],
      locations: [_graphql.DirectiveLocation.OBJECT, _graphql.DirectiveLocation.FIELD_DEFINITION]
    };
  }
}), _AuthDirectiveDefinit);
/**
 * Map of AST configs for ASTNodeBuilder
 */

var directiveDefinitionBuilderMap = (_directiveDefinitionB = {}, (0, _defineProperty2["default"])(_directiveDefinitionB, DirectiveDefinition.CYPHER, function (_ref16) {
  var config = _ref16.config;
  return {
    name: DirectiveDefinition.CYPHER,
    args: [{
      name: 'statement',
      type: {
        name: _graphql.GraphQLString
      }
    }],
    locations: [_graphql.DirectiveLocation.FIELD_DEFINITION, _graphql.DirectiveLocation.INPUT_FIELD_DEFINITION]
  };
}), (0, _defineProperty2["default"])(_directiveDefinitionB, DirectiveDefinition.RELATION, function (_ref17) {
  var config = _ref17.config;
  return {
    name: DirectiveDefinition.RELATION,
    args: [{
      name: 'name',
      type: {
        name: _graphql.GraphQLString
      }
    }, {
      name: 'direction',
      type: {
        name: '_RelationDirections'
      }
    }, {
      name: RelationshipDirectionField.FROM,
      type: {
        name: _graphql.GraphQLString
      }
    }, {
      name: RelationshipDirectionField.TO,
      type: {
        name: _graphql.GraphQLString
      }
    }],
    locations: [_graphql.DirectiveLocation.FIELD_DEFINITION, _graphql.DirectiveLocation.OBJECT]
  };
}), (0, _defineProperty2["default"])(_directiveDefinitionB, DirectiveDefinition.ADDITIONAL_LABELS, function (_ref18) {
  var config = _ref18.config;
  return {
    name: DirectiveDefinition.ADDITIONAL_LABELS,
    args: [{
      name: 'labels',
      type: {
        name: _graphql.GraphQLString,
        wrappers: (0, _defineProperty2["default"])({}, _fields.TypeWrappers.LIST_TYPE, true)
      }
    }],
    locations: [_graphql.DirectiveLocation.OBJECT]
  };
}), (0, _defineProperty2["default"])(_directiveDefinitionB, DirectiveDefinition.MUTATION_META, function (_ref19) {
  var config = _ref19.config;
  return {
    name: DirectiveDefinition.MUTATION_META,
    args: [{
      name: 'relationship',
      type: {
        name: _graphql.GraphQLString
      }
    }, {
      name: RelationshipDirectionField.FROM,
      type: {
        name: _graphql.GraphQLString
      }
    }, {
      name: RelationshipDirectionField.TO,
      type: {
        name: _graphql.GraphQLString
      }
    }],
    locations: [_graphql.DirectiveLocation.FIELD_DEFINITION]
  };
}), (0, _defineProperty2["default"])(_directiveDefinitionB, DirectiveDefinition.NEO4J_IGNORE, function (_ref20) {
  var config = _ref20.config;
  return {
    name: DirectiveDefinition.NEO4J_IGNORE,
    locations: [_graphql.DirectiveLocation.FIELD_DEFINITION]
  };
}), (0, _defineProperty2["default"])(_directiveDefinitionB, DirectiveDefinition.ID, function (_ref21) {
  var config = _ref21.config;
  return {
    name: DirectiveDefinition.ID,
    locations: [_graphql.DirectiveLocation.FIELD_DEFINITION]
  };
}), (0, _defineProperty2["default"])(_directiveDefinitionB, DirectiveDefinition.UNIQUE, function (_ref22) {
  var config = _ref22.config;
  return {
    name: DirectiveDefinition.UNIQUE,
    locations: [_graphql.DirectiveLocation.FIELD_DEFINITION]
  };
}), (0, _defineProperty2["default"])(_directiveDefinitionB, DirectiveDefinition.INDEX, function (_ref23) {
  var config = _ref23.config;
  return {
    name: DirectiveDefinition.INDEX,
    locations: [_graphql.DirectiveLocation.FIELD_DEFINITION]
  };
}), (0, _defineProperty2["default"])(_directiveDefinitionB, DirectiveDefinition.SEARCH, function (_ref24) {
  var config = _ref24.config;
  return {
    name: DirectiveDefinition.SEARCH,
    args: [{
      name: 'index',
      type: {
        name: _graphql.GraphQLString
      }
    }],
    locations: [_graphql.DirectiveLocation.FIELD_DEFINITION]
  };
}), _directiveDefinitionB);
/**
 * Predicate function for deciding whether to a given directive
 */

var useAuthDirective = function useAuthDirective(config, authDirective) {
  if (config && (0, _typeof2["default"])(config) === 'object') {
    return config.auth === true || config && (0, _typeof2["default"])(config.auth) === 'object' && config.auth[authDirective] === true;
  }

  return false;
};
/**
 * Gets the direction argument of the relation field directive
 */


exports.useAuthDirective = useAuthDirective;

var getRelationDirection = function getRelationDirection(relationDirective) {
  var direction = {};

  try {
    direction = relationDirective.arguments.filter(function (a) {
      return a.name.value === 'direction';
    })[0];
    return direction.value.value;
  } catch (e) {
    // FIXME: should we ignore this error to define default behavior?
    throw new Error('No direction argument specified on @relation directive');
  }
};
/**
 * Gets the name argument of a relation directive
 */


exports.getRelationDirection = getRelationDirection;

var getRelationName = function getRelationName(relationDirective) {
  var name = {};

  try {
    name = relationDirective.arguments.filter(function (a) {
      return a.name.value === 'name';
    })[0];
    return name.value.value;
  } catch (e) {
    // FIXME: should we ignore this error to define default behavior?
    throw new Error('No name argument specified on @relation directive');
  }
};
/**
 * Gets a directive instance of a given name
 */


exports.getRelationName = getRelationName;

var getDirective = function getDirective(_ref25) {
  var directives = _ref25.directives,
      name = _ref25.name;
  return directives.find(function (directive) {
    return directive.name.value === name;
  });
};
/**
 * Gets an argument of a directive
 */


exports.getDirective = getDirective;

var getDirectiveArgument = function getDirectiveArgument(_ref26) {
  var directive = _ref26.directive,
      name = _ref26.name;
  var value = '';
  var args = directive ? directive.arguments : [];
  var arg = args.find(function (arg) {
    return arg.name && arg.name.value === name;
  });
  if (arg) value = arg.value.value;
  return value;
};

exports.getDirectiveArgument = getDirectiveArgument;

var augmentDirectives = function augmentDirectives(_ref27) {
  var _ref27$directives = _ref27.directives,
      directives = _ref27$directives === void 0 ? [] : _ref27$directives;
  var cypherDirective = getDirective({
    directives: directives,
    name: DirectiveDefinition.CYPHER
  });

  if (cypherDirective) {
    cypherDirective = escapeCypherStatement({
      directive: cypherDirective
    });
  }

  return directives;
};

exports.augmentDirectives = augmentDirectives;

var escapeCypherStatement = function escapeCypherStatement(_ref28) {
  var directive = _ref28.directive;
  var arg = directive.arguments.find(function (arg) {
    return arg.name.value === 'statement';
  });

  if (arg) {
    var value = arg.value;

    if (value && value.kind === _graphql.Kind.STRING && value.block) {
      // Negative lookbehind assertion regex
      var unescapedDoubleQuotes = /(?<!\\)"/g;
      var escaped = value.value.replace(unescapedDoubleQuotes, '\\"');
      arg.value.value = escaped;
    }
  }

  return directive;
};