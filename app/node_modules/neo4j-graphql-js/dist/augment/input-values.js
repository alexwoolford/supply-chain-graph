"use strict";

var _interopRequireDefault = require("@babel/runtime-corejs2/helpers/interopRequireDefault");

var _Object$defineProperty = require("@babel/runtime-corejs2/core-js/object/define-property");

var _Object$defineProperties = require("@babel/runtime-corejs2/core-js/object/define-properties");

var _Object$getOwnPropertyDescriptors = require("@babel/runtime-corejs2/core-js/object/get-own-property-descriptors");

var _Object$getOwnPropertyDescriptor = require("@babel/runtime-corejs2/core-js/object/get-own-property-descriptor");

var _Object$getOwnPropertySymbols = require("@babel/runtime-corejs2/core-js/object/get-own-property-symbols");

var _Object$keys2 = require("@babel/runtime-corejs2/core-js/object/keys");

_Object$defineProperty(exports, "__esModule", {
  value: true
});

exports.analyzeMutationArguments = exports.selectUnselectedOrderedFields = exports.buildFilters = exports.buildPropertyFilters = exports.buildLogicalFilterInputValues = exports.buildQuerySearchInputType = exports.buildQueryFilteringInputType = exports.buildPropertyOrderingValues = exports.buildQueryOrderingEnumType = exports.buildQueryFieldArguments = exports.augmentInputTypePropertyFields = exports.isNeo4jTypeArgument = exports.isDataSelectionArgument = exports.SearchArgument = exports.FilteringArgument = exports.OrderingArgument = exports.PagingArgument = void 0;

var _isInteger = _interopRequireDefault(require("@babel/runtime-corejs2/core-js/number/is-integer"));

var _typeof2 = _interopRequireDefault(require("@babel/runtime-corejs2/helpers/typeof"));

var _isArray = _interopRequireDefault(require("@babel/runtime-corejs2/core-js/array/is-array"));

var _keys = _interopRequireDefault(require("@babel/runtime-corejs2/core-js/object/keys"));

var _toConsumableArray2 = _interopRequireDefault(require("@babel/runtime-corejs2/helpers/toConsumableArray"));

var _defineProperty2 = _interopRequireDefault(require("@babel/runtime-corejs2/helpers/defineProperty"));

var _values = _interopRequireDefault(require("@babel/runtime-corejs2/core-js/object/values"));

var _graphql = require("graphql");

var _ast = require("./ast");

var _types = require("./types/types");

var _directives = require("./directives");

var _fields = require("./fields");

var _spatial = require("./types/spatial");

var _utils = require("../utils");

var _neo4jDriver = _interopRequireDefault(require("neo4j-driver"));

function ownKeys(object, enumerableOnly) { var keys = _Object$keys2(object); if (_Object$getOwnPropertySymbols) { var symbols = _Object$getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return _Object$getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }

function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(Object(source), true).forEach(function (key) { (0, _defineProperty2["default"])(target, key, source[key]); }); } else if (_Object$getOwnPropertyDescriptors) { _Object$defineProperties(target, _Object$getOwnPropertyDescriptors(source)); } else { ownKeys(Object(source)).forEach(function (key) { _Object$defineProperty(target, key, _Object$getOwnPropertyDescriptor(source, key)); }); } } return target; }

/**
 * An enum describing the names of the input value definitions
 * used for the field argument AST for data result pagination
 */
var PagingArgument = {
  FIRST: 'first',
  OFFSET: 'offset'
};
/**
 * An enum describing the names of the input value definitions
 * used for the field argument AST for data result ordering
 */

exports.PagingArgument = PagingArgument;
var OrderingArgument = {
  ORDER_BY: 'orderBy'
};
/**
 * An enum describing the names of the input value definitions
 * used for the field argument AST for data selection filtering
 */

exports.OrderingArgument = OrderingArgument;
var FilteringArgument = {
  FILTER: 'filter'
};
exports.FilteringArgument = FilteringArgument;
var SearchArgument = {
  SEARCH: 'search'
};
exports.SearchArgument = SearchArgument;

var isDataSelectionArgument = function isDataSelectionArgument(name) {
  return (0, _values["default"])(_objectSpread(_objectSpread({}, PagingArgument), OrderingArgument)).some(function (key) {
    return key === name;
  });
};

exports.isDataSelectionArgument = isDataSelectionArgument;

var isNeo4jTypeArgument = function isNeo4jTypeArgument(_ref) {
  var _ref$fieldArgument = _ref.fieldArgument,
      fieldArgument = _ref$fieldArgument === void 0 ? {} : _ref$fieldArgument;
  var type = fieldArgument.type;
  var unwrappedType = (0, _fields.unwrapNamedType)({
    type: type
  });
  var name = unwrappedType.name;
  return (0, _utils.isNeo4jTypeInput)(name);
};
/**
 * Builds the AST definitions for input values that compose the
 * input object types used by Query API field arguments,
 * e.g., pagination, ordering, filtering, etc.
 */


exports.isNeo4jTypeArgument = isNeo4jTypeArgument;

var augmentInputTypePropertyFields = function augmentInputTypePropertyFields(_ref2) {
  var _ref2$inputTypeMap = _ref2.inputTypeMap,
      inputTypeMap = _ref2$inputTypeMap === void 0 ? {} : _ref2$inputTypeMap,
      field = _ref2.field,
      fieldName = _ref2.fieldName,
      fieldDirectives = _ref2.fieldDirectives,
      outputType = _ref2.outputType,
      outputKind = _ref2.outputKind;
  var filteringType = inputTypeMap[FilteringArgument.FILTER];

  if (filteringType && !(0, _directives.isCypherField)({
    directives: fieldDirectives
  }) && !(0, _fields.isNeo4jIDField)({
    name: fieldName
  })) {
    var _filteringType$fields;

    (_filteringType$fields = filteringType.fields).push.apply(_filteringType$fields, (0, _toConsumableArray2["default"])(buildPropertyFilters({
      field: field,
      fieldName: fieldName,
      outputType: outputType,
      outputKind: outputKind
    })));
  }

  var orderingType = inputTypeMap[OrderingArgument.ORDER_BY];

  if (orderingType && !(0, _fields.isListTypeField)({
    field: field
  }) && !(0, _fields.isSpatialField)({
    type: outputType
  })) {
    var _orderingType$values;

    (_orderingType$values = orderingType.values).push.apply(_orderingType$values, (0, _toConsumableArray2["default"])(buildPropertyOrderingValues({
      fieldName: fieldName
    })));
  }

  return inputTypeMap;
};
/**
 * Given an argumentMap of expected Query API field arguments,
 * builds their AST definitions
 */


exports.augmentInputTypePropertyFields = augmentInputTypePropertyFields;

var buildQueryFieldArguments = function buildQueryFieldArguments(_ref3) {
  var _ref3$field = _ref3.field,
      field = _ref3$field === void 0 ? {} : _ref3$field,
      _ref3$argumentMap = _ref3.argumentMap,
      argumentMap = _ref3$argumentMap === void 0 ? {} : _ref3$argumentMap,
      fieldArguments = _ref3.fieldArguments,
      fieldDirectives = _ref3.fieldDirectives,
      typeName = _ref3.typeName,
      outputType = _ref3.outputType,
      isUnionType = _ref3.isUnionType,
      isListType = _ref3.isListType,
      searchesType = _ref3.searchesType,
      typeDefinitionMap = _ref3.typeDefinitionMap;
  var isListField = (0, _fields.isListTypeField)({
    field: field
  });
  (0, _values["default"])(argumentMap).forEach(function (name) {
    if (isListType || isListField) {
      if (name === PagingArgument.FIRST) {
        // Does not overwrite
        if (!(0, _fields.getFieldDefinition)({
          fields: fieldArguments,
          name: PagingArgument.FIRST
        })) {
          fieldArguments.push(buildQueryPagingArgument({
            name: PagingArgument.FIRST
          }));
        }
      } else if (name === PagingArgument.OFFSET) {
        // Does not overwrite
        if (!(0, _fields.getFieldDefinition)({
          fields: fieldArguments,
          name: PagingArgument.OFFSET
        })) {
          fieldArguments.push(buildQueryPagingArgument({
            name: PagingArgument.OFFSET
          }));
        }
      } else if (name === OrderingArgument.ORDER_BY && !isUnionType) {
        var argumentIndex = fieldArguments.findIndex(function (arg) {
          return arg.name.value === OrderingArgument.ORDER_BY;
        });
        var outputTypeDefinition = typeDefinitionMap[outputType];
        var orderingArgument = buildQueryOrderingArgument({
          typeName: outputType
        });
        var hasPropertyField = (0, _fields.propertyFieldExists)({
          definition: outputTypeDefinition,
          typeDefinitionMap: typeDefinitionMap
        }); // Does not already exist

        if (argumentIndex === -1) {
          // Ordering is only supported when there exists at
          // least 1 property field (scalar, temporal, etc.)
          if (hasPropertyField) {
            fieldArguments.push(orderingArgument);
          }
        } else {
          // Does already exist
          if (hasPropertyField) {
            // Replace it with generated argument
            fieldArguments.splice(argumentIndex, 1, orderingArgument);
          } // Else, there are no property fields on the type to be ordered,
          // but we should keep what has been provided

        }
      }
    }

    if (name === FilteringArgument.FILTER && !isUnionType) {
      if (!(0, _directives.isCypherField)({
        directives: fieldDirectives
      })) {
        var _argumentIndex = fieldArguments.findIndex(function (arg) {
          return arg.name.value === FilteringArgument.FILTER;
        });

        if (typeName) {
          outputType = "".concat(typeName).concat(outputType);
        } // Does overwrite


        if (_argumentIndex === -1) {
          fieldArguments.push(buildQueryFilteringArgument({
            typeName: outputType
          }));
        } else {
          fieldArguments.splice(_argumentIndex, 1, buildQueryFilteringArgument({
            typeName: outputType
          }));
        }
      }
    }

    if (name === SearchArgument.SEARCH && !isUnionType) {
      if (!(0, _directives.isCypherField)({
        directives: fieldDirectives
      })) {
        if (searchesType) {
          var _argumentIndex2 = fieldArguments.findIndex(function (arg) {
            return arg.name.value === SearchArgument.SEARCH;
          }); // Does overwrite


          if (_argumentIndex2 === -1) {
            fieldArguments.push(buildQuerySearchArgument({
              typeName: outputType
            }));
          } else {
            fieldArguments.splice(_argumentIndex2, 1, buildQuerySearchArgument({
              typeName: outputType
            }));
          }
        }
      }
    }
  });
  return fieldArguments;
};
/**
 * Builds the AST definition for pagination field arguments
 * used in the Query API
 */


exports.buildQueryFieldArguments = buildQueryFieldArguments;

var buildQueryPagingArgument = function buildQueryPagingArgument(_ref4) {
  var _ref4$name = _ref4.name,
      name = _ref4$name === void 0 ? '' : _ref4$name;
  var arg = {}; // Prevent overwrite

  if (name === PagingArgument.FIRST) {
    arg = (0, _ast.buildInputValue)({
      name: (0, _ast.buildName)({
        name: PagingArgument.FIRST
      }),
      type: (0, _ast.buildNamedType)({
        name: _graphql.GraphQLInt.name
      })
    });
  }

  if (name === PagingArgument.OFFSET) {
    arg = (0, _ast.buildInputValue)({
      name: (0, _ast.buildName)({
        name: PagingArgument.OFFSET
      }),
      type: (0, _ast.buildNamedType)({
        name: _graphql.GraphQLInt.name
      })
    });
  }

  return arg;
};
/**
 * Builds the AST definition for ordering field arguments
 */


var buildQueryOrderingArgument = function buildQueryOrderingArgument(_ref5) {
  var typeName = _ref5.typeName;
  return (0, _ast.buildInputValue)({
    name: (0, _ast.buildName)({
      name: OrderingArgument.ORDER_BY
    }),
    type: (0, _ast.buildNamedType)({
      name: "_".concat(typeName, "Ordering"),
      wrappers: (0, _defineProperty2["default"])({}, _fields.TypeWrappers.LIST_TYPE, true)
    })
  });
};
/**
 * Builds the AST definition for an enum type used as the
 * type of an ordering field argument
 */


var buildQueryOrderingEnumType = function buildQueryOrderingEnumType(_ref6) {
  var nodeInputTypeMap = _ref6.nodeInputTypeMap,
      typeDefinitionMap = _ref6.typeDefinitionMap,
      generatedTypeMap = _ref6.generatedTypeMap;
  var inputType = nodeInputTypeMap[OrderingArgument.ORDER_BY];

  if (inputType && inputType.values.length) {
    var orderingTypeName = inputType.name;
    var type = typeDefinitionMap[inputType.name]; // Prevent overwrite

    if (!type) {
      inputType.name = (0, _ast.buildName)({
        name: orderingTypeName
      });
      generatedTypeMap[orderingTypeName] = (0, _ast.buildEnumType)(inputType);
    }
  }

  return generatedTypeMap;
};
/**
 * Builds the AST definitions for the values of an enum
 * definitions used by an ordering field argument
 */


exports.buildQueryOrderingEnumType = buildQueryOrderingEnumType;

var buildPropertyOrderingValues = function buildPropertyOrderingValues(_ref7) {
  var fieldName = _ref7.fieldName;
  return [(0, _ast.buildEnumValue)({
    name: (0, _ast.buildName)({
      name: "".concat(fieldName, "_asc")
    })
  }), (0, _ast.buildEnumValue)({
    name: (0, _ast.buildName)({
      name: "".concat(fieldName, "_desc")
    })
  })];
};
/**
 * Builds the AST definition for the input value definition
 * used for a filtering field argument
 */


exports.buildPropertyOrderingValues = buildPropertyOrderingValues;

var buildQueryFilteringArgument = function buildQueryFilteringArgument(_ref8) {
  var typeName = _ref8.typeName;
  return (0, _ast.buildInputValue)({
    name: (0, _ast.buildName)({
      name: FilteringArgument.FILTER
    }),
    type: (0, _ast.buildNamedType)({
      name: "_".concat(typeName, "Filter")
    })
  });
};

var buildQuerySearchArgument = function buildQuerySearchArgument(_ref9) {
  var typeName = _ref9.typeName;
  return (0, _ast.buildInputValue)({
    name: (0, _ast.buildName)({
      name: SearchArgument.SEARCH
    }),
    type: (0, _ast.buildNamedType)({
      name: "_".concat(typeName, "Search")
    })
  });
};
/**
 * Builds the AST definition for an input object type used
 * as the type of a filtering field argument
 */


var buildQueryFilteringInputType = function buildQueryFilteringInputType(_ref10) {
  var typeName = _ref10.typeName,
      inputTypeMap = _ref10.inputTypeMap,
      typeDefinitionMap = _ref10.typeDefinitionMap,
      generatedTypeMap = _ref10.generatedTypeMap;
  var inputType = inputTypeMap[FilteringArgument.FILTER];

  if (inputType) {
    var _inputType$fields;

    var inputTypeName = inputType.name;
    inputType.name = (0, _ast.buildName)({
      name: inputTypeName
    });

    (_inputType$fields = inputType.fields).unshift.apply(_inputType$fields, (0, _toConsumableArray2["default"])(buildLogicalFilterInputValues({
      typeName: typeName
    })));

    if (!typeDefinitionMap[inputTypeName]) {
      generatedTypeMap[inputTypeName] = (0, _ast.buildInputObjectType)(inputType);
    }
  }

  return generatedTypeMap;
};

exports.buildQueryFilteringInputType = buildQueryFilteringInputType;

var buildQuerySearchInputType = function buildQuerySearchInputType(_ref11) {
  var typeName = _ref11.typeName,
      inputTypeMap = _ref11.inputTypeMap,
      generatedTypeMap = _ref11.generatedTypeMap;
  var indexNames = (0, _keys["default"])(inputTypeMap);

  if (indexNames.length) {
    // build optional, String type arguments for each search index name
    var inputValues = indexNames.map(function (name) {
      return (0, _ast.buildInputValue)({
        name: (0, _ast.buildName)({
          name: name
        }),
        type: (0, _ast.buildNamedType)({
          name: _graphql.GraphQLString.name
        })
      });
    }); // add a Float type threshold argument used as a>= floor to filter over the score
    // statistics for the nodes matched when one of the above search arguments are used

    inputValues.push((0, _ast.buildInputValue)({
      name: (0, _ast.buildName)({
        name: 'threshold'
      }),
      type: (0, _ast.buildNamedType)({
        name: _graphql.GraphQLFloat.name
      })
    })); // generate the _${Node}Search input object (overwritten)

    generatedTypeMap[typeName] = (0, _ast.buildInputObjectType)({
      name: (0, _ast.buildName)({
        name: typeName
      }),
      fields: inputValues
    });
  }

  return generatedTypeMap;
}; // An enum containing the semantics of logical filtering arguments


exports.buildQuerySearchInputType = buildQuerySearchInputType;
var LogicalFilteringArgument = {
  AND: 'AND',
  OR: 'OR'
};
/**
 * Builds the AST definitions for logical filtering arguments
 */

var buildLogicalFilterInputValues = function buildLogicalFilterInputValues(_ref12) {
  var _wrappers2, _wrappers3;

  var _ref12$typeName = _ref12.typeName,
      typeName = _ref12$typeName === void 0 ? '' : _ref12$typeName;
  return [(0, _ast.buildInputValue)({
    name: (0, _ast.buildName)({
      name: LogicalFilteringArgument.AND
    }),
    type: (0, _ast.buildNamedType)({
      name: typeName,
      wrappers: (_wrappers2 = {}, (0, _defineProperty2["default"])(_wrappers2, _fields.TypeWrappers.NON_NULL_NAMED_TYPE, true), (0, _defineProperty2["default"])(_wrappers2, _fields.TypeWrappers.LIST_TYPE, true), _wrappers2)
    })
  }), (0, _ast.buildInputValue)({
    name: (0, _ast.buildName)({
      name: LogicalFilteringArgument.OR
    }),
    type: (0, _ast.buildNamedType)({
      name: typeName,
      wrappers: (_wrappers3 = {}, (0, _defineProperty2["default"])(_wrappers3, _fields.TypeWrappers.NON_NULL_NAMED_TYPE, true), (0, _defineProperty2["default"])(_wrappers3, _fields.TypeWrappers.LIST_TYPE, true), _wrappers3)
    })
  })];
};
/**
 * Builds the AST definitions for filtering Neo4j property type fields
 */


exports.buildLogicalFilterInputValues = buildLogicalFilterInputValues;

var buildPropertyFilters = function buildPropertyFilters(_ref13) {
  var field = _ref13.field,
      _ref13$fieldName = _ref13.fieldName,
      fieldName = _ref13$fieldName === void 0 ? '' : _ref13$fieldName,
      _ref13$outputType = _ref13.outputType,
      outputType = _ref13$outputType === void 0 ? '' : _ref13$outputType,
      _ref13$outputKind = _ref13.outputKind,
      outputKind = _ref13$outputKind === void 0 ? '' : _ref13$outputKind;
  var filterTypes = [];
  var fieldConfig = {
    name: fieldName,
    type: {
      name: outputType
    }
  };
  var isListFilter = (0, _fields.isListTypeField)({
    field: field
  });

  if (isListFilter) {
    var _fieldConfig$type$wra;

    fieldConfig.type.wrappers = (_fieldConfig$type$wra = {}, (0, _defineProperty2["default"])(_fieldConfig$type$wra, _fields.TypeWrappers.LIST_TYPE, true), (0, _defineProperty2["default"])(_fieldConfig$type$wra, _fields.TypeWrappers.NON_NULL_NAMED_TYPE, true), _fieldConfig$type$wra);
  }

  if ((0, _fields.isSpatialField)({
    type: outputType
  }) || (0, _types.isNeo4jPointType)({
    type: outputType
  })) {
    filterTypes = ['not'].concat((0, _toConsumableArray2["default"])((0, _values["default"])(_spatial.Neo4jPointDistanceFilter)));
  } else if ((0, _fields.isIntegerField)({
    type: outputType
  }) || (0, _fields.isFloatField)({
    type: outputType
  }) || (0, _fields.isTemporalField)({
    type: outputType
  }) || (0, _types.isNeo4jTemporalType)({
    type: outputType
  })) {
    filterTypes = ['not'];
    if (!isListFilter) filterTypes = [].concat((0, _toConsumableArray2["default"])(filterTypes), ['in', 'not_in']);
    filterTypes = [].concat((0, _toConsumableArray2["default"])(filterTypes), ['lt', 'lte', 'gt', 'gte']);
  } else if ((0, _fields.isBooleanField)({
    type: outputType
  })) {
    filterTypes = ['not'];
  } else if ((0, _fields.isStringField)({
    kind: outputKind,
    type: outputType
  })) {
    if (outputKind === _graphql.Kind.ENUM_TYPE_DEFINITION) {
      filterTypes = ['not'];
      if (!isListFilter) filterTypes = [].concat((0, _toConsumableArray2["default"])(filterTypes), ['in', 'not_in']);
    } else {
      filterTypes = ['not'];
      if (!isListFilter) filterTypes = [].concat((0, _toConsumableArray2["default"])(filterTypes), ['in', 'not_in']);
      filterTypes = [].concat((0, _toConsumableArray2["default"])(filterTypes), ['regexp', 'contains', 'not_contains', 'starts_with', 'not_starts_with', 'ends_with', 'not_ends_with']);
    }
  }

  return buildFilters({
    fieldName: fieldName,
    fieldConfig: fieldConfig,
    filterTypes: filterTypes,
    isListFilter: isListFilter
  });
};
/**
 * Builds the input value definitions that compose input object types
 * used by filtering arguments
 */


exports.buildPropertyFilters = buildPropertyFilters;

var buildFilters = function buildFilters(_ref14) {
  var fieldName = _ref14.fieldName,
      fieldConfig = _ref14.fieldConfig,
      _ref14$filterTypes = _ref14.filterTypes,
      filterTypes = _ref14$filterTypes === void 0 ? [] : _ref14$filterTypes,
      _ref14$isListFilter = _ref14.isListFilter,
      isListFilter = _ref14$isListFilter === void 0 ? false : _ref14$isListFilter;

  if (isListFilter) {
    var _fieldConfig$type$wra2;

    fieldConfig.type.wrappers = (_fieldConfig$type$wra2 = {}, (0, _defineProperty2["default"])(_fieldConfig$type$wra2, _fields.TypeWrappers.NON_NULL_NAMED_TYPE, true), (0, _defineProperty2["default"])(_fieldConfig$type$wra2, _fields.TypeWrappers.LIST_TYPE, true), _fieldConfig$type$wra2);
  }

  return filterTypes.reduce(function (inputValues, name) {
    var filterName = "".concat(fieldName, "_").concat(name);
    var isPointDistanceFilter = (0, _values["default"])(_spatial.Neo4jPointDistanceFilter).some(function (distanceFilter) {
      return distanceFilter === name;
    });
    var wrappers = {};

    if ((name === 'in' || name === 'not_in') && name !== 'regexp') {
      var _wrappers4;

      wrappers = (_wrappers4 = {}, (0, _defineProperty2["default"])(_wrappers4, _fields.TypeWrappers.NON_NULL_NAMED_TYPE, true), (0, _defineProperty2["default"])(_wrappers4, _fields.TypeWrappers.LIST_TYPE, true), _wrappers4);
    } else if (isPointDistanceFilter) {
      fieldConfig.type.name = "".concat(_types.Neo4jTypeName).concat(_spatial.SpatialType.POINT, "DistanceFilter");
    }

    if (isListFilter) {
      if (name !== 'regexp') {
        var _wrappers5;

        wrappers = (_wrappers5 = {}, (0, _defineProperty2["default"])(_wrappers5, _fields.TypeWrappers.NON_NULL_NAMED_TYPE, true), (0, _defineProperty2["default"])(_wrappers5, _fields.TypeWrappers.LIST_TYPE, true), _wrappers5);
      }
    }

    inputValues.push((0, _ast.buildInputValue)({
      name: (0, _ast.buildName)({
        name: filterName
      }),
      type: (0, _ast.buildNamedType)({
        name: fieldConfig.type.name,
        wrappers: wrappers
      })
    }));
    return inputValues;
  }, [(0, _ast.buildInputValue)({
    name: (0, _ast.buildName)({
      name: fieldConfig.name
    }),
    type: (0, _ast.buildNamedType)(fieldConfig.type)
  })]);
};

exports.buildFilters = buildFilters;

var selectUnselectedOrderedFields = function selectUnselectedOrderedFields(_ref15) {
  var selectionFilters = _ref15.selectionFilters,
      fieldSelectionSet = _ref15.fieldSelectionSet;
  var orderingArguments = selectionFilters['orderBy'];
  var orderedFieldSelectionSet = []; // cooerce to array if not provided as list

  if (orderingArguments) {
    // if a single ordering enum argument value is provided,
    // cooerce back into an array
    if (typeof orderingArguments === 'string') {
      orderingArguments = [orderingArguments];
    }

    orderedFieldSelectionSet.push.apply(orderedFieldSelectionSet, (0, _toConsumableArray2["default"])(fieldSelectionSet)); // add field selection AST for ordered fields if those fields are
    // not selected, since apoc.coll.sortMulti requires data to sort

    var orderedFieldNameMap = orderingArguments.reduce(function (uniqueFieldMap, orderingArg) {
      var fieldName = orderingArg.substring(0, orderingArg.lastIndexOf('_')); // prevent redundant selections
      // ex: [datetime_asc, datetime_desc], if provided, would result
      // in adding two selections for the datetime field

      if (!uniqueFieldMap[fieldName]) uniqueFieldMap[fieldName] = true;
      return uniqueFieldMap;
    }, {});
    var orderingArgumentFieldNames = (0, _keys["default"])(orderedFieldNameMap);
    orderingArgumentFieldNames.forEach(function (orderedFieldName) {
      var orderedFieldAlreadySelected = fieldSelectionSet.some(function (field) {
        return field.name && field.name.value === orderedFieldName;
      });

      if (!orderedFieldAlreadySelected) {
        // add the field so that its data can be used for ordering
        // since as it is not actually selected, it will be removed
        // by default GraphQL post-processing field resolvers
        orderedFieldSelectionSet.push((0, _ast.buildFieldSelection)({
          name: (0, _ast.buildName)({
            name: orderedFieldName
          })
        }));
      }
    });
  }

  return orderedFieldSelectionSet;
};

exports.selectUnselectedOrderedFields = selectUnselectedOrderedFields;

var analyzeMutationArguments = function analyzeMutationArguments(_ref16) {
  var fieldArguments = _ref16.fieldArguments,
      _ref16$values = _ref16.values,
      values = _ref16$values === void 0 ? {} : _ref16$values,
      resolveInfo = _ref16.resolveInfo;
  var schema = resolveInfo.schema;

  var serialized = _objectSpread({}, values);

  if (!(0, _isArray["default"])(values) && (0, _typeof2["default"])(values) === 'object') {
    fieldArguments.forEach(function (fieldArgument) {
      var name = fieldArgument.name.value;

      if (!isDataSelectionArgument(name)) {
        var type = fieldArgument.type;
        var unwrappedType = (0, _fields.unwrapNamedType)({
          type: type
        });
        var typeName = unwrappedType[_fields.TypeWrappers.NAME];
        var argumentValue = serialized[name];

        if (argumentValue !== undefined) {
          var schemaType = schema.getType(typeName);

          if ((0, _graphql.isInputObjectType)(schemaType)) {
            var fieldMap = schemaType.getFields();
            var fields = (0, _values["default"])(fieldMap);
            var inputFields = fields.map(function (field) {
              return field.astNode;
            });

            if ((0, _isArray["default"])(argumentValue)) {
              argumentValue = argumentValue.map(function (inputValues) {
                var serialized = analyzeMutationArguments({
                  fieldArguments: inputFields,
                  values: inputValues,
                  resolveInfo: resolveInfo
                });
                return serialized;
              });
            } else if ((0, _typeof2["default"])(argumentValue) === 'object') {
              argumentValue = analyzeMutationArguments({
                fieldArguments: inputFields,
                values: argumentValue,
                resolveInfo: resolveInfo
              });
            }
          } else if (typeName === _graphql.GraphQLInt.name) {
            argumentValue = serializeIntegerArgument(argumentValue);
          }

          serialized[name] = argumentValue;
        }
      }
    });
  }

  return serialized;
};

exports.analyzeMutationArguments = analyzeMutationArguments;

var serializeIntegerArgument = function serializeIntegerArgument(argumentValue) {
  var isListValue = (0, _isArray["default"])(argumentValue);
  if (!isListValue) argumentValue = [argumentValue];
  var serialized = argumentValue.map(function (value) {
    if ((0, _isInteger["default"])(value)) value = _neo4jDriver["default"]["int"](value);
    return value;
  });
  if (!isListValue) serialized = serialized[0];
  return serialized;
};