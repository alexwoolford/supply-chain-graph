"use strict";

var _interopRequireDefault = require("@babel/runtime-corejs2/helpers/interopRequireDefault");

var _Object$defineProperty = require("@babel/runtime-corejs2/core-js/object/define-property");

_Object$defineProperty(exports, "__esModule", {
  value: true
});

exports.augmentNodeMutationAPI = exports.NodeMutation = void 0;

var _defineProperty2 = _interopRequireDefault(require("@babel/runtime-corejs2/helpers/defineProperty"));

var _values = _interopRequireDefault(require("@babel/runtime-corejs2/core-js/object/values"));

var _graphql = require("graphql");

var _ast = require("../../ast");

var _directives = require("../../directives");

var _selection = require("./selection");

var _augment = require("../../augment");

var _types = require("../../types/types");

var _fields = require("../../fields");

/**
 * An enum describing the names of node type mutations
 */
var NodeMutation = {
  CREATE: 'Create',
  UPDATE: 'Update',
  DELETE: 'Delete',
  MERGE: 'Merge'
};
exports.NodeMutation = NodeMutation;
var GRANDSTACK_DOCS = "https://grandstack.io/docs";
var GRANDSTACK_DOCS_SCHEMA_AUGMENTATION = "".concat(GRANDSTACK_DOCS, "/graphql-schema-generation-augmentation");
/**
 * Given the results of augmentNodeTypeFields, builds or augments
 * the AST definitions of the Mutation operation fields and any
 * generated input or output types required for translation
 */

var augmentNodeMutationAPI = function augmentNodeMutationAPI(_ref) {
  var definition = _ref.definition,
      typeName = _ref.typeName,
      isInterfaceType = _ref.isInterfaceType,
      propertyInputValues = _ref.propertyInputValues,
      generatedTypeMap = _ref.generatedTypeMap,
      operationTypeMap = _ref.operationTypeMap,
      typeDefinitionMap = _ref.typeDefinitionMap,
      typeExtensionDefinitionMap = _ref.typeExtensionDefinitionMap,
      config = _ref.config;
  var fields = (0, _fields.getTypeFields)({
    typeName: typeName,
    definition: definition,
    typeExtensionDefinitionMap: typeExtensionDefinitionMap
  });
  var primaryKey = (0, _selection.getPrimaryKey)({
    fields: fields
  });
  var mutationTypeName = _types.OperationType.MUTATION;
  var mutationType = operationTypeMap[mutationTypeName];
  var mutationTypeNameLower = mutationTypeName.toLowerCase();

  if (mutationType && (0, _augment.shouldAugmentType)(config, mutationTypeNameLower, typeName) && !isInterfaceType) {
    (0, _values["default"])(NodeMutation).forEach(function (mutationAction) {
      operationTypeMap = buildNodeMutationField({
        mutationType: mutationType,
        mutationAction: mutationAction,
        primaryKey: primaryKey,
        typeName: typeName,
        propertyInputValues: propertyInputValues,
        operationTypeMap: operationTypeMap,
        typeExtensionDefinitionMap: typeExtensionDefinitionMap,
        config: config
      });
    });
  }

  if (config.experimental === true) {
    generatedTypeMap = (0, _selection.buildNodeSelectionInputTypes)({
      definition: definition,
      typeName: typeName,
      propertyInputValues: propertyInputValues,
      generatedTypeMap: generatedTypeMap,
      typeDefinitionMap: typeDefinitionMap,
      typeExtensionDefinitionMap: typeExtensionDefinitionMap,
      config: config
    });
  } else {
    generatedTypeMap = (0, _selection.buildNodeSelectionInputType)({
      definition: definition,
      typeName: typeName,
      propertyInputValues: propertyInputValues,
      generatedTypeMap: generatedTypeMap,
      typeDefinitionMap: typeDefinitionMap,
      typeExtensionDefinitionMap: typeExtensionDefinitionMap,
      config: config
    });
  }

  return [operationTypeMap, generatedTypeMap];
};
/**
 * Builds the AST for the input value definitions used as arguments
 * on generated node Mutation fields of NodeMutation names
 */


exports.augmentNodeMutationAPI = augmentNodeMutationAPI;

var buildNodeMutationArguments = function buildNodeMutationArguments(_ref2) {
  var _ref2$operationName = _ref2.operationName,
      operationName = _ref2$operationName === void 0 ? '' : _ref2$operationName,
      primaryKey = _ref2.primaryKey,
      _ref2$args = _ref2.args,
      args = _ref2$args === void 0 ? [] : _ref2$args;
  var primaryKeyName = primaryKey ? primaryKey.name.value : '';
  args = args.reduce(function (args, field) {
    var name = field.name;
    var directives = field.directives;

    if (!(0, _fields.isNeo4jIDField)({
      name: name
    }) && !(0, _directives.isCypherField)({
      directives: directives
    })) {
      var type = field.type;

      if (operationName === NodeMutation.CREATE) {
        // Uses primary key and any other property field
        if (primaryKeyName === name) {
          if (type.name === _graphql.GraphQLID.name) {
            // Create auto-generates ID primary keys
            args.push({
              name: name,
              type: {
                name: type.name
              }
            });
          } else {
            args.push({
              name: name,
              type: {
                name: type.name,
                wrappers: type.wrappers
              }
            });
          }
        } else {
          args.push({
            name: name,
            type: type
          });
        }
      } else if (operationName === NodeMutation.UPDATE || operationName === NodeMutation.MERGE) {
        // Uses primary key and any other property field
        if (primaryKeyName === name) {
          // Require primary key otherwise
          args.push({
            name: name,
            type: {
              name: type.name,
              wrappers: (0, _defineProperty2["default"])({}, _fields.TypeWrappers.NON_NULL_NAMED_TYPE, true)
            }
          });
        } else {
          // Persist list type wrapper
          args.push({
            name: name,
            type: {
              name: type.name,
              wrappers: (0, _defineProperty2["default"])({}, _fields.TypeWrappers.LIST_TYPE, type.wrappers[_fields.TypeWrappers.LIST_TYPE])
            }
          });
        }
      } else if (operationName === NodeMutation.DELETE) {
        // Only uses primary key
        if (primaryKeyName === name) {
          // Require primary key otherwise
          args.push({
            name: name,
            type: {
              name: type.name,
              wrappers: (0, _defineProperty2["default"])({}, _fields.TypeWrappers.NON_NULL_NAMED_TYPE, true)
            }
          });
        }
      }
    }

    return args;
  }, []);
  return args.map(function (arg) {
    return (0, _ast.buildInputValue)({
      name: (0, _ast.buildName)({
        name: arg.name
      }),
      type: (0, _ast.buildNamedType)(arg.type)
    });
  });
};

var buildNodeMutationObjectArguments = function buildNodeMutationObjectArguments(_ref3) {
  var typeName = _ref3.typeName,
      _ref3$operationName = _ref3.operationName,
      operationName = _ref3$operationName === void 0 ? '' : _ref3$operationName;
  var args = [];
  var nodeSelectionConfig = {
    name: 'where',
    type: {
      name: "_".concat(typeName, "Where"),
      wrappers: (0, _defineProperty2["default"])({}, _fields.TypeWrappers.NON_NULL_NAMED_TYPE, true)
    }
  };
  var propertyCreateInputConfig = {
    name: 'data',
    type: {
      name: "_".concat(typeName, "Create"),
      wrappers: (0, _defineProperty2["default"])({}, _fields.TypeWrappers.NON_NULL_NAMED_TYPE, true)
    }
  };
  var propertyUpdateInputConfig = {
    name: 'data',
    type: {
      name: "_".concat(typeName, "Update"),
      wrappers: (0, _defineProperty2["default"])({}, _fields.TypeWrappers.NON_NULL_NAMED_TYPE, true)
    }
  };

  if (operationName === NodeMutation.CREATE) {
    args.push(propertyCreateInputConfig);
  } else if (operationName === NodeMutation.UPDATE) {
    args.push(nodeSelectionConfig);
    args.push(propertyUpdateInputConfig);
  } else if (operationName === NodeMutation.MERGE) {
    var keySelectionInputConfig = {
      name: 'where',
      type: {
        name: "_".concat(typeName, "Keys"),
        wrappers: (0, _defineProperty2["default"])({}, _fields.TypeWrappers.NON_NULL_NAMED_TYPE, true)
      }
    };
    args.push(keySelectionInputConfig);
    args.push(propertyCreateInputConfig);
  } else if (operationName === NodeMutation.DELETE) {
    args.push(nodeSelectionConfig);
  }

  return args.map(function (arg) {
    return (0, _ast.buildInputValue)({
      name: (0, _ast.buildName)({
        name: arg.name
      }),
      type: (0, _ast.buildNamedType)(arg.type)
    });
  });
};
/**
 * Given the results of augmentNodeTypeFields, builds the AST
 * definition for a Mutation operation field of a given
 * NodeMutation name
 */


var buildNodeMutationField = function buildNodeMutationField(_ref4) {
  var mutationType = _ref4.mutationType,
      _ref4$mutationAction = _ref4.mutationAction,
      mutationAction = _ref4$mutationAction === void 0 ? '' : _ref4$mutationAction,
      primaryKey = _ref4.primaryKey,
      typeName = _ref4.typeName,
      propertyInputValues = _ref4.propertyInputValues,
      operationTypeMap = _ref4.operationTypeMap,
      typeExtensionDefinitionMap = _ref4.typeExtensionDefinitionMap,
      config = _ref4.config;
  var mutationFields = mutationType.fields;
  var mutationName = "".concat(mutationAction).concat(typeName);
  var mutationTypeName = mutationType ? mutationType.name.value : '';
  var mutationTypeExtensions = typeExtensionDefinitionMap[mutationTypeName];

  if (!(0, _fields.getFieldDefinition)({
    fields: mutationFields,
    name: mutationName
  }) && !(0, _fields.getTypeExtensionFieldDefinition)({
    typeExtensions: mutationTypeExtensions,
    name: typeName
  })) {
    var mutationArgs = [];

    if (config.experimental === true) {
      mutationArgs = buildNodeMutationObjectArguments({
        typeName: typeName,
        operationName: mutationAction
      });
    } else {
      mutationArgs = buildNodeMutationArguments({
        operationName: mutationAction,
        primaryKey: primaryKey,
        args: propertyInputValues
      });
    }

    var mutationConfig = {
      name: (0, _ast.buildName)({
        name: mutationName
      }),
      args: mutationArgs,
      type: (0, _ast.buildNamedType)({
        name: typeName
      }),
      directives: buildNodeMutationDirectives({
        mutationAction: mutationAction,
        typeName: typeName,
        config: config
      })
    };
    var mutationField = undefined;
    var mutationDescriptionUrl = '';

    if (mutationAction === NodeMutation.CREATE) {
      mutationField = mutationConfig;
      mutationDescriptionUrl = '[creating](https://neo4j.com/docs/cypher-manual/4.1/clauses/create/#create-nodes)';
    } else if (mutationAction === NodeMutation.UPDATE) {
      if (primaryKey && mutationConfig.args.length > 1) {
        mutationField = mutationConfig;
        mutationDescriptionUrl = '[updating](https://neo4j.com/docs/cypher-manual/4.1/clauses/set/#set-update-a-property)';
      }
    } else if (mutationAction === NodeMutation.MERGE) {
      if (primaryKey) {
        mutationField = mutationConfig;
        mutationDescriptionUrl = '[merging](https://neo4j.com/docs/cypher-manual/4.1/clauses/merge/#query-merge-node-derived)';
      }
    } else if (mutationAction === NodeMutation.DELETE) {
      if (primaryKey) {
        mutationField = mutationConfig;
        mutationDescriptionUrl = '[deleting](https://neo4j.com/docs/cypher-manual/4.1/clauses/delete/#delete-delete-single-node)';
      }
    }

    if (mutationField) {
      mutationField.description = (0, _ast.buildDescription)({
        value: "[Generated mutation](".concat(GRANDSTACK_DOCS_SCHEMA_AUGMENTATION, "/#").concat(mutationAction.toLowerCase(), ") for ").concat(mutationDescriptionUrl, " a ").concat(typeName, " node."),
        config: config
      });
      mutationFields.push((0, _ast.buildField)(mutationField));
    }

    operationTypeMap[_types.OperationType.MUTATION].fields = mutationFields;
  }

  return operationTypeMap;
};
/**
 * Builds the AST definitions for directive instances used by
 * generated node Mutation fields of NodeMutation names
 */


var buildNodeMutationDirectives = function buildNodeMutationDirectives(_ref5) {
  var mutationAction = _ref5.mutationAction,
      typeName = _ref5.typeName,
      config = _ref5.config;
  var directives = [];

  if ((0, _directives.useAuthDirective)(config, _directives.DirectiveDefinition.HAS_SCOPE)) {
    directives.push((0, _directives.buildAuthScopeDirective)({
      scopes: [{
        typeName: typeName,
        mutation: mutationAction
      }]
    }));
  }

  return directives;
};