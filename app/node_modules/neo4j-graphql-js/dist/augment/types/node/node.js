"use strict";

var _interopRequireDefault = require("@babel/runtime-corejs2/helpers/interopRequireDefault");

var _Object$defineProperty = require("@babel/runtime-corejs2/core-js/object/define-property");

var _Object$defineProperties = require("@babel/runtime-corejs2/core-js/object/define-properties");

var _Object$getOwnPropertyDescriptors = require("@babel/runtime-corejs2/core-js/object/get-own-property-descriptors");

var _Object$getOwnPropertyDescriptor = require("@babel/runtime-corejs2/core-js/object/get-own-property-descriptor");

var _Object$getOwnPropertySymbols = require("@babel/runtime-corejs2/core-js/object/get-own-property-symbols");

var _Object$keys = require("@babel/runtime-corejs2/core-js/object/keys");

_Object$defineProperty(exports, "__esModule", {
  value: true
});

exports.augmentNodeTypeFields = exports.augmentNodeType = void 0;

var _defineProperty2 = _interopRequireDefault(require("@babel/runtime-corejs2/helpers/defineProperty"));

var _toConsumableArray2 = _interopRequireDefault(require("@babel/runtime-corejs2/helpers/toConsumableArray"));

var _slicedToArray2 = _interopRequireDefault(require("@babel/runtime-corejs2/helpers/slicedToArray"));

var _graphql = require("graphql");

var _query = require("./query");

var _mutation = require("./mutation");

var _relationship = require("../relationship/relationship");

var _mutation2 = require("../relationship/mutation");

var _fields = require("../../fields");

var _inputValues = require("../../input-values");

var _directives = require("../../directives");

var _types = require("../../types/types");

var _apolloServerErrors = require("apollo-server-errors");

function ownKeys(object, enumerableOnly) { var keys = _Object$keys(object); if (_Object$getOwnPropertySymbols) { var symbols = _Object$getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return _Object$getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }

function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(Object(source), true).forEach(function (key) { (0, _defineProperty2["default"])(target, key, source[key]); }); } else if (_Object$getOwnPropertyDescriptors) { _Object$defineProperties(target, _Object$getOwnPropertyDescriptors(source)); } else { ownKeys(Object(source)).forEach(function (key) { _Object$defineProperty(target, key, _Object$getOwnPropertyDescriptor(source, key)); }); } } return target; }

/**
 * The main export for the augmentation process of a GraphQL
 * type definition representing a Neo4j node entity
 */
var augmentNodeType = function augmentNodeType(_ref) {
  var typeName = _ref.typeName,
      definition = _ref.definition,
      isObjectType = _ref.isObjectType,
      isInterfaceType = _ref.isInterfaceType,
      isUnionType = _ref.isUnionType,
      isOperationType = _ref.isOperationType,
      isQueryType = _ref.isQueryType,
      typeDefinitionMap = _ref.typeDefinitionMap,
      generatedTypeMap = _ref.generatedTypeMap,
      operationTypeMap = _ref.operationTypeMap,
      typeExtensionDefinitionMap = _ref.typeExtensionDefinitionMap,
      config = _ref.config;
  var nodeInputTypeMap = {};
  var searchInputTypeMap = {};
  var propertyOutputFields = [];
  var propertyInputValues = [];
  var extensionPropertyInputValues = [];
  var extensionNodeInputTypeMap = {}; // let extensionSearchInputTypeMap = {};

  var searchesType = false;

  if (isObjectType || isInterfaceType || isUnionType) {
    var typeExtensions = typeExtensionDefinitionMap[typeName] || [];

    if (typeExtensions.length) {
      typeExtensionDefinitionMap[typeName] = typeExtensions.map(function (extension) {
        var isIgnoredType = false;
        var isObjectExtension = (0, _types.isObjectTypeExtensionDefinition)({
          definition: extension
        });
        var isInterfaceExtension = (0, _types.isInterfaceTypeExtensionDefinition)({
          definition: extension
        });

        if (isObjectExtension || isInterfaceExtension) {
          var _augmentNodeTypeField = augmentNodeTypeFields({
            typeName: typeName,
            definition: extension,
            typeDefinitionMap: typeDefinitionMap,
            typeExtensionDefinitionMap: typeExtensionDefinitionMap,
            generatedTypeMap: generatedTypeMap,
            searchInputTypeMap: searchInputTypeMap,
            operationTypeMap: operationTypeMap,
            nodeInputTypeMap: extensionNodeInputTypeMap,
            propertyInputValues: extensionPropertyInputValues,
            propertyOutputFields: propertyOutputFields,
            searchesType: searchesType,
            config: config
          });

          var _augmentNodeTypeField2 = (0, _slicedToArray2["default"])(_augmentNodeTypeField, 6);

          extensionNodeInputTypeMap = _augmentNodeTypeField2[0];
          propertyOutputFields = _augmentNodeTypeField2[1];
          extensionPropertyInputValues = _augmentNodeTypeField2[2];
          isIgnoredType = _augmentNodeTypeField2[3];
          searchesType = _augmentNodeTypeField2[4];
          searchInputTypeMap = _augmentNodeTypeField2[5];

          if (!isIgnoredType) {
            extension.fields = propertyOutputFields;
          }
        }

        return extension;
      });
    } // A type is ignored when all its fields use @neo4j_ignore


    var isIgnoredType = false;

    var _augmentNodeTypeField3 = augmentNodeTypeFields({
      typeName: typeName,
      definition: definition,
      isUnionType: isUnionType,
      isQueryType: isQueryType,
      searchesType: searchesType,
      typeDefinitionMap: typeDefinitionMap,
      typeExtensionDefinitionMap: typeExtensionDefinitionMap,
      generatedTypeMap: generatedTypeMap,
      operationTypeMap: operationTypeMap,
      nodeInputTypeMap: nodeInputTypeMap,
      searchInputTypeMap: searchInputTypeMap,
      extensionNodeInputTypeMap: extensionNodeInputTypeMap,
      propertyOutputFields: propertyOutputFields,
      propertyInputValues: propertyInputValues,
      config: config
    });

    var _augmentNodeTypeField4 = (0, _slicedToArray2["default"])(_augmentNodeTypeField3, 6);

    nodeInputTypeMap = _augmentNodeTypeField4[0];
    propertyOutputFields = _augmentNodeTypeField4[1];
    propertyInputValues = _augmentNodeTypeField4[2];
    isIgnoredType = _augmentNodeTypeField4[3];
    searchesType = _augmentNodeTypeField4[4];
    searchInputTypeMap = _augmentNodeTypeField4[5];
    definition.fields = propertyOutputFields;

    if (extensionPropertyInputValues.length) {
      var _propertyInputValues;

      (_propertyInputValues = propertyInputValues).push.apply(_propertyInputValues, (0, _toConsumableArray2["default"])(extensionPropertyInputValues));
    }

    if (!isIgnoredType) {
      if (!isOperationType && !isInterfaceType && !isUnionType) {
        var _buildNeo4jSystemIDFi = (0, _fields.buildNeo4jSystemIDField)({
          typeName: typeName,
          propertyOutputFields: propertyOutputFields,
          nodeInputTypeMap: nodeInputTypeMap,
          config: config
        });

        var _buildNeo4jSystemIDFi2 = (0, _slicedToArray2["default"])(_buildNeo4jSystemIDFi, 2);

        propertyOutputFields = _buildNeo4jSystemIDFi2[0];
        nodeInputTypeMap = _buildNeo4jSystemIDFi2[1];
      }

      var _augmentNodeTypeAPI = augmentNodeTypeAPI({
        definition: definition,
        isObjectType: isObjectType,
        isInterfaceType: isInterfaceType,
        isUnionType: isUnionType,
        isOperationType: isOperationType,
        isQueryType: isQueryType,
        searchesType: searchesType,
        typeName: typeName,
        propertyOutputFields: propertyOutputFields,
        propertyInputValues: propertyInputValues,
        nodeInputTypeMap: nodeInputTypeMap,
        searchInputTypeMap: searchInputTypeMap,
        typeDefinitionMap: typeDefinitionMap,
        typeExtensionDefinitionMap: typeExtensionDefinitionMap,
        generatedTypeMap: generatedTypeMap,
        operationTypeMap: operationTypeMap,
        config: config
      });

      var _augmentNodeTypeAPI2 = (0, _slicedToArray2["default"])(_augmentNodeTypeAPI, 3);

      typeDefinitionMap = _augmentNodeTypeAPI2[0];
      generatedTypeMap = _augmentNodeTypeAPI2[1];
      operationTypeMap = _augmentNodeTypeAPI2[2];
    }
  }

  return [definition, generatedTypeMap, operationTypeMap, typeExtensionDefinitionMap];
};
/**
 * Iterates through all field definitions of a node type, deciding whether
 * to generate the corresponding field or input value definitions that compose
 * the output and input types used in the Query and Mutation API
 */


exports.augmentNodeType = augmentNodeType;

var augmentNodeTypeFields = function augmentNodeTypeFields(_ref2) {
  var typeName = _ref2.typeName,
      definition = _ref2.definition,
      isUnionType = _ref2.isUnionType,
      isQueryType = _ref2.isQueryType,
      typeDefinitionMap = _ref2.typeDefinitionMap,
      typeExtensionDefinitionMap = _ref2.typeExtensionDefinitionMap,
      generatedTypeMap = _ref2.generatedTypeMap,
      operationTypeMap = _ref2.operationTypeMap,
      _ref2$nodeInputTypeMa = _ref2.nodeInputTypeMap,
      nodeInputTypeMap = _ref2$nodeInputTypeMa === void 0 ? {} : _ref2$nodeInputTypeMa,
      _ref2$searchInputType = _ref2.searchInputTypeMap,
      searchInputTypeMap = _ref2$searchInputType === void 0 ? {} : _ref2$searchInputType,
      extensionNodeInputTypeMap = _ref2.extensionNodeInputTypeMap,
      _ref2$propertyOutputF = _ref2.propertyOutputFields,
      propertyOutputFields = _ref2$propertyOutputF === void 0 ? [] : _ref2$propertyOutputF,
      _ref2$propertyInputVa = _ref2.propertyInputValues,
      propertyInputValues = _ref2$propertyInputVa === void 0 ? [] : _ref2$propertyInputVa,
      isUnionExtension = _ref2.isUnionExtension,
      isObjectExtension = _ref2.isObjectExtension,
      isInterfaceExtension = _ref2.isInterfaceExtension,
      searchesType = _ref2.searchesType,
      config = _ref2.config;
  var isIgnoredType = true;
  var filterTypeName = "_".concat(typeName, "Filter");
  var fields = definition.fields;

  if (!isUnionType && !isUnionExtension) {
    if (!isQueryType) {
      if (!nodeInputTypeMap[_inputValues.FilteringArgument.FILTER]) {
        nodeInputTypeMap[_inputValues.FilteringArgument.FILTER] = {
          name: filterTypeName,
          fields: []
        };
      }

      if (!nodeInputTypeMap[_inputValues.OrderingArgument.ORDER_BY]) {
        nodeInputTypeMap[_inputValues.OrderingArgument.ORDER_BY] = {
          name: "_".concat(typeName, "Ordering"),
          values: []
        };
      }
    }

    propertyOutputFields = fields.reduce(function (outputFields, field) {
      var fieldType = field.type;
      var fieldArguments = field.arguments;
      var fieldDirectives = field.directives;
      var isIgnored = (0, _directives.isIgnoredField)({
        directives: fieldDirectives
      });

      if (!isIgnored) {
        isIgnoredType = false;
        var fieldName = field.name.value;
        var unwrappedType = (0, _fields.unwrapNamedType)({
          type: fieldType
        });
        var outputType = unwrappedType.name;
        var outputDefinition = typeDefinitionMap[outputType];
        var outputKind = outputDefinition ? outputDefinition.kind : '';
        var relationshipDirective = (0, _directives.getDirective)({
          directives: fieldDirectives,
          name: _directives.DirectiveDefinition.RELATION
        }); // escapes unescaped double quotes in @cypher statements

        field.directives = (0, _directives.augmentDirectives)({
          directives: fieldDirectives
        });
        (0, _directives.validateFieldDirectives)({
          fields: fields,
          directives: fieldDirectives
        });

        if (!isObjectExtension && !isInterfaceExtension && (0, _fields.isPropertyTypeField)({
          kind: outputKind,
          type: outputType
        })) {
          nodeInputTypeMap = (0, _inputValues.augmentInputTypePropertyFields)({
            inputTypeMap: nodeInputTypeMap,
            field: field,
            fieldName: fieldName,
            fieldDirectives: fieldDirectives,
            outputType: outputType,
            outputKind: outputKind
          });

          if (!(0, _directives.isCypherField)({
            directives: fieldDirectives
          })) {
            propertyInputValues.push({
              name: fieldName,
              type: unwrappedType,
              directives: fieldDirectives
            });

            if (outputType === _graphql.GraphQLID.name || outputType === _graphql.GraphQLString.name) {
              var searchDirective = (0, _directives.getDirective)({
                directives: fieldDirectives,
                name: _directives.DirectiveDefinition.SEARCH
              });

              if (searchDirective) {
                searchesType = true;
                var indexName = (0, _directives.getDirectiveArgument)({
                  directive: searchDirective,
                  name: 'index'
                }); // defult search index name for this node type

                if (!indexName) indexName = "".concat(typeName, "Search");
                searchInputTypeMap[indexName] = true;
              }
            }
          }
        } else if ((0, _types.isNodeType)({
          definition: outputDefinition
        })) {
          var _augmentNodeTypeField5 = augmentNodeTypeField({
            typeName: typeName,
            definition: definition,
            field: field,
            outputDefinition: outputDefinition,
            fieldArguments: fieldArguments,
            fieldDirectives: fieldDirectives,
            fieldName: fieldName,
            outputType: outputType,
            nodeInputTypeMap: nodeInputTypeMap,
            typeDefinitionMap: typeDefinitionMap,
            typeExtensionDefinitionMap: typeExtensionDefinitionMap,
            generatedTypeMap: generatedTypeMap,
            operationTypeMap: operationTypeMap,
            relationshipDirective: relationshipDirective,
            isObjectExtension: isObjectExtension,
            isInterfaceExtension: isInterfaceExtension,
            config: config
          });

          var _augmentNodeTypeField6 = (0, _slicedToArray2["default"])(_augmentNodeTypeField5, 5);

          fieldArguments = _augmentNodeTypeField6[0];
          nodeInputTypeMap = _augmentNodeTypeField6[1];
          typeDefinitionMap = _augmentNodeTypeField6[2];
          generatedTypeMap = _augmentNodeTypeField6[3];
          operationTypeMap = _augmentNodeTypeField6[4];
        } else if ((0, _types.isRelationshipType)({
          definition: outputDefinition
        })) {
          var _augmentRelationshipT = (0, _relationship.augmentRelationshipTypeField)({
            typeName: typeName,
            definition: definition,
            field: field,
            fieldType: fieldType,
            fieldArguments: fieldArguments,
            fieldDirectives: fieldDirectives,
            fieldName: fieldName,
            outputType: outputType,
            outputDefinition: outputDefinition,
            nodeInputTypeMap: nodeInputTypeMap,
            typeDefinitionMap: typeDefinitionMap,
            typeExtensionDefinitionMap: typeExtensionDefinitionMap,
            generatedTypeMap: generatedTypeMap,
            operationTypeMap: operationTypeMap,
            isObjectExtension: isObjectExtension,
            isInterfaceExtension: isInterfaceExtension,
            config: config
          });

          var _augmentRelationshipT2 = (0, _slicedToArray2["default"])(_augmentRelationshipT, 6);

          fieldType = _augmentRelationshipT2[0];
          fieldArguments = _augmentRelationshipT2[1];
          nodeInputTypeMap = _augmentRelationshipT2[2];
          typeDefinitionMap = _augmentRelationshipT2[3];
          generatedTypeMap = _augmentRelationshipT2[4];
          operationTypeMap = _augmentRelationshipT2[5];
        }
      }

      outputFields.push(_objectSpread(_objectSpread({}, field), {}, {
        type: fieldType,
        arguments: fieldArguments
      }));
      return outputFields;
    }, []);

    if (!isObjectExtension && !isInterfaceExtension) {
      if (!isQueryType && extensionNodeInputTypeMap) {
        if (extensionNodeInputTypeMap[_inputValues.FilteringArgument.FILTER]) {
          var _nodeInputTypeMap$Fil;

          var extendedFilteringFields = extensionNodeInputTypeMap[_inputValues.FilteringArgument.FILTER].fields;

          (_nodeInputTypeMap$Fil = nodeInputTypeMap[_inputValues.FilteringArgument.FILTER].fields).push.apply(_nodeInputTypeMap$Fil, (0, _toConsumableArray2["default"])(extendedFilteringFields));
        }

        if (extensionNodeInputTypeMap[_inputValues.OrderingArgument.ORDER_BY]) {
          var _nodeInputTypeMap$Ord;

          var extendedOrderingValues = extensionNodeInputTypeMap[_inputValues.OrderingArgument.ORDER_BY].values;

          (_nodeInputTypeMap$Ord = nodeInputTypeMap[_inputValues.OrderingArgument.ORDER_BY].values).push.apply(_nodeInputTypeMap$Ord, (0, _toConsumableArray2["default"])(extendedOrderingValues));
        }
      }
    }
  } else {
    isIgnoredType = false;
  }

  return [nodeInputTypeMap, propertyOutputFields, propertyInputValues, isIgnoredType, searchesType, searchInputTypeMap];
};
/**
 * Builds the Query API field arguments and relationship field mutation
 * API for a node type field
 */


exports.augmentNodeTypeFields = augmentNodeTypeFields;

var augmentNodeTypeField = function augmentNodeTypeField(_ref3) {
  var typeName = _ref3.typeName,
      definition = _ref3.definition,
      field = _ref3.field,
      outputDefinition = _ref3.outputDefinition,
      fieldArguments = _ref3.fieldArguments,
      fieldDirectives = _ref3.fieldDirectives,
      fieldName = _ref3.fieldName,
      outputType = _ref3.outputType,
      nodeInputTypeMap = _ref3.nodeInputTypeMap,
      typeDefinitionMap = _ref3.typeDefinitionMap,
      typeExtensionDefinitionMap = _ref3.typeExtensionDefinitionMap,
      generatedTypeMap = _ref3.generatedTypeMap,
      operationTypeMap = _ref3.operationTypeMap,
      config = _ref3.config,
      relationshipDirective = _ref3.relationshipDirective;
  var isPrimaryKey = (0, _directives.isPrimaryKeyField)({
    directives: fieldDirectives
  });
  var isUnique = (0, _directives.isUniqueField)({
    directives: fieldDirectives
  });
  var isIndex = (0, _directives.isIndexedField)({
    directives: fieldDirectives
  });
  if (isPrimaryKey) throw new _apolloServerErrors.ApolloError("The @id directive cannot be used on @relation fields.");
  if (isUnique) throw new _apolloServerErrors.ApolloError("The @unique directive cannot be used on @relation fields.");
  if (isIndex) throw new _apolloServerErrors.ApolloError("The @index directive cannot be used on @relation fields.");
  var isUnionType = (0, _types.isUnionTypeDefinition)({
    definition: outputDefinition
  });
  fieldArguments = (0, _query.augmentNodeTypeFieldArguments)({
    field: field,
    fieldArguments: fieldArguments,
    fieldDirectives: fieldDirectives,
    isUnionType: isUnionType,
    outputType: outputType,
    typeDefinitionMap: typeDefinitionMap,
    config: config
  });

  if (!isUnionType) {
    if (relationshipDirective && !(0, _types.isQueryTypeDefinition)({
      definition: definition,
      operationTypeMap: operationTypeMap
    })) {
      var relationshipName = (0, _directives.getRelationName)(relationshipDirective);
      var relationshipDirection = (0, _directives.getRelationDirection)(relationshipDirective); // Assume direction OUT

      var fromType = typeName;
      var toType = outputType;

      if (relationshipDirection === 'IN') {
        var temp = fromType;
        fromType = outputType;
        toType = temp;
      }

      nodeInputTypeMap = (0, _query.augmentNodeQueryArgumentTypes)({
        typeName: typeName,
        field: field,
        fieldName: fieldName,
        outputType: outputType,
        nodeInputTypeMap: nodeInputTypeMap,
        config: config
      });

      var _augmentRelationshipM = (0, _mutation2.augmentRelationshipMutationAPI)({
        typeName: typeName,
        fieldName: fieldName,
        outputType: outputType,
        fromType: fromType,
        toType: toType,
        relationshipName: relationshipName,
        relationshipDirective: relationshipDirective,
        typeDefinitionMap: typeDefinitionMap,
        typeExtensionDefinitionMap: typeExtensionDefinitionMap,
        generatedTypeMap: generatedTypeMap,
        operationTypeMap: operationTypeMap,
        config: config
      });

      var _augmentRelationshipM2 = (0, _slicedToArray2["default"])(_augmentRelationshipM, 3);

      typeDefinitionMap = _augmentRelationshipM2[0];
      generatedTypeMap = _augmentRelationshipM2[1];
      operationTypeMap = _augmentRelationshipM2[2];
    }
  }

  return [fieldArguments, nodeInputTypeMap, typeDefinitionMap, generatedTypeMap, operationTypeMap];
};
/**
 * Uses the results of augmentNodeTypeFields to build the AST definitions
 * used to in supporting the Query and Mutation API of a node type
 */


var augmentNodeTypeAPI = function augmentNodeTypeAPI(_ref4) {
  var definition = _ref4.definition,
      typeName = _ref4.typeName,
      isObjectType = _ref4.isObjectType,
      isInterfaceType = _ref4.isInterfaceType,
      isUnionType = _ref4.isUnionType,
      isOperationType = _ref4.isOperationType,
      isQueryType = _ref4.isQueryType,
      searchesType = _ref4.searchesType,
      propertyInputValues = _ref4.propertyInputValues,
      nodeInputTypeMap = _ref4.nodeInputTypeMap,
      searchInputTypeMap = _ref4.searchInputTypeMap,
      typeDefinitionMap = _ref4.typeDefinitionMap,
      typeExtensionDefinitionMap = _ref4.typeExtensionDefinitionMap,
      generatedTypeMap = _ref4.generatedTypeMap,
      operationTypeMap = _ref4.operationTypeMap,
      config = _ref4.config;

  if (!isUnionType) {
    var _augmentNodeMutationA = (0, _mutation.augmentNodeMutationAPI)({
      definition: definition,
      typeName: typeName,
      isInterfaceType: isInterfaceType,
      propertyInputValues: propertyInputValues,
      generatedTypeMap: generatedTypeMap,
      operationTypeMap: operationTypeMap,
      typeDefinitionMap: typeDefinitionMap,
      typeExtensionDefinitionMap: typeExtensionDefinitionMap,
      config: config
    });

    var _augmentNodeMutationA2 = (0, _slicedToArray2["default"])(_augmentNodeMutationA, 2);

    operationTypeMap = _augmentNodeMutationA2[0];
    generatedTypeMap = _augmentNodeMutationA2[1];
  }

  var _augmentNodeQueryAPI = (0, _query.augmentNodeQueryAPI)({
    typeName: typeName,
    isObjectType: isObjectType,
    isInterfaceType: isInterfaceType,
    isUnionType: isUnionType,
    isOperationType: isOperationType,
    isQueryType: isQueryType,
    searchesType: searchesType,
    propertyInputValues: propertyInputValues,
    nodeInputTypeMap: nodeInputTypeMap,
    searchInputTypeMap: searchInputTypeMap,
    typeDefinitionMap: typeDefinitionMap,
    typeExtensionDefinitionMap: typeExtensionDefinitionMap,
    generatedTypeMap: generatedTypeMap,
    operationTypeMap: operationTypeMap,
    config: config
  });

  var _augmentNodeQueryAPI2 = (0, _slicedToArray2["default"])(_augmentNodeQueryAPI, 2);

  operationTypeMap = _augmentNodeQueryAPI2[0];
  generatedTypeMap = _augmentNodeQueryAPI2[1];
  return [typeDefinitionMap, generatedTypeMap, operationTypeMap];
};