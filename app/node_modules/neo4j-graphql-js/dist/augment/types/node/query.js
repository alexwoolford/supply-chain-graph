"use strict";

var _interopRequireDefault = require("@babel/runtime-corejs2/helpers/interopRequireDefault");

var _Object$defineProperty = require("@babel/runtime-corejs2/core-js/object/define-property");

var _Object$defineProperties = require("@babel/runtime-corejs2/core-js/object/define-properties");

var _Object$getOwnPropertyDescriptors = require("@babel/runtime-corejs2/core-js/object/get-own-property-descriptors");

var _Object$getOwnPropertyDescriptor = require("@babel/runtime-corejs2/core-js/object/get-own-property-descriptor");

var _Object$getOwnPropertySymbols = require("@babel/runtime-corejs2/core-js/object/get-own-property-symbols");

var _Object$keys = require("@babel/runtime-corejs2/core-js/object/keys");

_Object$defineProperty(exports, "__esModule", {
  value: true
});

exports.augmentNodeQueryArgumentTypes = exports.augmentNodeTypeFieldArguments = exports.augmentNodeQueryAPI = void 0;

var _toConsumableArray2 = _interopRequireDefault(require("@babel/runtime-corejs2/helpers/toConsumableArray"));

var _defineProperty2 = _interopRequireDefault(require("@babel/runtime-corejs2/helpers/defineProperty"));

var _graphql = require("graphql");

var _query = require("../relationship/query");

var _ast = require("../../ast");

var _directives = require("../../directives");

var _augment = require("../../augment");

var _types = require("../../types/types");

var _fields = require("../../fields");

var _inputValues = require("../../input-values");

function ownKeys(object, enumerableOnly) { var keys = _Object$keys(object); if (_Object$getOwnPropertySymbols) { var symbols = _Object$getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return _Object$getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }

function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(Object(source), true).forEach(function (key) { (0, _defineProperty2["default"])(target, key, source[key]); }); } else if (_Object$getOwnPropertyDescriptors) { _Object$defineProperties(target, _Object$getOwnPropertyDescriptors(source)); } else { ownKeys(Object(source)).forEach(function (key) { _Object$defineProperty(target, key, _Object$getOwnPropertyDescriptor(source, key)); }); } } return target; }

/**
 * An enum describing which arguments are implemented for
 * node type fields in the Query API
 */
var NodeQueryArgument = _objectSpread(_objectSpread(_objectSpread(_objectSpread({}, _inputValues.PagingArgument), _inputValues.OrderingArgument), _inputValues.FilteringArgument), _inputValues.SearchArgument);

var GRANDSTACK_DOCS = "https://grandstack.io/docs";
var GRANDSTACK_DOCS_GENERATED_QUERIES = "".concat(GRANDSTACK_DOCS, "/graphql-schema-generation-augmentation#generated-queries");
/**
 * Given the results of augmentNodeTypeFields, builds or augments
 * the AST definition of the Query operation field and any
 * generated input or output types required for translation
 */

var augmentNodeQueryAPI = function augmentNodeQueryAPI(_ref) {
  var typeName = _ref.typeName,
      isUnionType = _ref.isUnionType,
      searchesType = _ref.searchesType,
      propertyInputValues = _ref.propertyInputValues,
      nodeInputTypeMap = _ref.nodeInputTypeMap,
      searchInputTypeMap = _ref.searchInputTypeMap,
      typeDefinitionMap = _ref.typeDefinitionMap,
      typeExtensionDefinitionMap = _ref.typeExtensionDefinitionMap,
      generatedTypeMap = _ref.generatedTypeMap,
      operationTypeMap = _ref.operationTypeMap,
      config = _ref.config;
  var queryType = operationTypeMap[_types.OperationType.QUERY];

  var queryTypeNameLower = _types.OperationType.QUERY.toLowerCase();

  if ((0, _augment.shouldAugmentType)(config, queryTypeNameLower, typeName)) {
    if (queryType) {
      operationTypeMap = buildNodeQueryField({
        typeName: typeName,
        isUnionType: isUnionType,
        searchesType: searchesType,
        queryType: queryType,
        propertyInputValues: propertyInputValues,
        operationTypeMap: operationTypeMap,
        typeDefinitionMap: typeDefinitionMap,
        typeExtensionDefinitionMap: typeExtensionDefinitionMap,
        config: config
      });
    }

    if (!isUnionType) {
      generatedTypeMap = (0, _inputValues.buildQueryOrderingEnumType)({
        nodeInputTypeMap: nodeInputTypeMap,
        typeDefinitionMap: typeDefinitionMap,
        generatedTypeMap: generatedTypeMap
      });
      generatedTypeMap = (0, _inputValues.buildQueryFilteringInputType)({
        typeName: "_".concat(typeName, "Filter"),
        typeDefinitionMap: typeDefinitionMap,
        generatedTypeMap: generatedTypeMap,
        inputTypeMap: nodeInputTypeMap
      });
      generatedTypeMap = (0, _inputValues.buildQuerySearchInputType)({
        typeName: "_".concat(typeName, "Search"),
        typeDefinitionMap: typeDefinitionMap,
        generatedTypeMap: generatedTypeMap,
        inputTypeMap: searchInputTypeMap
      });
    }
  }

  return [operationTypeMap, generatedTypeMap];
};
/**
 * Builds the AST for the input value definitions used for
 * node type Query field arguments
 */


exports.augmentNodeQueryAPI = augmentNodeQueryAPI;

var augmentNodeTypeFieldArguments = function augmentNodeTypeFieldArguments(_ref2) {
  var field = _ref2.field,
      fieldArguments = _ref2.fieldArguments,
      fieldDirectives = _ref2.fieldDirectives,
      isUnionType = _ref2.isUnionType,
      outputType = _ref2.outputType,
      typeDefinitionMap = _ref2.typeDefinitionMap,
      config = _ref2.config;

  var queryTypeNameLower = _types.OperationType.QUERY.toLowerCase();

  if ((0, _augment.shouldAugmentType)(config, queryTypeNameLower, outputType)) {
    fieldArguments = (0, _inputValues.buildQueryFieldArguments)({
      field: field,
      argumentMap: NodeQueryArgument,
      isUnionType: isUnionType,
      fieldArguments: fieldArguments,
      fieldDirectives: fieldDirectives,
      outputType: outputType,
      typeDefinitionMap: typeDefinitionMap
    });
  }

  return fieldArguments;
};
/**
 * Given information about a field on a node type, builds the AST
 * for associated input value definitions used by input types
 * generated for the Query API
 */


exports.augmentNodeTypeFieldArguments = augmentNodeTypeFieldArguments;

var augmentNodeQueryArgumentTypes = function augmentNodeQueryArgumentTypes(_ref3) {
  var typeName = _ref3.typeName,
      field = _ref3.field,
      fieldName = _ref3.fieldName,
      outputType = _ref3.outputType,
      nodeInputTypeMap = _ref3.nodeInputTypeMap,
      config = _ref3.config;

  var queryTypeNameLower = _types.OperationType.QUERY.toLowerCase();

  if ((0, _augment.shouldAugmentType)(config, queryTypeNameLower, outputType)) {
    var _nodeInputTypeMap$Fil;

    (_nodeInputTypeMap$Fil = nodeInputTypeMap[_inputValues.FilteringArgument.FILTER].fields).push.apply(_nodeInputTypeMap$Fil, (0, _toConsumableArray2["default"])((0, _query.buildRelationshipFilters)({
      typeName: typeName,
      field: field,
      fieldName: fieldName,
      outputType: "_".concat(outputType, "Filter"),
      relatedType: outputType,
      config: config
    })));
  }

  return nodeInputTypeMap;
};
/**
 * Builds the AST for the Query type field definition for
 * a given node type
 */


exports.augmentNodeQueryArgumentTypes = augmentNodeQueryArgumentTypes;

var buildNodeQueryField = function buildNodeQueryField(_ref4) {
  var typeName = _ref4.typeName,
      isUnionType = _ref4.isUnionType,
      searchesType = _ref4.searchesType,
      queryType = _ref4.queryType,
      propertyInputValues = _ref4.propertyInputValues,
      operationTypeMap = _ref4.operationTypeMap,
      typeDefinitionMap = _ref4.typeDefinitionMap,
      typeExtensionDefinitionMap = _ref4.typeExtensionDefinitionMap,
      config = _ref4.config;
  var queryFields = queryType.fields;
  var queryTypeName = queryType ? queryType.name.value : '';
  var queryTypeExtensions = typeExtensionDefinitionMap[queryTypeName];

  if (!(0, _fields.getFieldDefinition)({
    fields: queryFields,
    name: typeName
  }) && !(0, _fields.getTypeExtensionFieldDefinition)({
    typeExtensions: queryTypeExtensions,
    name: typeName
  })) {
    queryFields.push((0, _ast.buildField)({
      name: (0, _ast.buildName)({
        name: typeName
      }),
      type: (0, _ast.buildNamedType)({
        name: typeName,
        wrappers: (0, _defineProperty2["default"])({}, _fields.TypeWrappers.LIST_TYPE, true)
      }),
      args: buildNodeQueryArguments({
        typeName: typeName,
        isUnionType: isUnionType,
        propertyInputValues: propertyInputValues,
        typeDefinitionMap: typeDefinitionMap,
        searchesType: searchesType
      }),
      directives: buildNodeQueryDirectives({
        typeName: typeName,
        config: config
      }),
      description: (0, _ast.buildDescription)({
        value: "[Generated query](".concat(GRANDSTACK_DOCS_GENERATED_QUERIES, ") for ").concat(typeName, " type nodes."),
        config: config
      })
    }));
  }

  operationTypeMap[_types.OperationType.QUERY].fields = queryFields;
  return operationTypeMap;
};
/**
 * Builds the AST for input value definitions used for the
 * arguments of the Query type field for a given node type
 */


var buildNodeQueryArguments = function buildNodeQueryArguments(_ref5) {
  var typeName = _ref5.typeName,
      isUnionType = _ref5.isUnionType,
      propertyInputValues = _ref5.propertyInputValues,
      typeDefinitionMap = _ref5.typeDefinitionMap,
      _ref5$searchesType = _ref5.searchesType,
      searchesType = _ref5$searchesType === void 0 ? false : _ref5$searchesType;

  if (!isUnionType) {
    // Do not persist type wrappers
    propertyInputValues = propertyInputValues.map(function (arg) {
      var isListArgument = arg.type.wrappers[_fields.TypeWrappers.LIST_TYPE];
      var wrappers = {};

      if (isListArgument) {
        wrappers = (0, _defineProperty2["default"])({}, _fields.TypeWrappers.LIST_TYPE, true);
      }

      return (0, _ast.buildInputValue)({
        name: (0, _ast.buildName)({
          name: arg.name
        }),
        type: (0, _ast.buildNamedType)({
          name: arg.type.name,
          wrappers: wrappers
        })
      });
    });
    var hasNeo4jIDField = propertyInputValues.some(function (field) {
      return (0, _fields.isNeo4jIDField)({
        name: field.name.value
      });
    });

    if (!hasNeo4jIDField) {
      propertyInputValues.push((0, _ast.buildInputValue)({
        name: (0, _ast.buildName)({
          name: _fields.Neo4jSystemIDField
        }),
        type: (0, _ast.buildNamedType)({
          name: _graphql.GraphQLString.name
        })
      }));
    }
  }

  propertyInputValues = (0, _inputValues.buildQueryFieldArguments)({
    argumentMap: NodeQueryArgument,
    fieldArguments: propertyInputValues,
    outputType: typeName,
    isListType: true,
    searchesType: searchesType,
    isUnionType: isUnionType,
    typeDefinitionMap: typeDefinitionMap
  });
  return propertyInputValues;
};
/**
 * Builds the AST for directive instances on the Query type
 * field for a given node type
 */


var buildNodeQueryDirectives = function buildNodeQueryDirectives(_ref6) {
  var typeName = _ref6.typeName,
      config = _ref6.config;
  var directives = [];

  if ((0, _directives.useAuthDirective)(config, _directives.DirectiveDefinition.HAS_SCOPE)) {
    directives.push((0, _directives.buildAuthScopeDirective)({
      scopes: [{
        typeName: typeName,
        mutation: "Read"
      }]
    }));
  }

  return directives;
};