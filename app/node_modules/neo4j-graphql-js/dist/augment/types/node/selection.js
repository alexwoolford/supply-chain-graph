"use strict";

var _interopRequireDefault = require("@babel/runtime-corejs2/helpers/interopRequireDefault");

var _Object$defineProperty = require("@babel/runtime-corejs2/core-js/object/define-property");

_Object$defineProperty(exports, "__esModule", {
  value: true
});

exports.buildNodeSelectionInputTypes = exports.buildNodeSelectionInputType = exports.getKeyFields = exports.getPrimaryKey = void 0;

var _toConsumableArray2 = _interopRequireDefault(require("@babel/runtime-corejs2/helpers/toConsumableArray"));

var _defineProperty2 = _interopRequireDefault(require("@babel/runtime-corejs2/helpers/defineProperty"));

var _graphql = require("graphql");

var _types = require("../types");

var _fields = require("../../fields");

var _directives = require("../../directives");

var _ast = require("../../ast");

var _augment = require("../../augment");

var _types2 = require("../../types/types");

var _inputValues = require("../../input-values");

var _mutation = require("./mutation");

/**
 * Gets a single field for use as a primary key
 */
var getPrimaryKey = function getPrimaryKey(_ref) {
  var _ref$fields = _ref.fields,
      fields = _ref$fields === void 0 ? [] : _ref$fields;
  // Get all scalar fields that can be used as keys
  var keyFields = getKeyFields({
    fields: fields
  }); // Try getting an @id field

  var pk = getPrimaryKeyField(keyFields);

  if (!pk) {
    // Try getting a single key from @unique fields
    var uniqueFields = getUniqueFields(keyFields);
    pk = inferPrimaryKey(uniqueFields);
  }

  if (!pk) {
    // Try getting a single key from @index fields
    var indexedFields = getIndexedFields(keyFields);
    pk = inferPrimaryKey(indexedFields);
  }

  if (!pk) {
    // Try getting a single key from all fields
    pk = inferPrimaryKey(keyFields);
  }

  return pk;
};
/**
 * Gets all fields for which is it possible to set
 * unique property constraint or indexes in Neo4j.
 */


exports.getPrimaryKey = getPrimaryKey;

var getKeyFields = function getKeyFields(_ref2) {
  var _ref2$fields = _ref2.fields,
      fields = _ref2$fields === void 0 ? [] : _ref2$fields;
  return fields.filter(function (field) {
    var name = field.name,
        type = field.type,
        directives = field.directives;
    var unwrappedType = (0, _fields.unwrapNamedType)({
      type: type
    });
    (0, _directives.validateFieldDirectives)({
      directives: directives
    }); // Prevent ignored, relationship, computed, temporal,
    // and spatial fields from being indexable

    return !(0, _directives.isCypherField)({
      directives: directives
    }) && !(0, _directives.isIgnoredField)({
      directives: directives
    }) && !(0, _directives.isRelationField)({
      directives: directives
    }) && !(0, _fields.isNeo4jIDField)({
      name: name.value
    }) && !(0, _types.isNeo4jPropertyType)({
      type: unwrappedType.name
    }) && !(0, _fields.isNeo4jTypeField)({
      type: unwrappedType.name
    });
  });
}; // Finds an @id field


exports.getKeyFields = getKeyFields;

var getPrimaryKeyField = function getPrimaryKeyField(fields) {
  return fields.find(function (_ref3) {
    var directives = _ref3.directives;
    return (0, _directives.isPrimaryKeyField)({
      directives: directives
    });
  });
}; // Gets all @unique fields


var getUniqueFields = function getUniqueFields(fields) {
  return fields.filter(function (_ref4) {
    var directives = _ref4.directives;
    return (0, _directives.isUniqueField)({
      directives: directives
    });
  });
}; // Gets all @index fields


var getIndexedFields = function getIndexedFields(fields) {
  return fields.filter(function (_ref5) {
    var directives = _ref5.directives;
    return (0, _directives.isIndexedField)({
      directives: directives
    });
  });
};
/**
 * Attempts to select a default primary key by assessing field
 * type predecence. Ideally, a default primary keyis an ID type
 * and non-nullable. With neither an ID, nor a non-nullable field,
 * the first scalar field is used.
 */


var inferPrimaryKey = function inferPrimaryKey() {
  var fields = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : [];
  var pk = undefined;
  if (!fields.length) return pk; // Try to use the first `ID!` field.

  pk = fields.find(function (_ref6) {
    var type = _ref6.type;
    var unwrappedType = (0, _fields.unwrapNamedType)({
      type: type
    });
    return unwrappedType.wrappers[_fields.TypeWrappers.NON_NULL_NAMED_TYPE] && unwrappedType.name === _graphql.GraphQLID.name;
  });

  if (!pk) {
    // Try to use the first `ID` type field.
    pk = fields.find(function (_ref7) {
      var type = _ref7.type;
      return (0, _fields.unwrapNamedType)({
        type: type
      }).name === _graphql.GraphQLID.name;
    });
  }

  if (!pk) {
    // Try to use the first `!` scalar field.
    pk = fields.find(function (_ref8) {
      var type = _ref8.type;
      return (0, _fields.unwrapNamedType)({
        type: type
      }).wrappers[_fields.TypeWrappers.NON_NULL_NAMED_TYPE];
    });
  }

  if (!pk) {
    // Try to use the first field.
    pk = fields[0];
  }

  return pk;
};
/**
 * Builds the AST definition of the node input object type used
 * by relationship mutations for selecting the nodes of the
 * relationship
 */


var buildNodeSelectionInputType = function buildNodeSelectionInputType(_ref9) {
  var definition = _ref9.definition,
      typeName = _ref9.typeName,
      propertyInputValues = _ref9.propertyInputValues,
      generatedTypeMap = _ref9.generatedTypeMap,
      typeExtensionDefinitionMap = _ref9.typeExtensionDefinitionMap,
      config = _ref9.config;
  var mutationTypeName = _types2.OperationType.MUTATION;
  var mutationTypeNameLower = mutationTypeName.toLowerCase();

  if ((0, _augment.shouldAugmentType)(config, mutationTypeNameLower, typeName)) {
    var fields = (0, _fields.getTypeFields)({
      typeName: typeName,
      definition: definition,
      typeExtensionDefinitionMap: typeExtensionDefinitionMap
    });
    var primaryKey = getPrimaryKey({
      fields: fields
    });
    var propertyInputName = "_".concat(typeName, "Input");

    if (primaryKey) {
      var primaryKeyName = primaryKey.name.value;
      var primaryKeyInputConfig = propertyInputValues.find(function (field) {
        return field.name === primaryKeyName;
      });

      if (primaryKeyInputConfig) {
        generatedTypeMap[propertyInputName] = (0, _ast.buildInputObjectType)({
          name: (0, _ast.buildName)({
            name: propertyInputName
          }),
          fields: [(0, _ast.buildInputValue)({
            name: (0, _ast.buildName)({
              name: primaryKeyName
            }),
            type: (0, _ast.buildNamedType)({
              name: primaryKeyInputConfig.type.name,
              wrappers: (0, _defineProperty2["default"])({}, _fields.TypeWrappers.NON_NULL_NAMED_TYPE, true)
            })
          })]
        });
      }
    }
  }

  return generatedTypeMap;
};

exports.buildNodeSelectionInputType = buildNodeSelectionInputType;

var buildNodeSelectionInputTypes = function buildNodeSelectionInputTypes(_ref10) {
  var definition = _ref10.definition,
      typeName = _ref10.typeName,
      propertyInputValues = _ref10.propertyInputValues,
      generatedTypeMap = _ref10.generatedTypeMap,
      typeDefinitionMap = _ref10.typeDefinitionMap,
      typeExtensionDefinitionMap = _ref10.typeExtensionDefinitionMap,
      config = _ref10.config;
  var mutationTypeName = _types2.OperationType.MUTATION;
  var mutationTypeNameLower = mutationTypeName.toLowerCase();

  if ((0, _augment.shouldAugmentType)(config, mutationTypeNameLower, typeName)) {
    var fields = (0, _fields.getTypeFields)({
      typeName: typeName,
      definition: definition,
      typeExtensionDefinitionMap: typeExtensionDefinitionMap
    }); // Used by Create, Merge

    generatedTypeMap = buildNodeCreateInputObject({
      typeName: typeName,
      propertyInputValues: propertyInputValues,
      generatedTypeMap: generatedTypeMap
    }); // Used by Update

    generatedTypeMap = buildNodeUpdateInputObject({
      typeName: typeName,
      propertyInputValues: propertyInputValues,
      generatedTypeMap: generatedTypeMap
    }); // Used by Update, Delete

    generatedTypeMap = buildNodeSelectionInputObject({
      typeName: typeName,
      generatedTypeMap: generatedTypeMap,
      typeDefinitionMap: typeDefinitionMap,
      fields: fields
    }); // Used by Merge

    generatedTypeMap = buildNodeKeySelectionInputObject({
      typeName: typeName,
      generatedTypeMap: generatedTypeMap,
      fields: fields
    });
  }

  return generatedTypeMap;
};

exports.buildNodeSelectionInputTypes = buildNodeSelectionInputTypes;

var buildNodeSelectionInputObject = function buildNodeSelectionInputObject(_ref11) {
  var typeName = _ref11.typeName,
      generatedTypeMap = _ref11.generatedTypeMap,
      typeDefinitionMap = _ref11.typeDefinitionMap,
      fields = _ref11.fields;
  var keyFields = getKeyFields({
    fields: fields
  });
  keyFields = keyFields.filter(function (field) {
    var directives = field.directives;
    return (0, _directives.isPrimaryKeyField)({
      directives: directives
    }) || (0, _directives.isUniqueField)({
      directives: directives
    }) || (0, _directives.isIndexedField)({
      directives: directives
    });
  });

  if (!keyFields.length) {
    var primaryKey = getPrimaryKey({
      fields: fields
    });
    if (primaryKey) keyFields.push(primaryKey);
  }

  var propertyInputName = "_".concat(typeName, "Where");

  if (keyFields.length) {
    var selectionArguments = (0, _inputValues.buildLogicalFilterInputValues)({
      typeName: propertyInputName
    });
    keyFields.forEach(function (field) {
      var fieldName = field.name.value;
      var fieldType = field.type;
      var unwrappedType = (0, _fields.unwrapNamedType)({
        type: fieldType
      });
      var outputType = unwrappedType.name;
      var outputDefinition = typeDefinitionMap[outputType];
      var outputKind = outputDefinition ? outputDefinition.kind : '';
      selectionArguments.push.apply(selectionArguments, (0, _toConsumableArray2["default"])((0, _inputValues.buildPropertyFilters)({
        field: field,
        fieldName: fieldName,
        outputType: outputType,
        outputKind: outputKind
      })));
    });

    if (selectionArguments.length) {
      generatedTypeMap[propertyInputName] = (0, _ast.buildInputObjectType)({
        name: (0, _ast.buildName)({
          name: propertyInputName
        }),
        fields: selectionArguments
      });
    }
  }

  return generatedTypeMap;
};

var buildNodeKeySelectionInputObject = function buildNodeKeySelectionInputObject(_ref12) {
  var typeName = _ref12.typeName,
      generatedTypeMap = _ref12.generatedTypeMap,
      fields = _ref12.fields;
  var keyFields = getKeyFields({
    fields: fields
  });
  keyFields = keyFields.filter(function (field) {
    var directives = field.directives;
    return (0, _directives.isPrimaryKeyField)({
      directives: directives
    }) || (0, _directives.isUniqueField)({
      directives: directives
    }) || (0, _directives.isIndexedField)({
      directives: directives
    });
  });

  if (!keyFields.length) {
    var primaryKey = getPrimaryKey({
      fields: fields
    });
    if (primaryKey) keyFields.push(primaryKey);
  }

  if (keyFields.length) {
    var propertyInputName = "_".concat(typeName, "Keys");
    var selectionArguments = keyFields.map(function (field) {
      var fieldName = field.name.value;
      var fieldType = field.type;
      var unwrappedType = (0, _fields.unwrapNamedType)({
        type: fieldType
      });
      var outputType = unwrappedType.name;
      return (0, _ast.buildInputValue)({
        name: (0, _ast.buildName)({
          name: fieldName
        }),
        type: (0, _ast.buildNamedType)({
          name: outputType
        })
      });
    });

    if (selectionArguments.length) {
      generatedTypeMap[propertyInputName] = (0, _ast.buildInputObjectType)({
        name: (0, _ast.buildName)({
          name: propertyInputName
        }),
        fields: selectionArguments
      });
    }
  }

  return generatedTypeMap;
};

var buildNodeCreateInputObject = function buildNodeCreateInputObject(_ref13) {
  var typeName = _ref13.typeName,
      _ref13$propertyInputV = _ref13.propertyInputValues,
      propertyInputValues = _ref13$propertyInputV === void 0 ? [] : _ref13$propertyInputV,
      generatedTypeMap = _ref13.generatedTypeMap;
  var propertyInputName = "_".concat(typeName, "Create");
  var inputValues = propertyInputValues.map(function (field) {
    var name = field.name,
        type = field.type,
        directives = field.directives;
    var isPrimaryKey = directives.some(function (directive) {
      return directive.name.value === 'id';
    }); // keep nonnull and list type wrappers for Create and Merge node mutation,
    // expect for a primary key, so it could be generated if not provided

    if (isPrimaryKey) type.wrappers = {};
    return (0, _ast.buildInputValue)({
      name: (0, _ast.buildName)({
        name: name
      }),
      type: (0, _ast.buildNamedType)(type)
    });
  });

  if (inputValues.length) {
    generatedTypeMap[propertyInputName] = (0, _ast.buildInputObjectType)({
      name: (0, _ast.buildName)({
        name: propertyInputName
      }),
      fields: inputValues
    });
  }

  return generatedTypeMap;
};

var buildNodeUpdateInputObject = function buildNodeUpdateInputObject(_ref14) {
  var typeName = _ref14.typeName,
      _ref14$propertyInputV = _ref14.propertyInputValues,
      propertyInputValues = _ref14$propertyInputV === void 0 ? [] : _ref14$propertyInputV,
      generatedTypeMap = _ref14.generatedTypeMap;
  var propertyInputName = "_".concat(typeName, "Update");
  var inputValues = propertyInputValues.map(function (field) {
    var name = field.name,
        type = field.type; // set all fields to optional, keep list type wrappers

    type.wrappers[_fields.TypeWrappers.NON_NULL_NAMED_TYPE] = false;
    return (0, _ast.buildInputValue)({
      name: (0, _ast.buildName)({
        name: name
      }),
      type: (0, _ast.buildNamedType)(type)
    });
  });

  if (inputValues.length) {
    generatedTypeMap[propertyInputName] = (0, _ast.buildInputObjectType)({
      name: (0, _ast.buildName)({
        name: propertyInputName
      }),
      fields: inputValues
    });
  }

  return generatedTypeMap;
};