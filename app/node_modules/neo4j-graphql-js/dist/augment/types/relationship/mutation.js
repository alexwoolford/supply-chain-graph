"use strict";

var _interopRequireDefault = require("@babel/runtime-corejs2/helpers/interopRequireDefault");

var _Object$defineProperty = require("@babel/runtime-corejs2/core-js/object/define-property");

var _Object$defineProperties = require("@babel/runtime-corejs2/core-js/object/define-properties");

var _Object$getOwnPropertyDescriptors = require("@babel/runtime-corejs2/core-js/object/get-own-property-descriptors");

var _Object$getOwnPropertyDescriptor = require("@babel/runtime-corejs2/core-js/object/get-own-property-descriptor");

var _Object$getOwnPropertySymbols = require("@babel/runtime-corejs2/core-js/object/get-own-property-symbols");

var _Object$keys = require("@babel/runtime-corejs2/core-js/object/keys");

_Object$defineProperty(exports, "__esModule", {
  value: true
});

exports.augmentRelationshipMutationAPI = exports.RelationshipMutation = void 0;

var _toConsumableArray2 = _interopRequireDefault(require("@babel/runtime-corejs2/helpers/toConsumableArray"));

var _defineProperty2 = _interopRequireDefault(require("@babel/runtime-corejs2/helpers/defineProperty"));

var _slicedToArray2 = _interopRequireDefault(require("@babel/runtime-corejs2/helpers/slicedToArray"));

var _values = _interopRequireDefault(require("@babel/runtime-corejs2/core-js/object/values"));

var _graphql = require("graphql");

var _relationship = require("./relationship");

var _augment = require("../../augment");

var _types = require("../../types/types");

var _fields = require("../../fields");

var _directives = require("../../directives");

var _ast = require("../../ast");

var _selection = require("../node/selection");

var _federation = require("../../../federation");

function ownKeys(object, enumerableOnly) { var keys = _Object$keys(object); if (_Object$getOwnPropertySymbols) { var symbols = _Object$getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return _Object$getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }

function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(Object(source), true).forEach(function (key) { (0, _defineProperty2["default"])(target, key, source[key]); }); } else if (_Object$getOwnPropertyDescriptors) { _Object$defineProperties(target, _Object$getOwnPropertyDescriptors(source)); } else { ownKeys(Object(source)).forEach(function (key) { _Object$defineProperty(target, key, _Object$getOwnPropertyDescriptor(source, key)); }); } } return target; }

/**
 * An enum describing the names of relationship mutations,
 * for node and relationship type fields (field and type
 * relation directive)
 */
var RelationshipMutation = {
  CREATE: 'Add',
  DELETE: 'Remove',
  UPDATE: 'Update',
  MERGE: 'Merge'
};
exports.RelationshipMutation = RelationshipMutation;
var GRANDSTACK_DOCS = "https://grandstack.io/docs";
var GRANDSTACK_DOCS_RELATIONSHIP_TYPE_QUERY = "".concat(GRANDSTACK_DOCS, "/graphql-relationship-types");
var GRANDSTACK_DOCS_SCHEMA_AUGMENTATION = "".concat(GRANDSTACK_DOCS, "/graphql-schema-generation-augmentation");
/**
 * Given the results of augmentRelationshipTypeFields, builds or
 * augments the AST definitions of the Mutation operation fields
 * and any generated input or output types required for translation
 */

var augmentRelationshipMutationAPI = function augmentRelationshipMutationAPI(_ref) {
  var typeName = _ref.typeName,
      fieldName = _ref.fieldName,
      outputType = _ref.outputType,
      fromType = _ref.fromType,
      toType = _ref.toType,
      relationshipName = _ref.relationshipName,
      relationshipDirective = _ref.relationshipDirective,
      _ref$propertyInputVal = _ref.propertyInputValues,
      propertyInputValues = _ref$propertyInputVal === void 0 ? [] : _ref$propertyInputVal,
      _ref$propertyOutputFi = _ref.propertyOutputFields,
      propertyOutputFields = _ref$propertyOutputFi === void 0 ? [] : _ref$propertyOutputFi,
      typeDefinitionMap = _ref.typeDefinitionMap,
      typeExtensionDefinitionMap = _ref.typeExtensionDefinitionMap,
      generatedTypeMap = _ref.generatedTypeMap,
      operationTypeMap = _ref.operationTypeMap,
      config = _ref.config;
  var mutationTypeName = _types.OperationType.MUTATION;
  var mutationType = operationTypeMap[mutationTypeName];
  var mutationTypeNameLower = mutationTypeName.toLowerCase();

  if (mutationType && (0, _augment.shouldAugmentRelationshipField)(config, mutationTypeNameLower, fromType, toType)) {
    (0, _values["default"])(RelationshipMutation).forEach(function (mutationAction) {
      var mutationName = buildRelationshipMutationName({
        mutationAction: mutationAction,
        typeName: typeName,
        fieldName: fieldName
      });

      var _getRelatedNodeTypeDe = getRelatedNodeTypeDefinition({
        typeName: fromType,
        typeDefinitionMap: typeDefinitionMap,
        typeExtensionDefinitionMap: typeExtensionDefinitionMap
      }),
          _getRelatedNodeTypeDe2 = (0, _slicedToArray2["default"])(_getRelatedNodeTypeDe, 2),
          fromTypeDefinition = _getRelatedNodeTypeDe2[0],
          isFromServiceType = _getRelatedNodeTypeDe2[1];

      var _getRelatedNodeTypeDe3 = getRelatedNodeTypeDefinition({
        typeName: toType,
        typeDefinitionMap: typeDefinitionMap,
        typeExtensionDefinitionMap: typeExtensionDefinitionMap
      }),
          _getRelatedNodeTypeDe4 = (0, _slicedToArray2["default"])(_getRelatedNodeTypeDe3, 2),
          toTypeDefinition = _getRelatedNodeTypeDe4[0],
          isToServiceType = _getRelatedNodeTypeDe4[1];

      var fromFields = (0, _fields.getTypeFields)({
        typeName: fromType,
        definition: fromTypeDefinition,
        typeExtensionDefinitionMap: typeExtensionDefinitionMap
      });
      var fromTypePk = (0, _selection.getPrimaryKey)({
        fields: fromFields
      });
      var toFields = (0, _fields.getTypeFields)({
        typeName: toType,
        definition: toTypeDefinition,
        typeExtensionDefinitionMap: typeExtensionDefinitionMap
      });
      var toTypePk = (0, _selection.getPrimaryKey)({
        fields: toFields
      });

      if (!(0, _fields.getFieldDefinition)({
        fields: mutationType.fields,
        name: mutationName
      }) && // Only generate mutation API for given relationship if both related
      // nodes have a primary key
      fromTypePk && toTypePk) {
        var _buildRelationshipMut = buildRelationshipMutationAPI({
          mutationAction: mutationAction,
          mutationName: mutationName,
          relationshipName: relationshipName,
          relationshipDirective: relationshipDirective,
          fromType: fromType,
          toType: toType,
          propertyInputValues: propertyInputValues,
          propertyOutputFields: propertyOutputFields,
          outputType: outputType,
          generatedTypeMap: generatedTypeMap,
          operationTypeMap: operationTypeMap,
          isFromServiceType: isFromServiceType,
          isToServiceType: isToServiceType,
          config: config
        });

        var _buildRelationshipMut2 = (0, _slicedToArray2["default"])(_buildRelationshipMut, 2);

        operationTypeMap = _buildRelationshipMut2[0];
        generatedTypeMap = _buildRelationshipMut2[1];
      }
    });
  }

  return [typeDefinitionMap, generatedTypeMap, operationTypeMap];
};

exports.augmentRelationshipMutationAPI = augmentRelationshipMutationAPI;

var getRelatedNodeTypeDefinition = function getRelatedNodeTypeDefinition(_ref2) {
  var _ref2$typeName = _ref2.typeName,
      typeName = _ref2$typeName === void 0 ? '' : _ref2$typeName,
      _ref2$typeDefinitionM = _ref2.typeDefinitionMap,
      typeDefinitionMap = _ref2$typeDefinitionM === void 0 ? {} : _ref2$typeDefinitionM,
      _ref2$typeExtensionDe = _ref2.typeExtensionDefinitionMap,
      typeExtensionDefinitionMap = _ref2$typeExtensionDe === void 0 ? {} : _ref2$typeExtensionDe;
  var definition = {};
  var isServiceType = false;

  if ((0, _federation.isExternalTypeExtension)({
    typeName: typeName,
    typeMap: typeDefinitionMap,
    typeExtensionDefinitionMap: typeExtensionDefinitionMap
  })) {
    var typeExtensions = typeExtensionDefinitionMap[typeName];

    if (typeExtensions && typeExtensions.length) {
      definition = typeExtensions[0];
      isServiceType = true;
    }
  } else {
    definition = typeDefinitionMap[typeName];
  }

  return [definition, isServiceType];
};
/**
 * Builds the AST for the input value definitions used as
 * field arguments on relationship mutations for selecting
 * the related nodes
 */


var buildNodeSelectionArguments = function buildNodeSelectionArguments(_ref3) {
  var fromType = _ref3.fromType,
      toType = _ref3.toType,
      relationshipDirective = _ref3.relationshipDirective,
      config = _ref3.config;
  var fromFieldName = (0, _directives.getDirectiveArgument)({
    directive: relationshipDirective,
    name: _relationship.RelationshipDirectionField.FROM
  });
  var toFieldName = (0, _directives.getDirectiveArgument)({
    directive: relationshipDirective,
    name: _relationship.RelationshipDirectionField.TO
  });
  if (!fromFieldName) fromFieldName = _relationship.RelationshipDirectionField.FROM;
  if (!toFieldName) toFieldName = _relationship.RelationshipDirectionField.TO;
  var fromTypeName = "_".concat(fromType, "Input");
  var toTypeName = "_".concat(toType, "Input");

  if (config.experimental === true) {
    fromTypeName = "_".concat(fromType, "Where");
    toTypeName = "_".concat(toType, "Where");
  }

  return [(0, _ast.buildInputValue)({
    name: (0, _ast.buildName)({
      name: fromFieldName
    }),
    type: (0, _ast.buildNamedType)({
      name: fromTypeName,
      wrappers: (0, _defineProperty2["default"])({}, _fields.TypeWrappers.NON_NULL_NAMED_TYPE, true)
    })
  }), (0, _ast.buildInputValue)({
    name: (0, _ast.buildName)({
      name: toFieldName
    }),
    type: (0, _ast.buildNamedType)({
      name: toTypeName,
      wrappers: (0, _defineProperty2["default"])({}, _fields.TypeWrappers.NON_NULL_NAMED_TYPE, true)
    })
  })];
};
/**
 * Builds the AST definitions decided and configured in
 * augmentRelationshipMutationAPI
 */


var buildRelationshipMutationAPI = function buildRelationshipMutationAPI(_ref4) {
  var mutationAction = _ref4.mutationAction,
      mutationName = _ref4.mutationName,
      relationshipName = _ref4.relationshipName,
      relationshipDirective = _ref4.relationshipDirective,
      fromType = _ref4.fromType,
      toType = _ref4.toType,
      propertyInputValues = _ref4.propertyInputValues,
      propertyOutputFields = _ref4.propertyOutputFields,
      outputType = _ref4.outputType,
      generatedTypeMap = _ref4.generatedTypeMap,
      operationTypeMap = _ref4.operationTypeMap,
      isFromServiceType = _ref4.isFromServiceType,
      isToServiceType = _ref4.isToServiceType,
      config = _ref4.config;

  if (!isFromServiceType && !isToServiceType) {
    var mutationOutputType = "_".concat(mutationName, "Payload");
    operationTypeMap = buildRelationshipMutationField({
      mutationAction: mutationAction,
      mutationName: mutationName,
      relationshipName: relationshipName,
      relationshipDirective: relationshipDirective,
      fromType: fromType,
      toType: toType,
      propertyInputValues: propertyInputValues,
      propertyOutputFields: propertyOutputFields,
      mutationOutputType: mutationOutputType,
      outputType: outputType,
      operationTypeMap: operationTypeMap,
      config: config
    });
    generatedTypeMap = buildRelationshipMutationPropertyInputType({
      mutationAction: mutationAction,
      outputType: outputType,
      propertyInputValues: propertyInputValues,
      generatedTypeMap: generatedTypeMap
    });
    generatedTypeMap = buildRelationshipMutationOutputType({
      mutationAction: mutationAction,
      mutationOutputType: mutationOutputType,
      propertyInputValues: propertyInputValues,
      propertyOutputFields: propertyOutputFields,
      relationshipName: relationshipName,
      relationshipDirective: relationshipDirective,
      fromType: fromType,
      toType: toType,
      generatedTypeMap: generatedTypeMap,
      config: config
    });
  }

  return [operationTypeMap, generatedTypeMap];
};
/**
 * Builds the AST definition for a Mutation operation field
 * of a given RelationshipMutation name
 */


var buildRelationshipMutationField = function buildRelationshipMutationField(_ref5) {
  var mutationAction = _ref5.mutationAction,
      mutationName = _ref5.mutationName,
      relationshipName = _ref5.relationshipName,
      relationshipDirective = _ref5.relationshipDirective,
      fromType = _ref5.fromType,
      toType = _ref5.toType,
      propertyInputValues = _ref5.propertyInputValues,
      propertyOutputFields = _ref5.propertyOutputFields,
      mutationOutputType = _ref5.mutationOutputType,
      outputType = _ref5.outputType,
      operationTypeMap = _ref5.operationTypeMap,
      config = _ref5.config;

  if (mutationAction === RelationshipMutation.CREATE || mutationAction === RelationshipMutation.DELETE || mutationAction === RelationshipMutation.UPDATE && propertyInputValues.length || mutationAction === RelationshipMutation.MERGE) {
    var cypherDocUrl = '';
    var grandstackDocUrl = '';

    if (mutationAction === RelationshipMutation.CREATE) {
      cypherDocUrl = '[creating](https://neo4j.com/docs/cypher-manual/4.1/clauses/create/#create-relationships)';
      grandstackDocUrl = '#add--remove-relationship';
    }

    if (mutationAction === RelationshipMutation.DELETE) {
      cypherDocUrl = '[deleting](https://neo4j.com/docs/cypher-manual/4.1/clauses/delete/#delete-delete-relationships-only)';
      grandstackDocUrl = '#add--remove-relationship';
    }

    if (mutationAction === RelationshipMutation.UPDATE) {
      cypherDocUrl = '[updating](https://neo4j.com/docs/cypher-manual/4.1/clauses/set/#set-update-a-property)';
      grandstackDocUrl = '#update-relationship';
    }

    if (mutationAction === RelationshipMutation.MERGE) {
      cypherDocUrl = '[merging](https://neo4j.com/docs/cypher-manual/4.1/clauses/merge/#query-merge-relationships)';
      grandstackDocUrl = '#merge-relationship';
    }

    operationTypeMap[_types.OperationType.MUTATION].fields.push((0, _ast.buildField)({
      name: (0, _ast.buildName)({
        name: mutationName
      }),
      type: (0, _ast.buildNamedType)({
        name: mutationOutputType
      }),
      args: buildRelationshipMutationArguments({
        mutationAction: mutationAction,
        relationshipDirective: relationshipDirective,
        fromType: fromType,
        toType: toType,
        propertyOutputFields: propertyOutputFields,
        propertyInputValues: propertyInputValues,
        outputType: outputType,
        config: config
      }),
      directives: buildRelationshipMutationDirectives({
        mutationAction: mutationAction,
        relationshipName: relationshipName,
        fromType: fromType,
        toType: toType,
        config: config
      }),
      description: (0, _ast.buildDescription)({
        value: "[Generated mutation](".concat(GRANDSTACK_DOCS_SCHEMA_AUGMENTATION, "/#").concat(grandstackDocUrl.toLowerCase(), ") for ").concat(cypherDocUrl, " the ").concat(relationshipName, " relationship."),
        config: config
      })
    }));
  }

  return operationTypeMap;
};
/**
 * Given the use of a relationship type field, builds the AST
 * for the input value definition of the 'data' argument for its 'Add'
 * relationship mutation field, which inputs a generated input object
 * type for providing relationship properties
 */


var buildRelationshipPropertyInputArgument = function buildRelationshipPropertyInputArgument(_ref6) {
  var outputType = _ref6.outputType;
  return (0, _ast.buildInputValue)({
    name: (0, _ast.buildName)({
      name: 'data'
    }),
    type: (0, _ast.buildNamedType)({
      name: "_".concat(outputType, "Input"),
      wrappers: (0, _defineProperty2["default"])({}, _fields.TypeWrappers.NON_NULL_NAMED_TYPE, true)
    })
  });
};
/**
 * Builds the AST for the relationship type property input
 * object definition, used as the type of the 'data' input value
 * definition built by buildRelationshipPropertyInputArgument
 */


var buildRelationshipMutationPropertyInputType = function buildRelationshipMutationPropertyInputType(_ref7) {
  var mutationAction = _ref7.mutationAction,
      outputType = _ref7.outputType,
      propertyInputValues = _ref7.propertyInputValues,
      generatedTypeMap = _ref7.generatedTypeMap;

  if ((mutationAction === RelationshipMutation.CREATE || mutationAction === RelationshipMutation.UPDATE || mutationAction === RelationshipMutation.MERGE) && propertyInputValues.length) {
    var nonComputedPropertyInputFields = propertyInputValues.filter(function (field) {
      var cypherDirective = (0, _directives.getDirective)({
        directives: field.directives,
        name: _directives.DirectiveDefinition.CYPHER
      });
      return !cypherDirective && !(0, _fields.isNeo4jIDField)({
        name: field.name
      });
    });
    var inputTypeName = "_".concat(outputType, "Input");
    generatedTypeMap[inputTypeName] = (0, _ast.buildInputObjectType)({
      name: (0, _ast.buildName)({
        name: inputTypeName
      }),
      fields: nonComputedPropertyInputFields.map(function (inputValue) {
        return (0, _ast.buildInputValue)({
          name: (0, _ast.buildName)({
            name: inputValue.name
          }),
          type: (0, _ast.buildNamedType)(inputValue.type)
        });
      })
    });
  }

  return generatedTypeMap;
};
/**
 * Builds the AST for the input value definitions used as arguments on
 * generated relationship Mutation fields of RelationshipMutation names
 */


var buildRelationshipMutationArguments = function buildRelationshipMutationArguments(_ref8) {
  var mutationAction = _ref8.mutationAction,
      relationshipDirective = _ref8.relationshipDirective,
      fromType = _ref8.fromType,
      toType = _ref8.toType,
      propertyOutputFields = _ref8.propertyOutputFields,
      propertyInputValues = _ref8.propertyInputValues,
      outputType = _ref8.outputType,
      config = _ref8.config;
  var fieldArguments = buildNodeSelectionArguments({
    relationshipDirective: relationshipDirective,
    fromType: fromType,
    toType: toType,
    config: config
  });

  if ((mutationAction === RelationshipMutation.CREATE || mutationAction === RelationshipMutation.UPDATE || mutationAction === RelationshipMutation.MERGE) && propertyOutputFields.length && propertyInputValues.length) {
    fieldArguments.push(buildRelationshipPropertyInputArgument({
      outputType: outputType
    }));
  }

  return fieldArguments;
};
/**
 * Builds the AST definitions for directive instances used by
 * generated relationship Mutation fields of RelationshipMutation
 * names
 */


var buildRelationshipMutationDirectives = function buildRelationshipMutationDirectives(_ref9) {
  var mutationAction = _ref9.mutationAction,
      relationshipName = _ref9.relationshipName,
      fromType = _ref9.fromType,
      toType = _ref9.toType,
      config = _ref9.config;
  var mutationMetaDirective = (0, _directives.buildMutationMetaDirective)({
    relationshipName: relationshipName,
    fromType: fromType,
    toType: toType
  });
  var directives = [mutationMetaDirective];

  if ((0, _directives.useAuthDirective)(config, _directives.DirectiveDefinition.HAS_SCOPE)) {
    var authAction = '';

    if (mutationAction === RelationshipMutation.CREATE) {
      authAction = 'Create';
    } else if (mutationAction === RelationshipMutation.DELETE) {
      authAction = 'Delete';
    } else if (mutationAction === RelationshipMutation.UPDATE) {
      authAction = 'Update';
    } else if (mutationAction === RelationshipMutation.MERGE) {
      authAction = 'Merge';
    }

    if (authAction) {
      directives.push((0, _directives.buildAuthScopeDirective)({
        scopes: [{
          typeName: fromType,
          mutation: authAction
        }, {
          typeName: toType,
          mutation: authAction
        }]
      }));
    }
  }

  return directives;
};
/**
 * Builds the AST for the object type definition used for the
 * output type of relationship type Mutation fields
 */


var buildRelationshipMutationOutputType = function buildRelationshipMutationOutputType(_ref10) {
  var mutationAction = _ref10.mutationAction,
      mutationOutputType = _ref10.mutationOutputType,
      propertyInputValues = _ref10.propertyInputValues,
      propertyOutputFields = _ref10.propertyOutputFields,
      relationshipName = _ref10.relationshipName,
      relationshipDirective = _ref10.relationshipDirective,
      fromType = _ref10.fromType,
      toType = _ref10.toType,
      generatedTypeMap = _ref10.generatedTypeMap,
      config = _ref10.config;

  if (mutationAction === RelationshipMutation.CREATE || mutationAction === RelationshipMutation.DELETE || mutationAction === RelationshipMutation.MERGE || mutationAction === RelationshipMutation.UPDATE && propertyInputValues.length) {
    var relationTypeDirective = (0, _ast.buildDirective)({
      name: (0, _ast.buildName)({
        name: _directives.DirectiveDefinition.RELATION
      }),
      args: [(0, _ast.buildDirectiveArgument)({
        name: (0, _ast.buildName)({
          name: 'name'
        }),
        value: {
          kind: _graphql.Kind.STRING,
          value: relationshipName
        }
      }), (0, _ast.buildDirectiveArgument)({
        name: (0, _ast.buildName)({
          name: _relationship.RelationshipDirectionField.FROM
        }),
        value: {
          kind: _graphql.Kind.STRING,
          value: fromType
        }
      }), (0, _ast.buildDirectiveArgument)({
        name: (0, _ast.buildName)({
          name: _relationship.RelationshipDirectionField.TO
        }),
        value: {
          kind: _graphql.Kind.STRING,
          value: toType
        }
      })]
    }); // Try to get a provided field name for the .from argument

    var fromFieldName = (0, _directives.getDirectiveArgument)({
      directive: relationshipDirective,
      name: _relationship.RelationshipDirectionField.FROM
    }); // @relation 'from' argument is not provided, default to 'from' field

    var toFieldName = (0, _directives.getDirectiveArgument)({
      directive: relationshipDirective,
      name: _relationship.RelationshipDirectionField.TO
    });
    if (!fromFieldName) fromFieldName = _relationship.RelationshipDirectionField.FROM;
    if (!toFieldName) toFieldName = _relationship.RelationshipDirectionField.TO;
    var fields = [(0, _ast.buildField)({
      name: (0, _ast.buildName)({
        name: fromFieldName
      }),
      type: (0, _ast.buildNamedType)({
        name: fromType
      }),
      description: (0, _ast.buildDescription)({
        value: "Field for the ".concat(fromType, " node this ").concat(relationshipName, " [relationship](").concat(GRANDSTACK_DOCS_RELATIONSHIP_TYPE_QUERY, ") is coming from."),
        config: config
      })
    }), (0, _ast.buildField)({
      name: (0, _ast.buildName)({
        name: toFieldName
      }),
      type: (0, _ast.buildNamedType)({
        name: toType
      }),
      description: (0, _ast.buildDescription)({
        value: "Field for the ".concat(toType, " node this ").concat(relationshipName, " [relationship](").concat(GRANDSTACK_DOCS_RELATIONSHIP_TYPE_QUERY, ") is going to."),
        config: config
      })
    })];

    if (mutationAction === RelationshipMutation.CREATE || mutationAction === RelationshipMutation.UPDATE || mutationAction === RelationshipMutation.MERGE) {
      // TODO temporary block on cypher field arguments - needs translation test
      var mutationOutputFields = propertyOutputFields.map(function (field) {
        if ((0, _directives.isCypherField)({
          directives: field.directives
        })) {
          return _objectSpread(_objectSpread({}, field), {}, {
            arguments: []
          });
        } else return field;
      });
      fields.push.apply(fields, (0, _toConsumableArray2["default"])(mutationOutputFields));
    } // Overwrite


    generatedTypeMap[mutationOutputType] = (0, _ast.buildObjectType)({
      name: (0, _ast.buildName)({
        name: mutationOutputType
      }),
      fields: fields,
      directives: [relationTypeDirective]
    });
  }

  return generatedTypeMap;
};
/**
 * Builds the full name value for a relationship mutation field
 */


var buildRelationshipMutationName = function buildRelationshipMutationName(_ref11) {
  var mutationAction = _ref11.mutationAction,
      typeName = _ref11.typeName,
      fieldName = _ref11.fieldName;
  return "".concat(mutationAction).concat(typeName).concat(fieldName[0].toUpperCase() + fieldName.substr(1));
};