"use strict";

var _interopRequireDefault = require("@babel/runtime-corejs2/helpers/interopRequireDefault");

var _Object$defineProperty = require("@babel/runtime-corejs2/core-js/object/define-property");

var _Object$defineProperties = require("@babel/runtime-corejs2/core-js/object/define-properties");

var _Object$getOwnPropertyDescriptors = require("@babel/runtime-corejs2/core-js/object/get-own-property-descriptors");

var _Object$getOwnPropertyDescriptor = require("@babel/runtime-corejs2/core-js/object/get-own-property-descriptor");

var _Object$getOwnPropertySymbols = require("@babel/runtime-corejs2/core-js/object/get-own-property-symbols");

var _Object$keys = require("@babel/runtime-corejs2/core-js/object/keys");

_Object$defineProperty(exports, "__esModule", {
  value: true
});

exports.decideRelatedType = exports.buildQueryRelationDirective = exports.buildRelationshipFilters = exports.isReflexiveRelationshipOutputType = exports.isRelationshipMutationOutputType = exports.augmentRelationshipQueryAPI = void 0;

var _toConsumableArray2 = _interopRequireDefault(require("@babel/runtime-corejs2/helpers/toConsumableArray"));

var _slicedToArray2 = _interopRequireDefault(require("@babel/runtime-corejs2/helpers/slicedToArray"));

var _defineProperty2 = _interopRequireDefault(require("@babel/runtime-corejs2/helpers/defineProperty"));

var _graphql = require("graphql");

var _relationship = require("./relationship");

var _augment = require("../../augment");

var _types = require("../../types/types");

var _fields = require("../../fields");

var _inputValues = require("../../input-values");

var _directives = require("../../directives");

var _ast = require("../../ast");

var _federation = require("../../../federation");

function ownKeys(object, enumerableOnly) { var keys = _Object$keys(object); if (_Object$getOwnPropertySymbols) { var symbols = _Object$getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return _Object$getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }

function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(Object(source), true).forEach(function (key) { (0, _defineProperty2["default"])(target, key, source[key]); }); } else if (_Object$getOwnPropertyDescriptors) { _Object$defineProperties(target, _Object$getOwnPropertyDescriptors(source)); } else { ownKeys(Object(source)).forEach(function (key) { _Object$defineProperty(target, key, _Object$getOwnPropertyDescriptor(source, key)); }); } } return target; }

var GRANDSTACK_DOCS = "https://grandstack.io/docs";
var GRANDSTACK_DOCS_RELATIONSHIP_TYPE_QUERY = "".concat(GRANDSTACK_DOCS, "/graphql-relationship-types");
/**
 * An enum describing which arguments are implemented for
 * relationship type fields in the Query API
 */

var RelationshipQueryArgument = _objectSpread(_objectSpread(_objectSpread({}, _inputValues.PagingArgument), _inputValues.OrderingArgument), _inputValues.FilteringArgument);
/**
 * Given the results of augmentRelationshipTypeFields, builds or
 * augments the AST definition of the Query operation field and
 * any generated input or output types required for translation
 */


var augmentRelationshipQueryAPI = function augmentRelationshipQueryAPI(_ref) {
  var typeName = _ref.typeName,
      definition = _ref.definition,
      field = _ref.field,
      fieldArguments = _ref.fieldArguments,
      fieldName = _ref.fieldName,
      outputType = _ref.outputType,
      fromType = _ref.fromType,
      toType = _ref.toType,
      typeDefinitionMap = _ref.typeDefinitionMap,
      typeExtensionDefinitionMap = _ref.typeExtensionDefinitionMap,
      generatedTypeMap = _ref.generatedTypeMap,
      nodeInputTypeMap = _ref.nodeInputTypeMap,
      relationshipInputTypeMap = _ref.relationshipInputTypeMap,
      config = _ref.config,
      relationshipName = _ref.relationshipName,
      relationshipTypeDirective = _ref.relationshipTypeDirective,
      fieldType = _ref.fieldType,
      propertyOutputFields = _ref.propertyOutputFields;

  var queryTypeNameLower = _types.OperationType.QUERY.toLowerCase();

  if ((0, _augment.shouldAugmentRelationshipField)(config, queryTypeNameLower, fromType, toType)) {
    var _getTypeDefiningField = getTypeDefiningField({
      typeName: typeName,
      definition: definition,
      fieldName: fieldName,
      typeDefinitionMap: typeDefinitionMap,
      typeExtensionDefinitionMap: typeExtensionDefinitionMap
    }),
        _getTypeDefiningField2 = (0, _slicedToArray2["default"])(_getTypeDefiningField, 2),
        definingType = _getTypeDefiningField2[0],
        isImplementedField = _getTypeDefiningField2[1];

    if (isImplementedField) typeName = definingType;

    var _decideRelatedType = decideRelatedType({
      typeName: typeName,
      relationshipTypeDirective: relationshipTypeDirective,
      fromType: fromType,
      toType: toType
    }),
        _decideRelatedType2 = (0, _slicedToArray2["default"])(_decideRelatedType, 3),
        relatedTypeFieldName = _decideRelatedType2[0],
        relatedType = _decideRelatedType2[1],
        relationDirection = _decideRelatedType2[2];

    var _transformRelationshi = transformRelationshipTypeFieldOutput((0, _defineProperty2["default"])({
      typeName: typeName,
      field: field,
      relatedType: relatedType,
      relatedTypeFieldName: relatedTypeFieldName,
      fieldArguments: fieldArguments,
      fieldName: fieldName,
      outputType: outputType,
      fromType: fromType,
      toType: toType,
      typeDefinitionMap: typeDefinitionMap,
      generatedTypeMap: generatedTypeMap,
      config: config,
      relationshipName: relationshipName,
      relationDirection: relationDirection,
      relationshipTypeDirective: relationshipTypeDirective,
      fieldType: fieldType,
      propertyOutputFields: propertyOutputFields
    }, "config", config));

    var _transformRelationshi2 = (0, _slicedToArray2["default"])(_transformRelationshi, 2);

    fieldType = _transformRelationshi2[0];
    generatedTypeMap = _transformRelationshi2[1];

    var _augmentRelationshipT = augmentRelationshipTypeFieldInput({
      typeName: typeName,
      definition: definition,
      field: field,
      relationshipTypeDirective: relationshipTypeDirective,
      relatedType: relatedType,
      relatedTypeFieldName: relatedTypeFieldName,
      fieldArguments: fieldArguments,
      fieldName: fieldName,
      isImplementedField: isImplementedField,
      outputType: outputType,
      fromType: fromType,
      toType: toType,
      typeDefinitionMap: typeDefinitionMap,
      typeExtensionDefinitionMap: typeExtensionDefinitionMap,
      generatedTypeMap: generatedTypeMap,
      nodeInputTypeMap: nodeInputTypeMap,
      relationshipInputTypeMap: relationshipInputTypeMap,
      config: config
    });

    var _augmentRelationshipT2 = (0, _slicedToArray2["default"])(_augmentRelationshipT, 3);

    fieldArguments = _augmentRelationshipT2[0];
    generatedTypeMap = _augmentRelationshipT2[1];
    nodeInputTypeMap = _augmentRelationshipT2[2];
  }

  return [fieldType, fieldArguments, typeDefinitionMap, generatedTypeMap, nodeInputTypeMap];
};

exports.augmentRelationshipQueryAPI = augmentRelationshipQueryAPI;

var getTypeDefiningField = function getTypeDefiningField(_ref2) {
  var typeName = _ref2.typeName,
      definition = _ref2.definition,
      fieldName = _ref2.fieldName,
      typeDefinitionMap = _ref2.typeDefinitionMap,
      typeExtensionDefinitionMap = _ref2.typeExtensionDefinitionMap;
  var definitionInterfaces = definition.interfaces || [];
  var interfaces = (0, _toConsumableArray2["default"])(definitionInterfaces);
  var typeExtensions = typeExtensionDefinitionMap[typeName] || [];
  typeExtensions.forEach(function (extension) {
    var extendedImplementations = extension.interfaces;

    if (extendedImplementations && extendedImplementations.length) {
      interfaces.push.apply(interfaces, (0, _toConsumableArray2["default"])(extendedImplementations));
    }
  });
  var definingType = typeName; // field is defined by interface implemented by this type

  var isImplementedField = false;

  if (interfaces && interfaces.length) {
    interfaces.forEach(function (namedType) {
      var unwrappedType = (0, _fields.unwrapNamedType)({
        type: namedType
      });
      var interfaceName = unwrappedType.name;
      var interfaceTypes = [];
      var typeDefinition = typeDefinitionMap[interfaceName];
      if (typeDefinition) interfaceTypes.push(typeDefinition);
      var interfaceDefinesField = interfaceTypes.some(function (type) {
        return type.fields.some(function (field) {
          return field.name.value === fieldName;
        });
      });

      if (interfaceDefinesField) {
        isImplementedField = true;
        definingType = interfaceName;
      }
    });
  }

  return [definingType, isImplementedField];
};
/**
 * Given a relationship type field, builds the input value
 * definitions for its Query arguments, along with those needed
 * for input types generated to support the same Query API
 * for the given field of the given relationship type
 */


var augmentRelationshipTypeFieldInput = function augmentRelationshipTypeFieldInput(_ref3) {
  var field = _ref3.field,
      fieldName = _ref3.fieldName,
      typeName = _ref3.typeName,
      relationshipTypeDirective = _ref3.relationshipTypeDirective,
      relatedType = _ref3.relatedType,
      relatedTypeFieldName = _ref3.relatedTypeFieldName,
      fieldArguments = _ref3.fieldArguments,
      isImplementedField = _ref3.isImplementedField,
      outputType = _ref3.outputType,
      fromType = _ref3.fromType,
      toType = _ref3.toType,
      typeDefinitionMap = _ref3.typeDefinitionMap,
      typeExtensionDefinitionMap = _ref3.typeExtensionDefinitionMap,
      generatedTypeMap = _ref3.generatedTypeMap,
      nodeInputTypeMap = _ref3.nodeInputTypeMap,
      relationshipInputTypeMap = _ref3.relationshipInputTypeMap,
      config = _ref3.config;

  if (!(0, _federation.isExternalTypeExtension)({
    typeName: fromType,
    typeMap: typeDefinitionMap,
    typeExtensionDefinitionMap: typeExtensionDefinitionMap
  }) && !(0, _federation.isExternalTypeExtension)({
    typeName: toType,
    typeMap: typeDefinitionMap,
    typeExtensionDefinitionMap: typeExtensionDefinitionMap
  })) {
    var _nodeInputTypeMap$Fil;

    var relationshipFilterTypeName = "_".concat(typeName).concat(outputType[0].toUpperCase() + outputType.substr(1)); // Assume outgoing relationship

    if (fromType === toType) {
      relationshipFilterTypeName = "_".concat(outputType, "Directions");
    }

    (_nodeInputTypeMap$Fil = nodeInputTypeMap[_inputValues.FilteringArgument.FILTER].fields).push.apply(_nodeInputTypeMap$Fil, (0, _toConsumableArray2["default"])(buildRelationshipFilters({
      typeName: typeName,
      field: field,
      fieldName: fieldName,
      outputType: "".concat(relationshipFilterTypeName, "Filter"),
      relatedType: outputType,
      config: config
    })));

    var _augmentRelationshipT3 = augmentRelationshipTypeFieldArguments({
      field: field,
      fieldName: fieldName,
      fieldArguments: fieldArguments,
      relationshipTypeDirective: relationshipTypeDirective,
      relatedTypeFieldName: relatedTypeFieldName,
      typeName: typeName,
      fromType: fromType,
      toType: toType,
      isImplementedField: isImplementedField,
      outputType: outputType,
      relatedType: relatedType,
      relationshipFilterTypeName: relationshipFilterTypeName,
      typeDefinitionMap: typeDefinitionMap,
      generatedTypeMap: generatedTypeMap,
      relationshipInputTypeMap: relationshipInputTypeMap
    });

    var _augmentRelationshipT4 = (0, _slicedToArray2["default"])(_augmentRelationshipT3, 2);

    fieldArguments = _augmentRelationshipT4[0];
    generatedTypeMap = _augmentRelationshipT4[1];
  }

  return [fieldArguments, generatedTypeMap, nodeInputTypeMap];
};
/**
 * Builds the AST for the input value definitions used for
 * relationship type Query field arguments
 */


var augmentRelationshipTypeFieldArguments = function augmentRelationshipTypeFieldArguments(_ref4) {
  var fieldArguments = _ref4.fieldArguments,
      field = _ref4.field,
      fieldName = _ref4.fieldName,
      relationshipTypeDirective = _ref4.relationshipTypeDirective,
      relatedTypeFieldName = _ref4.relatedTypeFieldName,
      typeName = _ref4.typeName,
      fromType = _ref4.fromType,
      toType = _ref4.toType,
      isImplementedField = _ref4.isImplementedField,
      outputType = _ref4.outputType,
      relatedType = _ref4.relatedType,
      relationshipFilterTypeName = _ref4.relationshipFilterTypeName,
      typeDefinitionMap = _ref4.typeDefinitionMap,
      generatedTypeMap = _ref4.generatedTypeMap,
      relationshipInputTypeMap = _ref4.relationshipInputTypeMap;

  if (fromType !== toType) {
    fieldArguments = (0, _inputValues.buildQueryFieldArguments)({
      field: field,
      argumentMap: RelationshipQueryArgument,
      fieldArguments: fieldArguments,
      typeName: typeName,
      outputType: outputType,
      typeDefinitionMap: typeDefinitionMap
    });
  } else {
    fieldArguments = [];
  }

  if (!isImplementedField) {
    // If this relationship type field is on an object type implementing an
    // interface that defines it, then the argument input types and output type
    // must be those used on that interface's field definition
    generatedTypeMap = buildRelationshipSelectionArgumentInputTypes({
      field: field,
      fieldName: fieldName,
      fromType: fromType,
      toType: toType,
      relatedType: relatedType,
      relationshipTypeDirective: relationshipTypeDirective,
      relatedTypeFieldName: relatedTypeFieldName,
      relationshipFilterTypeName: relationshipFilterTypeName,
      generatedTypeMap: generatedTypeMap,
      relationshipInputTypeMap: relationshipInputTypeMap,
      typeDefinitionMap: typeDefinitionMap
    });
  }

  return [fieldArguments, generatedTypeMap];
};
/**
 * Builds the AST for object type definitions used for transforming
 * a relationship type field on a node type - will likely not be
 * necessary once we allow for dynamically named fields for the
 * 'from' and 'to' node type reference fields on relationship types
 */


var transformRelationshipTypeFieldOutput = function transformRelationshipTypeFieldOutput(_ref5) {
  var typeName = _ref5.typeName,
      field = _ref5.field,
      relatedType = _ref5.relatedType,
      relatedTypeFieldName = _ref5.relatedTypeFieldName,
      fieldArguments = _ref5.fieldArguments,
      fieldName = _ref5.fieldName,
      outputType = _ref5.outputType,
      fromType = _ref5.fromType,
      toType = _ref5.toType,
      typeDefinitionMap = _ref5.typeDefinitionMap,
      generatedTypeMap = _ref5.generatedTypeMap,
      relationshipName = _ref5.relationshipName,
      relationDirection = _ref5.relationDirection,
      relationshipTypeDirective = _ref5.relationshipTypeDirective,
      fieldType = _ref5.fieldType,
      propertyOutputFields = _ref5.propertyOutputFields,
      config = _ref5.config;
  var relationshipOutputName = "_".concat(typeName).concat(fieldName[0].toUpperCase() + fieldName.substr(1));
  var unwrappedType = (0, _fields.unwrapNamedType)({
    type: fieldType
  });

  if (fromType === toType) {
    // Clear arguments on this field, given their distribution
    fieldType = (0, _ast.buildNamedType)({
      name: "".concat(relationshipOutputName, "Directions")
    });
  } else {
    // Output transform
    unwrappedType.name = relationshipOutputName;
    fieldType = (0, _ast.buildNamedType)(unwrappedType);
  }

  generatedTypeMap = buildRelationshipFieldOutputTypes({
    field: field,
    outputType: outputType,
    fromType: fromType,
    toType: toType,
    fieldArguments: fieldArguments,
    relationshipOutputName: relationshipOutputName,
    relationshipName: relationshipName,
    relationDirection: relationDirection,
    relationshipTypeDirective: relationshipTypeDirective,
    relatedType: relatedType,
    relatedTypeFieldName: relatedTypeFieldName,
    propertyOutputFields: propertyOutputFields,
    typeDefinitionMap: typeDefinitionMap,
    generatedTypeMap: generatedTypeMap,
    config: config
  });
  return [fieldType, generatedTypeMap];
};

var isRelationshipMutationOutputType = function isRelationshipMutationOutputType(_ref6) {
  var _ref6$schemaType = _ref6.schemaType,
      schemaType = _ref6$schemaType === void 0 ? {} : _ref6$schemaType;
  var typeName = schemaType.name || '';
  return typeName.startsWith('_') && typeName.endsWith('Payload');
};

exports.isRelationshipMutationOutputType = isRelationshipMutationOutputType;

var isReflexiveRelationshipOutputType = function isReflexiveRelationshipOutputType(_ref7) {
  var _ref7$schemaType = _ref7.schemaType,
      schemaType = _ref7$schemaType === void 0 ? {} : _ref7$schemaType;
  var typeName = schemaType.name || '';
  return typeName.startsWith('_') && typeName.endsWith('Directions');
};
/**
 * Builds the AST definitions that compose the Query filtering input type
 * values for a given relationship field
 */


exports.isReflexiveRelationshipOutputType = isReflexiveRelationshipOutputType;

var buildRelationshipFilters = function buildRelationshipFilters(_ref8) {
  var typeName = _ref8.typeName,
      field = _ref8.field,
      fieldName = _ref8.fieldName,
      outputType = _ref8.outputType,
      relatedType = _ref8.relatedType,
      config = _ref8.config;
  var filters = [];

  var queryTypeNameLower = _types.OperationType.QUERY.toLowerCase();

  if ((0, _augment.shouldAugmentRelationshipField)(config, queryTypeNameLower, typeName, relatedType)) {
    if ((0, _fields.isListTypeField)({
      field: field
    })) {
      filters = (0, _inputValues.buildFilters)({
        fieldName: fieldName,
        fieldConfig: {
          name: fieldName,
          type: {
            name: outputType
          }
        },
        filterTypes: ['not', 'in', 'not_in', 'some', 'none', 'single', 'every']
      });
    } else {
      filters = (0, _inputValues.buildFilters)({
        fieldName: fieldName,
        fieldConfig: {
          name: fieldName,
          type: {
            name: outputType
          }
        },
        filterTypes: ['not', 'in', 'not_in']
      });
    }
  }

  return filters;
};
/**
 * Builds a relation directive for generated relationship output types
 */


exports.buildRelationshipFilters = buildRelationshipFilters;

var buildQueryRelationDirective = function buildQueryRelationDirective(_ref9) {
  var relationshipDirective = _ref9.relationshipDirective,
      relationshipName = _ref9.relationshipName,
      fromType = _ref9.fromType,
      toType = _ref9.toType;
  var fromFieldName = fromType;
  var toFieldName = toType;
  return (0, _ast.buildDirective)({
    name: (0, _ast.buildName)({
      name: _directives.DirectiveDefinition.RELATION
    }),
    args: [(0, _ast.buildDirectiveArgument)({
      name: (0, _ast.buildName)({
        name: 'name'
      }),
      value: {
        kind: _graphql.Kind.STRING,
        value: relationshipName
      }
    }), (0, _ast.buildDirectiveArgument)({
      name: (0, _ast.buildName)({
        name: _relationship.RelationshipDirectionField.FROM
      }),
      value: {
        kind: _graphql.Kind.STRING,
        value: fromFieldName
      }
    }), (0, _ast.buildDirectiveArgument)({
      name: (0, _ast.buildName)({
        name: _relationship.RelationshipDirectionField.TO
      }),
      value: {
        kind: _graphql.Kind.STRING,
        value: toFieldName
      }
    })]
  });
};
/**
 * Builds the AST definitions for the object types generated
 * for querying relationship type fields on node types
 */


exports.buildQueryRelationDirective = buildQueryRelationDirective;

var buildRelationshipFieldOutputTypes = function buildRelationshipFieldOutputTypes(_ref10) {
  var field = _ref10.field,
      outputType = _ref10.outputType,
      fromType = _ref10.fromType,
      toType = _ref10.toType,
      fieldArguments = _ref10.fieldArguments,
      relationshipOutputName = _ref10.relationshipOutputName,
      relationshipName = _ref10.relationshipName,
      relatedType = _ref10.relatedType,
      relatedTypeFieldName = _ref10.relatedTypeFieldName,
      relationDirection = _ref10.relationDirection,
      relationshipTypeDirective = _ref10.relationshipTypeDirective,
      propertyOutputFields = _ref10.propertyOutputFields,
      typeDefinitionMap = _ref10.typeDefinitionMap,
      generatedTypeMap = _ref10.generatedTypeMap,
      config = _ref10.config;

  // Try to get a provided field name for the .from argument
  if (fromType === toType) {
    var _fromFieldName = (0, _directives.getDirectiveArgument)({
      directive: relationshipTypeDirective,
      name: _relationship.RelationshipDirectionField.FROM
    });

    var _toFieldName = (0, _directives.getDirectiveArgument)({
      directive: relationshipTypeDirective,
      name: _relationship.RelationshipDirectionField.TO
    }); // Set defaults


    if (!_fromFieldName) _fromFieldName = _relationship.RelationshipDirectionField.FROM;
    if (!_toFieldName) _toFieldName = _relationship.RelationshipDirectionField.TO;
    fieldArguments = (0, _inputValues.buildQueryFieldArguments)({
      field: field,
      argumentMap: RelationshipQueryArgument,
      fieldArguments: fieldArguments,
      outputType: outputType,
      typeDefinitionMap: typeDefinitionMap
    });
    var reflexiveOutputName = "".concat(relationshipOutputName, "Directions");
    var nodeOutputFields = [(0, _ast.buildField)({
      name: (0, _ast.buildName)({
        name: _fromFieldName
      }),
      args: fieldArguments,
      type: (0, _ast.buildNamedType)({
        name: relationshipOutputName,
        wrappers: (0, _defineProperty2["default"])({}, _fields.TypeWrappers.LIST_TYPE, true)
      }),
      description: (0, _ast.buildDescription)({
        value: "Field for the ".concat(fromType, " node this ").concat(relationshipName, " [relationship](").concat(GRANDSTACK_DOCS_RELATIONSHIP_TYPE_QUERY, ") is coming from."),
        config: config
      })
    }), (0, _ast.buildField)({
      name: (0, _ast.buildName)({
        name: _toFieldName
      }),
      args: fieldArguments,
      type: (0, _ast.buildNamedType)({
        name: relationshipOutputName,
        wrappers: (0, _defineProperty2["default"])({}, _fields.TypeWrappers.LIST_TYPE, true)
      }),
      description: (0, _ast.buildDescription)({
        value: "Field for the ".concat(toType, " node this ").concat(relationshipName, " [relationship](").concat(GRANDSTACK_DOCS_RELATIONSHIP_TYPE_QUERY, ") is going to."),
        config: config
      })
    })];
    generatedTypeMap[reflexiveOutputName] = (0, _ast.buildObjectType)({
      name: (0, _ast.buildName)({
        name: reflexiveOutputName
      }),
      fields: nodeOutputFields,
      directives: [(0, _ast.buildDirective)({
        name: (0, _ast.buildName)({
          name: _directives.DirectiveDefinition.RELATION
        }),
        args: [(0, _ast.buildDirectiveArgument)({
          name: (0, _ast.buildName)({
            name: 'name'
          }),
          value: {
            kind: _graphql.Kind.STRING,
            value: relationshipName
          }
        }), (0, _ast.buildDirectiveArgument)({
          name: (0, _ast.buildName)({
            name: _relationship.RelationshipDirectionField.FROM
          }),
          value: {
            kind: _graphql.Kind.STRING,
            value: fromType
          }
        }), (0, _ast.buildDirectiveArgument)({
          name: (0, _ast.buildName)({
            name: _relationship.RelationshipDirectionField.TO
          }),
          value: {
            kind: _graphql.Kind.STRING,
            value: toType
          }
        })]
      })]
    });
    relatedTypeFieldName = relatedType;
  }

  var descriptionValue = "Field for the ".concat(toType, " node this ").concat(relationshipName, " [relationship](").concat(GRANDSTACK_DOCS_RELATIONSHIP_TYPE_QUERY, ") is going to.");

  if (relationDirection === 'IN') {
    descriptionValue = "Field for the ".concat(fromType, " node this ").concat(relationshipName, " [relationship](").concat(GRANDSTACK_DOCS_RELATIONSHIP_TYPE_QUERY, ") is coming from.");
  }

  var fromFieldName = fromType;
  var toFieldName = toType;
  generatedTypeMap[relationshipOutputName] = (0, _ast.buildObjectType)({
    name: (0, _ast.buildName)({
      name: relationshipOutputName
    }),
    fields: [].concat((0, _toConsumableArray2["default"])(propertyOutputFields), [(0, _ast.buildField)({
      name: (0, _ast.buildName)({
        name: relatedTypeFieldName
      }),
      type: (0, _ast.buildNamedType)({
        name: relatedType
      }),
      description: (0, _ast.buildDescription)({
        value: descriptionValue,
        config: config
      })
    })]),
    directives: [(0, _ast.buildDirective)({
      name: (0, _ast.buildName)({
        name: _directives.DirectiveDefinition.RELATION
      }),
      args: [(0, _ast.buildDirectiveArgument)({
        name: (0, _ast.buildName)({
          name: 'name'
        }),
        value: {
          kind: _graphql.Kind.STRING,
          value: relationshipName
        }
      }), (0, _ast.buildDirectiveArgument)({
        name: (0, _ast.buildName)({
          name: _relationship.RelationshipDirectionField.FROM
        }),
        value: {
          kind: _graphql.Kind.STRING,
          value: fromFieldName
        }
      }), (0, _ast.buildDirectiveArgument)({
        name: (0, _ast.buildName)({
          name: _relationship.RelationshipDirectionField.TO
        }),
        value: {
          kind: _graphql.Kind.STRING,
          value: toFieldName
        }
      })]
    })]
  });
  return generatedTypeMap;
};
/**
 * Given information about a field on a relationship type, builds
 * the AST for associated input value definitions used by input
 * types generated for the Query API
 */


var buildRelationshipSelectionArgumentInputTypes = function buildRelationshipSelectionArgumentInputTypes(_ref11) {
  var field = _ref11.field,
      fieldName = _ref11.fieldName,
      fromType = _ref11.fromType,
      toType = _ref11.toType,
      relatedType = _ref11.relatedType,
      relationshipTypeDirective = _ref11.relationshipTypeDirective,
      relatedTypeFieldName = _ref11.relatedTypeFieldName,
      relationshipFilterTypeName = _ref11.relationshipFilterTypeName,
      generatedTypeMap = _ref11.generatedTypeMap,
      relationshipInputTypeMap = _ref11.relationshipInputTypeMap,
      typeDefinitionMap = _ref11.typeDefinitionMap;
  var relationshipFilteringFields = relationshipInputTypeMap[_inputValues.FilteringArgument.FILTER].fields;
  var relatedTypeFilterName = relationshipInputTypeMap[_inputValues.FilteringArgument.FILTER].name;

  if (fromType === toType) {
    var reflexiveFilteringTypeName = "".concat(relationshipFilterTypeName, "Filter");
    var fromFieldName = (0, _directives.getDirectiveArgument)({
      directive: relationshipTypeDirective,
      name: _relationship.RelationshipDirectionField.FROM
    });
    var toFieldName = (0, _directives.getDirectiveArgument)({
      directive: relationshipTypeDirective,
      name: _relationship.RelationshipDirectionField.TO
    });
    if (!fromFieldName) fromFieldName = _relationship.RelationshipDirectionField.FROM;
    if (!toFieldName) toFieldName = _relationship.RelationshipDirectionField.TO;
    var nodeSelectionArguments = [(0, _ast.buildInputValue)({
      name: (0, _ast.buildName)({
        name: fromFieldName
      }),
      type: (0, _ast.buildNamedType)({
        name: relatedTypeFilterName
      })
    }), (0, _ast.buildInputValue)({
      name: (0, _ast.buildName)({
        name: toFieldName
      }),
      type: (0, _ast.buildNamedType)({
        name: relatedTypeFilterName
      })
    })];
    generatedTypeMap[reflexiveFilteringTypeName] = (0, _ast.buildInputObjectType)({
      name: (0, _ast.buildName)({
        name: reflexiveFilteringTypeName
      }),
      fields: nodeSelectionArguments
    });
    relationshipFilteringFields.push((0, _ast.buildInputValue)({
      name: (0, _ast.buildName)({
        name: relatedType
      }),
      type: (0, _ast.buildNamedType)({
        name: "_".concat(relatedType, "Filter")
      })
    }));
  } else {
    relationshipFilteringFields.push((0, _ast.buildInputValue)({
      name: (0, _ast.buildName)({
        name: relatedTypeFieldName
      }),
      type: (0, _ast.buildNamedType)({
        name: "_".concat(relatedType, "Filter")
      })
    }));
  }

  generatedTypeMap = (0, _inputValues.buildQueryFilteringInputType)({
    typeName: relatedTypeFilterName,
    typeDefinitionMap: typeDefinitionMap,
    generatedTypeMap: generatedTypeMap,
    inputTypeMap: relationshipInputTypeMap
  });
  generatedTypeMap = (0, _inputValues.buildQueryOrderingEnumType)({
    nodeInputTypeMap: relationshipInputTypeMap,
    typeDefinitionMap: typeDefinitionMap,
    generatedTypeMap: generatedTypeMap
  });
  return generatedTypeMap;
};
/**
 * Given the name of a type, and the names of the node types
 * of a relationship type, decides which type it is related to
 * (possibly itself)
 */


var decideRelatedType = function decideRelatedType(_ref12) {
  var typeName = _ref12.typeName,
      relationshipTypeDirective = _ref12.relationshipTypeDirective,
      fromType = _ref12.fromType,
      toType = _ref12.toType;
  var relatedType = toType;
  var relationDirection = 'OUT';
  var directedNodeFieldName = _relationship.RelationshipDirectionField.TO;

  if (fromType !== toType) {
    // Interpret relationship direction
    if (typeName === toType) {
      // Is incoming relationship
      relatedType = fromType;
      relationDirection = 'IN';
      directedNodeFieldName = _relationship.RelationshipDirectionField.FROM;
    }
  } // Try getting a custom directive argument for directedNodeFieldName


  var relatedTypeFieldName = (0, _directives.getDirectiveArgument)({
    directive: relationshipTypeDirective,
    name: directedNodeFieldName
  }); // If one is not provided, use the transformed default

  if (!relatedTypeFieldName) relatedTypeFieldName = relatedType;
  return [relatedTypeFieldName, relatedType, relationDirection];
};

exports.decideRelatedType = decideRelatedType;