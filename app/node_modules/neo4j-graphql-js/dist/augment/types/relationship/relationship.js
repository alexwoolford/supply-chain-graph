"use strict";

var _interopRequireDefault = require("@babel/runtime-corejs2/helpers/interopRequireDefault");

var _Object$defineProperty = require("@babel/runtime-corejs2/core-js/object/define-property");

_Object$defineProperty(exports, "__esModule", {
  value: true
});

exports.augmentRelationshipTypeField = exports.RelationshipDirectionField = void 0;

var _defineProperty2 = _interopRequireDefault(require("@babel/runtime-corejs2/helpers/defineProperty"));

var _slicedToArray2 = _interopRequireDefault(require("@babel/runtime-corejs2/helpers/slicedToArray"));

var _query = require("./query");

var _mutation = require("./mutation");

var _fields = require("../../fields");

var _inputValues = require("../../input-values");

var _directives = require("../../directives");

var _types = require("../../types/types");

var _apolloServerErrors = require("apollo-server-errors");

// An enum for the semantics of the directed fields of a relationship type
var RelationshipDirectionField = {
  FROM: 'from',
  TO: 'to'
};
/**
 * The main export for the augmentation process of a GraphQL
 * type definition representing a Neo4j relationship entity
 */

exports.RelationshipDirectionField = RelationshipDirectionField;

var augmentRelationshipTypeField = function augmentRelationshipTypeField(_ref) {
  var typeName = _ref.typeName,
      field = _ref.field,
      definition = _ref.definition,
      fieldType = _ref.fieldType,
      fieldArguments = _ref.fieldArguments,
      fieldDirectives = _ref.fieldDirectives,
      fieldName = _ref.fieldName,
      outputDefinition = _ref.outputDefinition,
      nodeInputTypeMap = _ref.nodeInputTypeMap,
      typeDefinitionMap = _ref.typeDefinitionMap,
      typeExtensionDefinitionMap = _ref.typeExtensionDefinitionMap,
      generatedTypeMap = _ref.generatedTypeMap,
      operationTypeMap = _ref.operationTypeMap,
      outputType = _ref.outputType,
      config = _ref.config;

  if (!(0, _types.isOperationTypeDefinition)({
    definition: definition,
    operationTypeMap: operationTypeMap
  })) {
    var isPrimaryKey = (0, _directives.isPrimaryKeyField)({
      directives: fieldDirectives
    });
    var isIndex = (0, _directives.isIndexedField)({
      directives: fieldDirectives
    });
    var isUnique = (0, _directives.isUniqueField)({
      directives: fieldDirectives
    });
    if (isPrimaryKey) throw new _apolloServerErrors.ApolloError("The @id directive cannot be used on @relation type fields.");
    if (isUnique) throw new _apolloServerErrors.ApolloError("The @unique directive cannot be used on @relation type fields.");
    if (isIndex) throw new _apolloServerErrors.ApolloError("The @index directive cannot be used on @relation type fields.");

    if (!(0, _directives.isCypherField)({
      directives: fieldDirectives
    })) {
      var relationshipTypeDirective = (0, _directives.getDirective)({
        directives: outputDefinition.directives,
        name: _directives.DirectiveDefinition.RELATION
      });
      var relationshipName = (0, _directives.getDirectiveArgument)({
        directive: relationshipTypeDirective,
        name: 'name'
      });
      relationshipName = decideDefaultRelationshipName({
        relationshipTypeDirective: relationshipTypeDirective,
        outputType: outputType,
        relationshipName: relationshipName
      }); // validate if the provided node type field names are defined

      validateRelationTypeDirective({
        outputDefinition: outputDefinition,
        relationshipTypeDirective: relationshipTypeDirective,
        config: config
      });

      var _augmentRelationshipT = augmentRelationshipTypeFields({
        typeName: typeName,
        outputType: outputType,
        outputDefinition: outputDefinition,
        typeDefinitionMap: typeDefinitionMap,
        relationshipTypeDirective: relationshipTypeDirective,
        config: config
      }),
          _augmentRelationshipT2 = (0, _slicedToArray2["default"])(_augmentRelationshipT, 5),
          fromType = _augmentRelationshipT2[0],
          toType = _augmentRelationshipT2[1],
          propertyInputValues = _augmentRelationshipT2[2],
          propertyOutputFields = _augmentRelationshipT2[3],
          relationshipInputTypeMap = _augmentRelationshipT2[4];

      var _augmentRelationshipQ = (0, _query.augmentRelationshipQueryAPI)({
        typeName: typeName,
        definition: definition,
        field: field,
        fieldArguments: fieldArguments,
        fieldName: fieldName,
        outputType: outputType,
        relationshipTypeDirective: relationshipTypeDirective,
        fromType: fromType,
        toType: toType,
        typeDefinitionMap: typeDefinitionMap,
        typeExtensionDefinitionMap: typeExtensionDefinitionMap,
        generatedTypeMap: generatedTypeMap,
        nodeInputTypeMap: nodeInputTypeMap,
        relationshipInputTypeMap: relationshipInputTypeMap,
        config: config,
        relationshipName: relationshipName,
        fieldType: fieldType,
        propertyOutputFields: propertyOutputFields
      });

      var _augmentRelationshipQ2 = (0, _slicedToArray2["default"])(_augmentRelationshipQ, 5);

      fieldType = _augmentRelationshipQ2[0];
      fieldArguments = _augmentRelationshipQ2[1];
      typeDefinitionMap = _augmentRelationshipQ2[2];
      generatedTypeMap = _augmentRelationshipQ2[3];
      nodeInputTypeMap = _augmentRelationshipQ2[4];

      var _augmentRelationshipM = (0, _mutation.augmentRelationshipMutationAPI)({
        typeName: typeName,
        fieldName: fieldName,
        outputType: outputType,
        fromType: fromType,
        toType: toType,
        relationshipDirective: relationshipTypeDirective,
        relationshipName: relationshipName,
        propertyInputValues: propertyInputValues,
        propertyOutputFields: propertyOutputFields,
        typeDefinitionMap: typeDefinitionMap,
        typeExtensionDefinitionMap: typeExtensionDefinitionMap,
        generatedTypeMap: generatedTypeMap,
        operationTypeMap: operationTypeMap,
        config: config
      });

      var _augmentRelationshipM2 = (0, _slicedToArray2["default"])(_augmentRelationshipM, 3);

      typeDefinitionMap = _augmentRelationshipM2[0];
      generatedTypeMap = _augmentRelationshipM2[1];
      operationTypeMap = _augmentRelationshipM2[2];
    }
  }

  return [fieldType, fieldArguments, nodeInputTypeMap, typeDefinitionMap, generatedTypeMap, operationTypeMap];
};

exports.augmentRelationshipTypeField = augmentRelationshipTypeField;

var validateRelationTypeDirective = function validateRelationTypeDirective(_ref2) {
  var outputDefinition = _ref2.outputDefinition,
      relationshipTypeDirective = _ref2.relationshipTypeDirective,
      _ref2$config = _ref2.config,
      config = _ref2$config === void 0 ? {} : _ref2$config;

  if (config.query !== false) {
    var outputTypeName = outputDefinition.name.value;
    var fields = outputDefinition.fields;
    validateRelationTypeNodeField({
      fields: fields,
      fieldName: RelationshipDirectionField.FROM,
      outputTypeName: outputTypeName,
      relationshipTypeDirective: relationshipTypeDirective
    });
    validateRelationTypeNodeField({
      fields: fields,
      fieldName: RelationshipDirectionField.TO,
      outputTypeName: outputTypeName,
      relationshipTypeDirective: relationshipTypeDirective
    });
  }
};

var validateRelationTypeNodeField = function validateRelationTypeNodeField(_ref3) {
  var _ref3$fields = _ref3.fields,
      fields = _ref3$fields === void 0 ? [] : _ref3$fields,
      _ref3$fieldName = _ref3.fieldName,
      fieldName = _ref3$fieldName === void 0 ? '' : _ref3$fieldName,
      _ref3$outputTypeName = _ref3.outputTypeName,
      outputTypeName = _ref3$outputTypeName === void 0 ? '' : _ref3$outputTypeName,
      _ref3$relationshipTyp = _ref3.relationshipTypeDirective,
      relationshipTypeDirective = _ref3$relationshipTyp === void 0 ? {} : _ref3$relationshipTyp;
  var name = (0, _directives.getDirectiveArgument)({
    directive: relationshipTypeDirective,
    name: fieldName
  });
  if (!name) name = fieldName;
  var fromField = (0, _fields.getFieldDefinition)({
    fields: fields,
    name: name
  });

  if (!fromField) {
    if (name === fieldName) {
      throw new _apolloServerErrors.ApolloError("The @relation directive on the ".concat(outputTypeName, " type requires either a \"").concat(fieldName, "\" argument value or a \"").concat(fieldName, "\" field definition."));
    } else {
      throw new _apolloServerErrors.ApolloError("The '".concat(fieldName, "' argument of the @relation directive on the ").concat(outputTypeName, " type is \"").concat(name, "\", but a \"").concat(name, "\" field is not defined."));
    }
  }
};
/**
 * Iterates through all field definitions of a relationship type, deciding whether
 * to generate the corresponding field or input value definitions that compose
 * the output and input types used in the Query and Mutation API
 */


var augmentRelationshipTypeFields = function augmentRelationshipTypeFields(_ref4) {
  var _relationshipInputTyp;

  var typeName = _ref4.typeName,
      outputType = _ref4.outputType,
      outputDefinition = _ref4.outputDefinition,
      typeDefinitionMap = _ref4.typeDefinitionMap,
      relationshipTypeDirective = _ref4.relationshipTypeDirective,
      config = _ref4.config;
  var fields = outputDefinition.fields;
  var fromFieldName = (0, _directives.getDirectiveArgument)({
    directive: relationshipTypeDirective,
    name: RelationshipDirectionField.FROM
  });
  var fromTypeName = (0, _fields.getFieldType)({
    fields: fields,
    name: fromFieldName
  });

  if (!fromTypeName) {
    fromTypeName = (0, _fields.getFieldType)({
      fields: fields,
      name: RelationshipDirectionField.FROM
    });
  }

  var toFieldName = (0, _directives.getDirectiveArgument)({
    directive: relationshipTypeDirective,
    name: RelationshipDirectionField.TO
  });
  var toTypeName = (0, _fields.getFieldType)({
    fields: fields,
    name: toFieldName
  });

  if (!toTypeName) {
    toTypeName = (0, _fields.getFieldType)({
      fields: fields,
      name: RelationshipDirectionField.TO
    });
  }

  var relatedTypeFilterName = "_".concat(typeName).concat(outputType, "Filter");
  var relatedTypeOrderingName = "_".concat(outputType, "Ordering");

  if (fromTypeName === toTypeName) {
    relatedTypeFilterName = "_".concat(outputType, "Filter");
    relatedTypeOrderingName = "_".concat(outputType, "Ordering");
  }

  var relationshipInputTypeMap = (_relationshipInputTyp = {}, (0, _defineProperty2["default"])(_relationshipInputTyp, _inputValues.FilteringArgument.FILTER, {
    name: relatedTypeFilterName,
    fields: []
  }), (0, _defineProperty2["default"])(_relationshipInputTyp, _inputValues.OrderingArgument.ORDER_BY, {
    name: relatedTypeOrderingName,
    values: []
  }), _relationshipInputTyp);
  var propertyInputValues = [];
  var propertyOutputFields = fields.reduce(function (outputFields, field) {
    var fieldName = field.name.value;
    var fieldDirectives = field.directives;

    if (!(0, _directives.isIgnoredField)({
      directives: fieldDirectives
    })) {
      var unwrappedType = (0, _fields.unwrapNamedType)({
        type: field.type
      });
      var _outputType = unwrappedType.name;
      var fieldDefinition = typeDefinitionMap[_outputType];
      var outputKind = fieldDefinition ? fieldDefinition.kind : '';

      if ((0, _fields.isPropertyTypeField)({
        kind: outputKind,
        type: _outputType
      })) {
        var isPrimaryKey = (0, _directives.isPrimaryKeyField)({
          directives: fieldDirectives
        });
        var isIndex = (0, _directives.isIndexedField)({
          directives: fieldDirectives
        });
        var isUnique = (0, _directives.isUniqueField)({
          directives: fieldDirectives
        });
        if (isPrimaryKey) throw new _apolloServerErrors.ApolloError("The @id directive cannot be used on @relation types.");
        if (isUnique) throw new _apolloServerErrors.ApolloError("The @unique directive cannot be used on @relation types.");
        if (isIndex) throw new _apolloServerErrors.ApolloError("The @index directive cannot be used on @relation types."); // escapes unescaped double quotes in @cypher statements

        field.directives = (0, _directives.augmentDirectives)({
          directives: fieldDirectives
        });
        relationshipInputTypeMap = (0, _inputValues.augmentInputTypePropertyFields)({
          inputTypeMap: relationshipInputTypeMap,
          field: field,
          fieldName: fieldName,
          fieldDirectives: fieldDirectives,
          outputType: _outputType,
          outputKind: outputKind
        });

        if (!(0, _directives.isCypherField)({
          directives: fieldDirectives
        })) {
          propertyInputValues.push({
            name: fieldName,
            type: unwrappedType,
            directives: fieldDirectives
          });
        }

        outputFields.push(field);
      }
    }

    return outputFields;
  }, []);

  var _buildNeo4jSystemIDFi = (0, _fields.buildNeo4jSystemIDField)({
    typeName: typeName,
    propertyOutputFields: propertyOutputFields,
    nodeInputTypeMap: relationshipInputTypeMap,
    config: config,
    isRelationship: true
  });

  var _buildNeo4jSystemIDFi2 = (0, _slicedToArray2["default"])(_buildNeo4jSystemIDFi, 2);

  propertyOutputFields = _buildNeo4jSystemIDFi2[0];
  relationshipInputTypeMap = _buildNeo4jSystemIDFi2[1];
  return [fromTypeName, toTypeName, propertyInputValues, propertyOutputFields, relationshipInputTypeMap];
};
/**
 * Generates a default value for the name argument
 * of the relation type directive, if none is provided
 */


var decideDefaultRelationshipName = function decideDefaultRelationshipName(_ref5) {
  var relationshipTypeDirective = _ref5.relationshipTypeDirective,
      outputType = _ref5.outputType,
      relationshipName = _ref5.relationshipName;

  if (relationshipTypeDirective && !relationshipName) {
    relationshipName = (0, _fields.toSnakeCase)(outputType);
  }

  return relationshipName;
};