"use strict";

var _interopRequireDefault = require("@babel/runtime-corejs2/helpers/interopRequireDefault");

var _Object$defineProperty = require("@babel/runtime-corejs2/core-js/object/define-property");

_Object$defineProperty(exports, "__esModule", {
  value: true
});

exports.neo4jgraphql = neo4jgraphql;
exports.cypherQuery = cypherQuery;
exports.cypherMutation = cypherMutation;
exports.searchSchema = exports.assertSchema = exports.cypher = exports.inferSchema = exports.makeAugmentedSchema = exports.augmentSchema = exports.augmentTypeDefs = void 0;

var _stringify = _interopRequireDefault(require("@babel/runtime-corejs2/core-js/json/stringify"));

var _regenerator = _interopRequireDefault(require("@babel/runtime-corejs2/regenerator"));

var _slicedToArray2 = _interopRequireDefault(require("@babel/runtime-corejs2/helpers/slicedToArray"));

var _objectWithoutProperties2 = _interopRequireDefault(require("@babel/runtime-corejs2/helpers/objectWithoutProperties"));

var _asyncToGenerator2 = _interopRequireDefault(require("@babel/runtime-corejs2/helpers/asyncToGenerator"));

var _graphql = require("graphql");

var _Neo4jSchemaTree = _interopRequireDefault(require("./neo4j-schema/Neo4jSchemaTree"));

var _graphQLMapper = _interopRequireDefault(require("./neo4j-schema/graphQLMapper"));

var _auth = require("./auth");

var _translate = require("./translate/translate");

var _mutation = require("./translate/mutation");

var _debug = _interopRequireDefault(require("debug"));

var _utils = require("./utils");

var _augment = require("./augment/augment");

var _types = require("./augment/types/types");

var _ast = require("./augment/ast");

var _directives = require("./augment/directives");

var _federation = require("./federation");

var _schemaAssert = require("./schemaAssert");

var _schemaSearch = require("./schemaSearch");

var neo4jGraphQLVersion = require('../package.json').version;

var debug = (0, _debug["default"])('neo4j-graphql-js');

function neo4jgraphql(_x, _x2, _x3, _x4, _x5) {
  return _neo4jgraphql.apply(this, arguments);
}

function _neo4jgraphql() {
  _neo4jgraphql = (0, _asyncToGenerator2["default"])( /*#__PURE__*/_regenerator["default"].mark(function _callee4(object, params, context, resolveInfo, debugFlag) {
    var query, cypherParams, cypherFunction, _cypherFunction, _cypherFunction2, session, buildSessionParams, sessionParams, result;

    return _regenerator["default"].wrap(function _callee4$(_context4) {
      while (1) {
        switch (_context4.prev = _context4.next) {
          case 0:
            if (!(0, _federation.isFederatedOperation)({
              resolveInfo: resolveInfo
            })) {
              _context4.next = 6;
              break;
            }

            _context4.next = 3;
            return (0, _federation.executeFederatedOperation)({
              object: object,
              params: params,
              context: context,
              resolveInfo: resolveInfo,
              debugFlag: debugFlag
            });

          case 3:
            return _context4.abrupt("return", _context4.sent);

          case 6:
            if (!(0, _auth.checkRequestError)(context)) {
              _context4.next = 8;
              break;
            }

            throw new Error((0, _auth.checkRequestError)(context));

          case 8:
            if (context.driver) {
              _context4.next = 10;
              break;
            }

            throw new Error("No Neo4j JavaScript driver instance provided. Please ensure a Neo4j JavaScript driver instance is injected into the context object at the key 'driver'.");

          case 10:
            cypherFunction = (0, _utils.isMutation)(resolveInfo) ? cypherMutation : cypherQuery;
            _cypherFunction = cypherFunction(params, context, resolveInfo, debugFlag);
            _cypherFunction2 = (0, _slicedToArray2["default"])(_cypherFunction, 2);
            query = _cypherFunction2[0];
            cypherParams = _cypherFunction2[1];

            if (debugFlag) {
              console.log("\n  Deprecation Warning: Remove `debug` parameter and use an environment variable\n  instead: `DEBUG=neo4j-graphql-js`.\n      ");
              console.log(query);
              console.log((0, _stringify["default"])(cypherParams, null, 2));
            }

            debug('%s', query);
            debug('%s', (0, _stringify["default"])(cypherParams, null, 2));
            context.driver._userAgent = "neo4j-graphql-js/".concat(neo4jGraphQLVersion);

            buildSessionParams = function buildSessionParams(ctx) {
              var paramObj = {};

              if (ctx.neo4jDatabase) {
                paramObj['database'] = ctx.neo4jDatabase;
              }

              if (ctx.neo4jBookmarks) {
                paramObj['bookmarks'] = ctx.neo4jBookmarks;
              }

              return paramObj;
            };

            if (!(context.neo4jDatabase || context.neo4jBookmarks)) {
              _context4.next = 35;
              break;
            }

            sessionParams = buildSessionParams(context);
            _context4.prev = 22;
            // connect to the specified database and/or use bookmarks
            // must be using 4.x version of driver
            session = context.driver.session(sessionParams);
            _context4.next = 33;
            break;

          case 26:
            _context4.prev = 26;
            _context4.t0 = _context4["catch"](22);

            if (!context.neo4jBookmarks) {
              _context4.next = 32;
              break;
            }

            throw new Error("context.neo4jBookmarks specified, but unable to set bookmark in session object: ".concat(_context4.t0.message));

          case 32:
            // error - not using a 4.x version of driver!
            // fall back to default database
            session = context.driver.session();

          case 33:
            _context4.next = 36;
            break;

          case 35:
            // no database or bookmark specified
            session = context.driver.session();

          case 36:
            _context4.prev = 36;

            if (!(0, _utils.isMutation)(resolveInfo)) {
              _context4.next = 43;
              break;
            }

            _context4.next = 40;
            return session.writeTransaction( /*#__PURE__*/function () {
              var _ref7 = (0, _asyncToGenerator2["default"])( /*#__PURE__*/_regenerator["default"].mark(function _callee2(tx) {
                var result;
                return _regenerator["default"].wrap(function _callee2$(_context2) {
                  while (1) {
                    switch (_context2.prev = _context2.next) {
                      case 0:
                        _context2.next = 2;
                        return tx.run(query, cypherParams);

                      case 2:
                        result = _context2.sent;
                        return _context2.abrupt("return", (0, _utils.extractQueryResult)(result, resolveInfo.returnType));

                      case 4:
                      case "end":
                        return _context2.stop();
                    }
                  }
                }, _callee2);
              }));

              return function (_x7) {
                return _ref7.apply(this, arguments);
              };
            }());

          case 40:
            result = _context4.sent;
            _context4.next = 46;
            break;

          case 43:
            _context4.next = 45;
            return session.readTransaction( /*#__PURE__*/function () {
              var _ref8 = (0, _asyncToGenerator2["default"])( /*#__PURE__*/_regenerator["default"].mark(function _callee3(tx) {
                var result;
                return _regenerator["default"].wrap(function _callee3$(_context3) {
                  while (1) {
                    switch (_context3.prev = _context3.next) {
                      case 0:
                        _context3.next = 2;
                        return tx.run(query, cypherParams);

                      case 2:
                        result = _context3.sent;
                        return _context3.abrupt("return", (0, _utils.extractQueryResult)(result, resolveInfo.returnType));

                      case 4:
                      case "end":
                        return _context3.stop();
                    }
                  }
                }, _callee3);
              }));

              return function (_x8) {
                return _ref8.apply(this, arguments);
              };
            }());

          case 45:
            result = _context4.sent;

          case 46:
            _context4.prev = 46;
            session.close();
            return _context4.finish(46);

          case 49:
            return _context4.abrupt("return", result);

          case 50:
          case "end":
            return _context4.stop();
        }
      }
    }, _callee4, null, [[22, 26], [36,, 46, 49]]);
  }));
  return _neo4jgraphql.apply(this, arguments);
}

function cypherQuery(_ref, context, resolveInfo) {
  var _ref$first = _ref.first,
      first = _ref$first === void 0 ? -1 : _ref$first,
      _ref$offset = _ref.offset,
      offset = _ref$offset === void 0 ? 0 : _ref$offset,
      _id = _ref._id,
      orderBy = _ref.orderBy,
      otherParams = (0, _objectWithoutProperties2["default"])(_ref, ["first", "offset", "_id", "orderBy"]);

  var _typeIdentifiers = (0, _utils.typeIdentifiers)(resolveInfo.returnType),
      typeName = _typeIdentifiers.typeName,
      variableName = _typeIdentifiers.variableName;

  var schemaType = resolveInfo.schema.getType(typeName);
  var selections = (0, _utils.getPayloadSelections)(resolveInfo);
  return (0, _translate.translateQuery)({
    resolveInfo: resolveInfo,
    context: context,
    schemaType: schemaType,
    selections: selections,
    variableName: variableName,
    typeName: typeName,
    first: first,
    offset: offset,
    _id: _id,
    orderBy: orderBy,
    otherParams: otherParams
  });
}

function cypherMutation(_ref2, context, resolveInfo) {
  var _ref2$first = _ref2.first,
      first = _ref2$first === void 0 ? -1 : _ref2$first,
      _ref2$offset = _ref2.offset,
      offset = _ref2$offset === void 0 ? 0 : _ref2$offset,
      _id = _ref2._id,
      orderBy = _ref2.orderBy,
      otherParams = (0, _objectWithoutProperties2["default"])(_ref2, ["first", "offset", "_id", "orderBy"]);

  var _typeIdentifiers2 = (0, _utils.typeIdentifiers)(resolveInfo.returnType),
      typeName = _typeIdentifiers2.typeName,
      variableName = _typeIdentifiers2.variableName;

  var schemaType = resolveInfo.schema.getType(typeName);
  var selections = (0, _utils.getPayloadSelections)(resolveInfo);
  return (0, _mutation.translateMutation)({
    resolveInfo: resolveInfo,
    context: context,
    schemaType: schemaType,
    selections: selections,
    variableName: variableName,
    typeName: typeName,
    first: first,
    offset: offset,
    otherParams: otherParams
  });
}

var augmentTypeDefs = function augmentTypeDefs(typeDefs) {
  var config = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
  config.query = false;
  config.mutation = false;
  if (config.isFederated === undefined) config.isFederated = false;
  var isParsedTypeDefs = (0, _types.isSchemaDocument)({
    definition: typeDefs
  });
  var definitions = [];

  if (isParsedTypeDefs) {
    // Print if we recieved parsed type definitions in a GraphQL Document
    definitions = typeDefs.definitions;
  } else {
    // Otherwise parse the SDL and get its definitions
    definitions = (0, _graphql.parse)(typeDefs).definitions;
  }

  var generatedTypeMap = {};

  var _mapDefinitions = (0, _augment.mapDefinitions)({
    definitions: definitions,
    config: config
  }),
      _mapDefinitions2 = (0, _slicedToArray2["default"])(_mapDefinitions, 5),
      typeDefinitionMap = _mapDefinitions2[0],
      typeExtensionDefinitionMap = _mapDefinitions2[1],
      directiveDefinitionMap = _mapDefinitions2[2],
      operationTypeMap = _mapDefinitions2[3],
      schemaTypeDefinition = _mapDefinitions2[4];

  var _augmentTypes = (0, _types.augmentTypes)({
    typeDefinitionMap: typeDefinitionMap,
    typeExtensionDefinitionMap: typeExtensionDefinitionMap,
    generatedTypeMap: generatedTypeMap,
    operationTypeMap: operationTypeMap,
    config: config
  });

  var _augmentTypes2 = (0, _slicedToArray2["default"])(_augmentTypes, 3);

  typeExtensionDefinitionMap = _augmentTypes2[0];
  generatedTypeMap = _augmentTypes2[1];
  operationTypeMap = _augmentTypes2[2];

  var _augmentDirectiveDefi = (0, _directives.augmentDirectiveDefinitions)({
    typeDefinitionMap: generatedTypeMap,
    directiveDefinitionMap: directiveDefinitionMap,
    config: config
  });

  var _augmentDirectiveDefi2 = (0, _slicedToArray2["default"])(_augmentDirectiveDefi, 2);

  typeDefinitionMap = _augmentDirectiveDefi2[0];
  directiveDefinitionMap = _augmentDirectiveDefi2[1];
  var mergedDefinitions = (0, _augment.mergeDefinitionMaps)({
    generatedTypeMap: generatedTypeMap,
    typeExtensionDefinitionMap: typeExtensionDefinitionMap,
    operationTypeMap: operationTypeMap,
    directiveDefinitionMap: directiveDefinitionMap,
    schemaTypeDefinition: schemaTypeDefinition
  });
  var transformedDefinitions = (0, _types.transformNeo4jTypes)({
    definitions: mergedDefinitions,
    config: config
  });
  var documentAST = (0, _ast.buildDocument)({
    definitions: transformedDefinitions
  });

  if (config.isFederated === true) {
    return documentAST;
  }

  return (0, _graphql.print)(documentAST);
};

exports.augmentTypeDefs = augmentTypeDefs;

var augmentSchema = function augmentSchema(schema, config) {
  return (0, _augment.augmentedSchema)(schema, config);
};

exports.augmentSchema = augmentSchema;

var makeAugmentedSchema = function makeAugmentedSchema(_ref3) {
  var schema = _ref3.schema,
      typeDefs = _ref3.typeDefs,
      _ref3$resolvers = _ref3.resolvers,
      resolvers = _ref3$resolvers === void 0 ? {} : _ref3$resolvers,
      logger = _ref3.logger,
      _ref3$allowUndefinedI = _ref3.allowUndefinedInResolve,
      allowUndefinedInResolve = _ref3$allowUndefinedI === void 0 ? false : _ref3$allowUndefinedI,
      _ref3$resolverValidat = _ref3.resolverValidationOptions,
      resolverValidationOptions = _ref3$resolverValidat === void 0 ? {} : _ref3$resolverValidat,
      _ref3$directiveResolv = _ref3.directiveResolvers,
      directiveResolvers = _ref3$directiveResolv === void 0 ? null : _ref3$directiveResolv,
      _ref3$schemaDirective = _ref3.schemaDirectives,
      schemaDirectives = _ref3$schemaDirective === void 0 ? {} : _ref3$schemaDirective,
      _ref3$schemaTransform = _ref3.schemaTransforms,
      schemaTransforms = _ref3$schemaTransform === void 0 ? [] : _ref3$schemaTransform,
      _ref3$parseOptions = _ref3.parseOptions,
      parseOptions = _ref3$parseOptions === void 0 ? {} : _ref3$parseOptions,
      _ref3$inheritResolver = _ref3.inheritResolversFromInterfaces,
      inheritResolversFromInterfaces = _ref3$inheritResolver === void 0 ? false : _ref3$inheritResolver,
      config = _ref3.config;

  if (schema) {
    return (0, _augment.augmentedSchema)(schema, config);
  }

  if (!typeDefs) throw new Error('Must provide typeDefs');
  return (0, _augment.makeAugmentedExecutableSchema)({
    typeDefs: typeDefs,
    resolvers: resolvers,
    logger: logger,
    allowUndefinedInResolve: allowUndefinedInResolve,
    resolverValidationOptions: resolverValidationOptions,
    directiveResolvers: directiveResolvers,
    schemaDirectives: schemaDirectives,
    schemaTransforms: schemaTransforms,
    parseOptions: parseOptions,
    inheritResolversFromInterfaces: inheritResolversFromInterfaces,
    config: config
  });
};
/**
 * Infer a GraphQL schema by inspecting the contents of a Neo4j instance.
 * @param {} driver
 * @returns a GraphQL schema.
 */


exports.makeAugmentedSchema = makeAugmentedSchema;

var inferSchema = function inferSchema(driver) {
  var config = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
  var tree = new _Neo4jSchemaTree["default"](driver, config);
  return tree.initialize().then(_graphQLMapper["default"]);
};

exports.inferSchema = inferSchema;

var cypher = function cypher(statement) {
  // Get the array of string literals
  var literals = statement.raw; // Add each substitution inbetween all

  for (var _len = arguments.length, substitutions = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
    substitutions[_key - 1] = arguments[_key];
  }

  var composed = substitutions.reduce(function (composed, substitution, index) {
    // Add the string literal
    composed.push(literals[index]); // Add the substution proceeding it

    composed.push(substitution);
    return composed;
  }, []); // Add the last literal

  composed.push(literals[literals.length - 1]);
  return "statement: \"\"\"".concat(composed.join(''), "\"\"\"");
};

exports.cypher = cypher;

var assertSchema = function assertSchema(_ref4) {
  var driver = _ref4.driver,
      schema = _ref4.schema,
      _ref4$dropExisting = _ref4.dropExisting,
      dropExisting = _ref4$dropExisting === void 0 ? true : _ref4$dropExisting,
      _ref4$debug = _ref4.debug,
      debug = _ref4$debug === void 0 ? false : _ref4$debug;
  var statement = (0, _schemaAssert.schemaAssert)({
    schema: schema,
    dropExisting: dropExisting
  });

  var executeQuery = function executeQuery(driver) {
    var session = driver.session();
    return session.writeTransaction(function (tx) {
      return tx.run(statement).then(function (result) {
        if (debug === true) {
          var recordsJSON = result.records.map(function (record) {
            return record.toObject();
          });
          recordsJSON.sort(function (lhs, rhs) {
            return lhs.label < rhs.label;
          });
          console.table(recordsJSON);
        }

        return result;
      });
    })["finally"](function () {
      return session.close();
    });
  };

  return executeQuery(driver)["catch"](function (error) {
    console.error(error);
  });
};

exports.assertSchema = assertSchema;

var searchSchema = /*#__PURE__*/function () {
  var _ref6 = (0, _asyncToGenerator2["default"])( /*#__PURE__*/_regenerator["default"].mark(function _callee(_ref5) {
    var driver, schema, _ref5$debug, debug, session, dropStatement, createStatement, dropResult;

    return _regenerator["default"].wrap(function _callee$(_context) {
      while (1) {
        switch (_context.prev = _context.next) {
          case 0:
            driver = _ref5.driver, schema = _ref5.schema, _ref5$debug = _ref5.debug, debug = _ref5$debug === void 0 ? false : _ref5$debug;
            session = driver.session(); // drop all search indexes, given they cannot be updated via a second CALL to createNodeIndex

            dropStatement = "\n  CALL db.indexes() YIELD name, provider WHERE provider = \"fulltext-1.0\"\n  CALL db.index.fulltext.drop(name)\n  RETURN TRUE\n  ";
            createStatement = (0, _schemaSearch.schemaSearch)({
              schema: schema
            });
            _context.next = 6;
            return session.writeTransaction(function (tx) {
              return tx.run(dropStatement).then(function (result) {
                if (debug === true) {
                  console.log("\n[searchSchema] Search indexes dropped using Cypher:".concat(dropStatement));
                }

                return true;
              });
            });

          case 6:
            dropResult = _context.sent;

            if (!dropResult) {
              _context.next = 18;
              break;
            }

            if (!createStatement) {
              _context.next = 14;
              break;
            }

            _context.next = 11;
            return session.writeTransaction(function (tx) {
              return tx.run(createStatement).then(function (result) {
                if (debug === true) {
                  console.log("[searchSchema] Search indexes created using Cypher:\n".concat(createStatement, "\n"));
                }

                return true;
              });
            })["finally"](function () {
              return session.close();
            });

          case 11:
            return _context.abrupt("return", _context.sent);

          case 14:
            if (debug === true) {
              console.log('[searchSchema] There were no @search directive fields discovered in the schema.\n');
            }

            return _context.abrupt("return", true);

          case 16:
            _context.next = 19;
            break;

          case 18:
            session.close();

          case 19:
            return _context.abrupt("return", false);

          case 20:
          case "end":
            return _context.stop();
        }
      }
    }, _callee);
  }));

  return function searchSchema(_x6) {
    return _ref6.apply(this, arguments);
  };
}();

exports.searchSchema = searchSchema;