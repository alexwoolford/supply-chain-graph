"use strict";

var _interopRequireDefault = require("@babel/runtime-corejs2/helpers/interopRequireDefault");

var _Object$defineProperty = require("@babel/runtime-corejs2/core-js/object/define-property");

var _Object$defineProperties = require("@babel/runtime-corejs2/core-js/object/define-properties");

var _Object$getOwnPropertyDescriptors = require("@babel/runtime-corejs2/core-js/object/get-own-property-descriptors");

var _Object$getOwnPropertyDescriptor = require("@babel/runtime-corejs2/core-js/object/get-own-property-descriptor");

var _Object$getOwnPropertySymbols = require("@babel/runtime-corejs2/core-js/object/get-own-property-symbols");

var _Object$keys = require("@babel/runtime-corejs2/core-js/object/keys");

_Object$defineProperty(exports, "__esModule", {
  value: true
});

exports.schemaAssert = void 0;

var _stringify = _interopRequireDefault(require("@babel/runtime-corejs2/core-js/json/stringify"));

var _defineProperty2 = _interopRequireDefault(require("@babel/runtime-corejs2/helpers/defineProperty"));

var _values = _interopRequireDefault(require("@babel/runtime-corejs2/core-js/object/values"));

var _slicedToArray2 = _interopRequireDefault(require("@babel/runtime-corejs2/helpers/slicedToArray"));

var _entries = _interopRequireDefault(require("@babel/runtime-corejs2/core-js/object/entries"));

var _utils = require("./utils");

var _directives = require("./augment/directives");

var _types = require("./augment/types/types");

var _selection = require("./augment/types/node/selection");

function ownKeys(object, enumerableOnly) { var keys = _Object$keys(object); if (_Object$getOwnPropertySymbols) { var symbols = _Object$getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return _Object$getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }

function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(Object(source), true).forEach(function (key) { (0, _defineProperty2["default"])(target, key, source[key]); }); } else if (_Object$getOwnPropertyDescriptors) { _Object$defineProperties(target, _Object$getOwnPropertyDescriptors(source)); } else { ownKeys(Object(source)).forEach(function (key) { _Object$defineProperty(target, key, _Object$getOwnPropertyDescriptor(source, key)); }); } } return target; }

var schemaAssert = function schemaAssert(_ref) {
  var schema = _ref.schema,
      indexLabels = _ref.indexLabels,
      constraintLabels = _ref.constraintLabels,
      _ref$dropExisting = _ref.dropExisting,
      dropExisting = _ref$dropExisting === void 0 ? true : _ref$dropExisting;
  if (!indexLabels) indexLabels = "{}";
  if (!constraintLabels) constraintLabels = "{}";

  if (schema) {
    var indexFieldTypeMap = buildKeyTypeMap({
      schema: schema,
      directives: [_directives.DirectiveDefinition.INDEX]
    });
    indexLabels = cypherMap({
      typeMap: indexFieldTypeMap
    });
    var uniqueFieldTypeMap = buildKeyTypeMap({
      schema: schema,
      directives: [_directives.DirectiveDefinition.ID, _directives.DirectiveDefinition.UNIQUE]
    });
    constraintLabels = cypherMap({
      typeMap: uniqueFieldTypeMap
    });
  }

  return "CALL apoc.schema.assert(".concat(indexLabels, ", ").concat(constraintLabels).concat(dropExisting === false ? ", ".concat(dropExisting) : '', ")");
};

exports.schemaAssert = schemaAssert;

var buildKeyTypeMap = function buildKeyTypeMap(_ref2) {
  var schema = _ref2.schema,
      _ref2$directives = _ref2.directives,
      directives = _ref2$directives === void 0 ? [] : _ref2$directives;
  var typeMap = schema ? schema.getTypeMap() : {};
  return (0, _entries["default"])(typeMap).reduce(function (mapped, _ref3) {
    var _ref4 = (0, _slicedToArray2["default"])(_ref3, 2),
        typeName = _ref4[0],
        definition = _ref4[1].astNode;

    if ((0, _types.isNodeType)({
      definition: definition
    }) && !(0, _types.isUnionTypeDefinition)({
      definition: definition
    })) {
      var type = schema.getType(typeName);
      var fieldMap = type.getFields();
      var fields = (0, _values["default"])(fieldMap).map(function (field) {
        return field.astNode;
      });
      var keyFields = (0, _selection.getKeyFields)({
        fields: fields
      });

      if (keyFields.length && directives.length) {
        var directiveFields = keyFields.filter(function (field) {
          // there exists at least one directive on this field
          // matching a directive we want to map
          return directives.some(function (directive) {
            return (0, _utils.getFieldDirective)(field, directive);
          });
        });

        if (directiveFields.length) {
          mapped[typeName] = _objectSpread(_objectSpread({}, definition), {}, {
            fields: directiveFields
          });
        }
      }
    }

    return mapped;
  }, {});
};

var cypherMap = function cypherMap(_ref5) {
  var _ref5$typeMap = _ref5.typeMap,
      typeMap = _ref5$typeMap === void 0 ? {} : _ref5$typeMap;
  // The format of a Cypher map is close to JSON but does not quote keys
  var cypherMapFormat = (0, _entries["default"])(typeMap).map(function (_ref6) {
    var _ref7 = (0, _slicedToArray2["default"])(_ref6, 2),
        typeName = _ref7[0],
        astNode = _ref7[1];

    var fields = astNode.fields || [];
    var fieldNames = fields.map(function (field) {
      return field.name.value;
    });
    var assertions = (0, _stringify["default"])(fieldNames);
    return "".concat(typeName, ":").concat(assertions);
  });
  return "{".concat(cypherMapFormat, "}");
};