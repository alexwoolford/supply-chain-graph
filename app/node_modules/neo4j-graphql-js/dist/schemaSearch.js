"use strict";

var _interopRequireDefault = require("@babel/runtime-corejs2/helpers/interopRequireDefault");

var _Object$defineProperty = require("@babel/runtime-corejs2/core-js/object/define-property");

_Object$defineProperty(exports, "__esModule", {
  value: true
});

exports.mapSearchDirectives = exports.schemaSearch = void 0;

var _defineProperty2 = _interopRequireDefault(require("@babel/runtime-corejs2/helpers/defineProperty"));

var _stringify = _interopRequireDefault(require("@babel/runtime-corejs2/core-js/json/stringify"));

var _keys = _interopRequireDefault(require("@babel/runtime-corejs2/core-js/object/keys"));

var _slicedToArray2 = _interopRequireDefault(require("@babel/runtime-corejs2/helpers/slicedToArray"));

var _entries = _interopRequireDefault(require("@babel/runtime-corejs2/core-js/object/entries"));

var _utils = require("./utils");

var _directives = require("./augment/directives");

var _types = require("./augment/types/types");

var _fields = require("./augment/fields");

var _graphql = require("graphql");

var _apolloServerErrors = require("apollo-server-errors");

var CREATE_NODE_INDEX = "CALL db.index.fulltext.createNodeIndex";

var schemaSearch = function schemaSearch(_ref) {
  var schema = _ref.schema;
  var statement = '';
  var statements = [];

  if (schema) {
    var searchFieldTypeMap = mapSearchDirectives({
      schema: schema
    });
    statements = (0, _entries["default"])(searchFieldTypeMap).map(function (_ref2) {
      var _ref3 = (0, _slicedToArray2["default"])(_ref2, 2),
          name = _ref3[0],
          config = _ref3[1];

      var labelMap = config.labelMap,
          properties = config.properties;
      var labels = (0, _keys["default"])(labelMap);
      var labelVariable = (0, _stringify["default"])(labels);
      var propertyVariable = (0, _stringify["default"])(properties); // create the index anew

      return "  ".concat(CREATE_NODE_INDEX, "(\"").concat(name, "\",").concat(labelVariable, ",").concat(propertyVariable, ")");
    });
  }

  if (statements.length) {
    statement = "".concat(statements.join('\n'), "\n  RETURN TRUE");
  }

  return statement;
};

exports.schemaSearch = schemaSearch;

var mapSearchDirectives = function mapSearchDirectives(_ref4) {
  var schema = _ref4.schema;
  var typeMap = schema ? schema.getTypeMap() : {};
  return (0, _entries["default"])(typeMap).reduce(function (mapped, _ref5) {
    var _ref6 = (0, _slicedToArray2["default"])(_ref5, 2),
        typeName = _ref6[0],
        definition = _ref6[1].astNode;

    if ((0, _types.isNodeType)({
      definition: definition
    }) && !(0, _types.isUnionTypeDefinition)({
      definition: definition
    })) {
      var type = schema.getType(typeName);
      var fieldMap = type.getFields();
      (0, _entries["default"])(fieldMap).forEach(function (_ref7) {
        var _ref8 = (0, _slicedToArray2["default"])(_ref7, 2),
            name = _ref8[0],
            field = _ref8[1];

        var astNode = field.astNode;

        if (astNode) {
          var unwrappedType = (0, _fields.unwrapNamedType)({
            type: astNode.type
          });
          var fieldTypeName = unwrappedType.name;
          var fieldTypeWrappers = unwrappedType.wrappers;
          var directives = astNode.directives;
          var directive = (0, _directives.getDirective)({
            directives: directives,
            name: _directives.DirectiveDefinition.SEARCH
          });

          if (directive) {
            var isStringType = fieldTypeName === _graphql.GraphQLString.name;
            var isIDType = fieldTypeName === _graphql.GraphQLID.name;
            var isListField = fieldTypeWrappers[_fields.TypeWrappers.LIST_TYPE];

            if (isIDType || isStringType) {
              if (!isListField) {
                var searchIndexName = (0, _directives.getDirectiveArgument)({
                  directive: directive,
                  name: 'index'
                });
                if (!searchIndexName) searchIndexName = "".concat(typeName, "Search");

                if (!mapped[searchIndexName]) {
                  mapped[searchIndexName] = {
                    labelMap: (0, _defineProperty2["default"])({}, typeName, true),
                    properties: [name]
                  };
                } else {
                  var indexEntry = mapped[searchIndexName];
                  var labelMap = indexEntry.labelMap;
                  var firstLabel = (0, _keys["default"])(labelMap)[0];

                  if (labelMap[typeName]) {
                    mapped[searchIndexName].properties.push(name);
                  } else {
                    throw new _apolloServerErrors.ApolloError("The ".concat(searchIndexName, " index on the ").concat(firstLabel, " type cannot be used on the ").concat(name, " field of the ").concat(typeName, " type, because composite search indexes are not yet supported."));
                  }
                }
              } else {
                throw new _apolloServerErrors.ApolloError("The @search directive on the ".concat(name, " field of the ").concat(typeName, " type is invalid, because search indexes cannot currently be set for list type fields."));
              }
            } else {
              throw new _apolloServerErrors.ApolloError("The @search directive on the ".concat(name, " field of the ").concat(typeName, " type is invalid, because search indexes can only be set for String and ID type fields."));
            }
          }
        }
      });
    }

    return mapped;
  }, {});
};

exports.mapSearchDirectives = mapSearchDirectives;