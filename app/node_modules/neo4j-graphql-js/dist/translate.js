"use strict";

var _interopRequireDefault = require("@babel/runtime-corejs2/helpers/interopRequireDefault");

var _Object$defineProperty2 = require("@babel/runtime-corejs2/core-js/object/define-property");

_Object$defineProperty2(exports, "__esModule", {
  value: true
});

exports.translateListArguments = exports.translateMutation = exports.translateQuery = exports.neo4jType = exports.neo4jTypeField = exports.nodeTypeFieldOnRelationType = exports.relationTypeFieldOnNodeType = exports.relationFieldOnNodeType = exports.customCypherField = exports.derivedTypesParams = exports.fragmentType = void 0;

var _defineProperty2 = _interopRequireDefault(require("@babel/runtime-corejs2/core-js/object/define-property"));

var _defineProperties = _interopRequireDefault(require("@babel/runtime-corejs2/core-js/object/define-properties"));

var _getOwnPropertyDescriptors = _interopRequireDefault(require("@babel/runtime-corejs2/core-js/object/get-own-property-descriptors"));

var _getOwnPropertyDescriptor = _interopRequireDefault(require("@babel/runtime-corejs2/core-js/object/get-own-property-descriptor"));

var _getOwnPropertySymbols = _interopRequireDefault(require("@babel/runtime-corejs2/core-js/object/get-own-property-symbols"));

var _isInteger = _interopRequireDefault(require("@babel/runtime-corejs2/core-js/number/is-integer"));

var _entries = _interopRequireDefault(require("@babel/runtime-corejs2/core-js/object/entries"));

var _values = _interopRequireDefault(require("@babel/runtime-corejs2/core-js/object/values"));

var _keys = _interopRequireDefault(require("@babel/runtime-corejs2/core-js/object/keys"));

var _toConsumableArray2 = _interopRequireDefault(require("@babel/runtime-corejs2/helpers/toConsumableArray"));

var _isArray = _interopRequireDefault(require("@babel/runtime-corejs2/core-js/array/is-array"));

var _defineProperty3 = _interopRequireDefault(require("@babel/runtime-corejs2/helpers/defineProperty"));

var _slicedToArray2 = _interopRequireDefault(require("@babel/runtime-corejs2/helpers/slicedToArray"));

var _utils = require("./utils");

var _selection = require("./augment/types/node/selection");

var _graphql = require("graphql");

var _selections = require("./selections");

var _lodash = _interopRequireDefault(require("lodash"));

var _neo4jDriver = _interopRequireDefault(require("neo4j-driver"));

var _types = require("./augment/types/types");

var _federation = require("./federation");

var _fields = require("./augment/fields");

var _inputValues = require("./augment/input-values");

var _query = require("./augment/types/relationship/query");

function ownKeys(object, enumerableOnly) { var keys = (0, _keys["default"])(object); if (_getOwnPropertySymbols["default"]) { var symbols = (0, _getOwnPropertySymbols["default"])(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return (0, _getOwnPropertyDescriptor["default"])(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }

function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(Object(source), true).forEach(function (key) { (0, _defineProperty3["default"])(target, key, source[key]); }); } else if (_getOwnPropertyDescriptors["default"]) { (0, _defineProperties["default"])(target, (0, _getOwnPropertyDescriptors["default"])(source)); } else { ownKeys(Object(source)).forEach(function (key) { (0, _defineProperty2["default"])(target, key, (0, _getOwnPropertyDescriptor["default"])(source, key)); }); } } return target; }

var derivedTypesParamName = function derivedTypesParamName(schemaTypeName) {
  return "".concat(schemaTypeName, "_derivedTypes");
};

var fragmentType = function fragmentType(varName, schemaTypeName) {
  return "FRAGMENT_TYPE: head( [ label IN labels(".concat(varName, ") WHERE label IN $").concat(derivedTypesParamName(schemaTypeName), " ] )");
};

exports.fragmentType = fragmentType;

var derivedTypesParams = function derivedTypesParams(_ref) {
  var isInterfaceType = _ref.isInterfaceType,
      isUnionType = _ref.isUnionType,
      schema = _ref.schema,
      schemaTypeName = _ref.schemaTypeName,
      usesFragments = _ref.usesFragments;
  var params = {};

  if (!usesFragments) {
    if (isInterfaceType) {
      var paramName = derivedTypesParamName(schemaTypeName);
      params[paramName] = (0, _utils.getInterfaceDerivedTypeNames)(schema, schemaTypeName);
    } else if (isUnionType) {
      var _paramName = derivedTypesParamName(schemaTypeName);

      var typeMap = schema.getTypeMap();
      var schemaType = typeMap[schemaTypeName];
      var types = schemaType.getTypes();
      params[_paramName] = types.map(function (type) {
        return type.name;
      });
    }
  }

  return params;
};

exports.derivedTypesParams = derivedTypesParams;

var customCypherField = function customCypherField(_ref2) {
  var customCypherStatement = _ref2.customCypherStatement,
      cypherParams = _ref2.cypherParams,
      paramIndex = _ref2.paramIndex,
      schemaTypeRelation = _ref2.schemaTypeRelation,
      isObjectTypeField = _ref2.isObjectTypeField,
      isInterfaceTypeField = _ref2.isInterfaceTypeField,
      isUnionTypeField = _ref2.isUnionTypeField,
      usesFragments = _ref2.usesFragments,
      schemaTypeFields = _ref2.schemaTypeFields,
      derivedTypeMap = _ref2.derivedTypeMap,
      initial = _ref2.initial,
      fieldName = _ref2.fieldName,
      fieldType = _ref2.fieldType,
      nestedVariable = _ref2.nestedVariable,
      variableName = _ref2.variableName,
      headSelection = _ref2.headSelection,
      schemaType = _ref2.schemaType,
      innerSchemaType = _ref2.innerSchemaType,
      resolveInfo = _ref2.resolveInfo,
      subSelection = _ref2.subSelection,
      skipLimit = _ref2.skipLimit,
      commaIfTail = _ref2.commaIfTail,
      tailParams = _ref2.tailParams,
      isFederatedOperation = _ref2.isFederatedOperation,
      context = _ref2.context;

  var _buildMapProjection = buildMapProjection({
    isComputedField: true,
    schemaType: innerSchemaType,
    isObjectType: isObjectTypeField,
    isInterfaceType: isInterfaceTypeField,
    isUnionType: isUnionTypeField,
    usesFragments: usesFragments,
    safeVariableName: nestedVariable,
    subQuery: subSelection[0],
    schemaTypeFields: schemaTypeFields,
    derivedTypeMap: derivedTypeMap,
    resolveInfo: resolveInfo
  }),
      _buildMapProjection2 = (0, _slicedToArray2["default"])(_buildMapProjection, 2),
      mapProjection = _buildMapProjection2[0],
      labelPredicate = _buildMapProjection2[1];

  var headListWrapperPrefix = "".concat(!(0, _utils.isArrayType)(fieldType) ? 'head(' : '');
  var headListWrapperSuffix = "".concat(!(0, _utils.isArrayType)(fieldType) ? ')' : ''); // For @cypher fields with object payload types, customCypherField is
  // called after the recursive call to compute a subSelection. But recurse()
  // increments paramIndex. So here we need to decrement it in order to map
  // appropriately to the indexed keys produced in getFilterParams()

  var cypherFieldParamsIndex = paramIndex - 1;

  if (schemaTypeRelation) {
    variableName = "".concat(variableName, "_relation");
  }

  return _objectSpread({
    initial: "".concat(initial).concat(fieldName, ": ").concat(headListWrapperPrefix).concat(labelPredicate ? "[".concat(nestedVariable, " IN ") : '', "[ ").concat(nestedVariable, " IN apoc.cypher.runFirstColumn(\"").concat(customCypherStatement, "\", {").concat((0, _utils.cypherDirectiveArgs)(variableName, headSelection, cypherParams, schemaType, resolveInfo, cypherFieldParamsIndex, isFederatedOperation, context), "}, true) ").concat(labelPredicate, "| ").concat(labelPredicate ? "".concat(nestedVariable, "] | ") : '').concat(mapProjection, "]").concat(headListWrapperSuffix).concat(skipLimit, " ").concat(commaIfTail)
  }, tailParams);
};

exports.customCypherField = customCypherField;

var relationFieldOnNodeType = function relationFieldOnNodeType(_ref3) {
  var initial = _ref3.initial,
      fieldName = _ref3.fieldName,
      fieldType = _ref3.fieldType,
      fieldSelectionSet = _ref3.fieldSelectionSet,
      variableName = _ref3.variableName,
      relDirection = _ref3.relDirection,
      relType = _ref3.relType,
      nestedVariable = _ref3.nestedVariable,
      schemaTypeFields = _ref3.schemaTypeFields,
      derivedTypeMap = _ref3.derivedTypeMap,
      isObjectTypeField = _ref3.isObjectTypeField,
      isInterfaceTypeField = _ref3.isInterfaceTypeField,
      isUnionTypeField = _ref3.isUnionTypeField,
      usesFragments = _ref3.usesFragments,
      innerSchemaType = _ref3.innerSchemaType,
      paramIndex = _ref3.paramIndex,
      fieldArgs = _ref3.fieldArgs,
      filterParams = _ref3.filterParams,
      selectionFilters = _ref3.selectionFilters,
      neo4jTypeArgs = _ref3.neo4jTypeArgs,
      fieldsForTranslation = _ref3.fieldsForTranslation,
      subSelection = _ref3.subSelection,
      skipLimit = _ref3.skipLimit,
      commaIfTail = _ref3.commaIfTail,
      tailParams = _ref3.tailParams,
      resolveInfo = _ref3.resolveInfo,
      cypherParams = _ref3.cypherParams;
  var safeVariableName = (0, _utils.safeVar)(nestedVariable);
  var subQuery = subSelection[0];

  var _buildMapProjection3 = buildMapProjection({
    schemaType: innerSchemaType,
    isObjectType: isObjectTypeField,
    isInterfaceType: isInterfaceTypeField,
    isUnionType: isUnionTypeField,
    usesFragments: usesFragments,
    safeVariableName: safeVariableName,
    subQuery: subQuery,
    schemaTypeFields: schemaTypeFields,
    derivedTypeMap: derivedTypeMap,
    resolveInfo: resolveInfo
  }),
      _buildMapProjection4 = (0, _slicedToArray2["default"])(_buildMapProjection3, 2),
      mapProjection = _buildMapProjection4[0],
      labelPredicate = _buildMapProjection4[1];

  var allParams = (0, _utils.innerFilterParams)(filterParams, neo4jTypeArgs);
  var queryParams = (0, _utils.paramsToString)(_lodash["default"].filter(allParams, function (param) {
    var value = param.value.value !== undefined ? param.value.value : param.value;
    return !(0, _isArray["default"])(value);
  }));

  var _processFilterArgumen = processFilterArgument({
    fieldArgs: fieldArgs,
    schemaType: innerSchemaType,
    variableName: nestedVariable,
    resolveInfo: resolveInfo,
    params: selectionFilters,
    paramIndex: paramIndex
  }),
      _processFilterArgumen2 = (0, _slicedToArray2["default"])(_processFilterArgumen, 2),
      filterPredicates = _processFilterArgumen2[0],
      serializedFilterParam = _processFilterArgumen2[1];

  var filterParamKey = "".concat(tailParams.paramIndex, "_filter");
  var fieldArgumentParams = subSelection[1];
  var filterParam = fieldArgumentParams[filterParamKey];

  if (filterParam && typeof serializedFilterParam[filterParamKey] !== 'undefined') {
    subSelection[1][filterParamKey] = serializedFilterParam[filterParamKey];
  }

  var neo4jTypeClauses = (0, _utils.neo4jTypePredicateClauses)(filterParams, nestedVariable, neo4jTypeArgs);
  var arrayPredicates = translateListArguments({
    schemaType: innerSchemaType,
    fieldArgs: fieldArgs,
    filterParams: filterParams,
    safeVariableName: safeVariableName,
    resolveInfo: resolveInfo
  });

  var _translateNestedOrder = translateNestedOrderingArgument({
    schemaType: innerSchemaType,
    selections: fieldsForTranslation,
    fieldSelectionSet: fieldSelectionSet,
    filterParams: filterParams
  }),
      _translateNestedOrder2 = (0, _slicedToArray2["default"])(_translateNestedOrder, 2),
      lhsOrdering = _translateNestedOrder2[0],
      rhsOrdering = _translateNestedOrder2[1];

  var whereClauses = [labelPredicate].concat((0, _toConsumableArray2["default"])(neo4jTypeClauses), (0, _toConsumableArray2["default"])(arrayPredicates), (0, _toConsumableArray2["default"])(filterPredicates)).filter(function (predicate) {
    return !!predicate;
  });
  tailParams.initial = "".concat(initial).concat(fieldName, ": ").concat(!(0, _utils.isArrayType)(fieldType) ? 'head(' : '').concat(lhsOrdering, "[(").concat((0, _utils.safeVar)(variableName), ")").concat(isUnionTypeField ? "--" : "".concat(relDirection === 'in' || relDirection === 'IN' ? '<' : '', "-[:").concat((0, _utils.safeLabel)([relType]), "]-").concat(relDirection === 'out' || relDirection === 'OUT' ? '>' : ''), "(").concat(safeVariableName, ":".concat((0, _utils.safeLabel)([innerSchemaType.name].concat((0, _toConsumableArray2["default"])((0, _utils.getAdditionalLabels)(resolveInfo.schema.getType(innerSchemaType.name), cypherParams)))))).concat(queryParams, ")").concat(whereClauses.length > 0 ? " WHERE ".concat(whereClauses.join(' AND ')) : '', " | ").concat(mapProjection, "]").concat(rhsOrdering).concat(!(0, _utils.isArrayType)(fieldType) ? ')' : '').concat(skipLimit, " ").concat(commaIfTail);
  return [tailParams, subSelection];
};

exports.relationFieldOnNodeType = relationFieldOnNodeType;

var relationTypeFieldOnNodeType = function relationTypeFieldOnNodeType(_ref4) {
  var innerSchemaTypeRelation = _ref4.innerSchemaTypeRelation,
      initial = _ref4.initial,
      fieldName = _ref4.fieldName,
      fieldSelectionSet = _ref4.fieldSelectionSet,
      subSelection = _ref4.subSelection,
      skipLimit = _ref4.skipLimit,
      commaIfTail = _ref4.commaIfTail,
      tailParams = _ref4.tailParams,
      fieldType = _ref4.fieldType,
      variableName = _ref4.variableName,
      fieldsForTranslation = _ref4.fieldsForTranslation,
      schemaType = _ref4.schemaType,
      innerSchemaType = _ref4.innerSchemaType,
      nestedVariable = _ref4.nestedVariable,
      filterParams = _ref4.filterParams,
      neo4jTypeArgs = _ref4.neo4jTypeArgs,
      resolveInfo = _ref4.resolveInfo,
      selectionFilters = _ref4.selectionFilters,
      paramIndex = _ref4.paramIndex,
      fieldArgs = _ref4.fieldArgs,
      cypherParams = _ref4.cypherParams;
  var translation = '';

  if (innerSchemaTypeRelation.from === innerSchemaTypeRelation.to) {
    translation = "".concat(initial).concat(fieldName, ": {").concat(subSelection[0], "}").concat(skipLimit, " ").concat(commaIfTail);
  } else {
    var relationshipVariableName = "".concat(nestedVariable, "_relation");
    var neo4jTypeClauses = (0, _utils.neo4jTypePredicateClauses)(filterParams, relationshipVariableName, neo4jTypeArgs);

    var _processFilterArgumen3 = processFilterArgument({
      fieldArgs: fieldArgs,
      parentSchemaType: schemaType,
      schemaType: innerSchemaType,
      variableName: relationshipVariableName,
      resolveInfo: resolveInfo,
      params: selectionFilters,
      paramIndex: paramIndex,
      rootIsRelationType: true
    }),
        _processFilterArgumen4 = (0, _slicedToArray2["default"])(_processFilterArgumen3, 2),
        filterPredicates = _processFilterArgumen4[0],
        serializedFilterParam = _processFilterArgumen4[1];

    var filterParamKey = "".concat(tailParams.paramIndex, "_filter");
    var fieldArgumentParams = subSelection[1];
    var filterParam = fieldArgumentParams[filterParamKey];

    if (filterParam && typeof serializedFilterParam[filterParamKey] !== 'undefined') {
      subSelection[1][filterParamKey] = serializedFilterParam[filterParamKey];
    }

    var allParams = (0, _utils.innerFilterParams)(filterParams, neo4jTypeArgs);
    var queryParams = (0, _utils.paramsToString)(_lodash["default"].filter(allParams, function (param) {
      var value = param.value.value !== undefined ? param.value.value : param.value;
      return !(0, _isArray["default"])(value);
    }));
    var arrayPredicates = translateListArguments({
      schemaType: innerSchemaType,
      fieldArgs: fieldArgs,
      filterParams: filterParams,
      safeVariableName: (0, _utils.safeVar)(relationshipVariableName),
      resolveInfo: resolveInfo
    });

    var _translateNestedOrder3 = translateNestedOrderingArgument({
      schemaType: innerSchemaType,
      selections: fieldsForTranslation,
      fieldSelectionSet: fieldSelectionSet,
      filterParams: filterParams
    }),
        _translateNestedOrder4 = (0, _slicedToArray2["default"])(_translateNestedOrder3, 2),
        lhsOrdering = _translateNestedOrder4[0],
        rhsOrdering = _translateNestedOrder4[1];

    var fromTypeName = innerSchemaTypeRelation.from;
    var toTypeName = innerSchemaTypeRelation.to;
    var schemaTypeName = schemaType.name;
    var isFromField = schemaTypeName === fromTypeName;
    var isToField = schemaTypeName === toTypeName;
    var incomingNodeTypeName = innerSchemaTypeRelation.from;
    var outgoingNodeTypeName = innerSchemaTypeRelation.to;
    var innerSchemaTypeFields = innerSchemaType.getFields();
    var selectsIncomingField = innerSchemaTypeFields[incomingNodeTypeName];
    var selectsOutgoingField = innerSchemaTypeFields[outgoingNodeTypeName];
    var nestedTypeLabels = selectsOutgoingField || isFromField ? [toTypeName].concat((0, _toConsumableArray2["default"])((0, _utils.getAdditionalLabels)(resolveInfo.schema.getType(toTypeName), cypherParams))) : [fromTypeName].concat((0, _toConsumableArray2["default"])((0, _utils.getAdditionalLabels)(resolveInfo.schema.getType(fromTypeName), cypherParams)));
    var whereClauses = [].concat((0, _toConsumableArray2["default"])(neo4jTypeClauses), (0, _toConsumableArray2["default"])(filterPredicates), (0, _toConsumableArray2["default"])(arrayPredicates));
    translation = "".concat(initial).concat(fieldName, ": ").concat(!(0, _utils.isArrayType)(fieldType) ? 'head(' : '').concat(lhsOrdering, "[(").concat((0, _utils.safeVar)(variableName), ")").concat( // if its fromField -- is this logically equivalent?
    selectsIncomingField || isToField ? '<' : '', "-[").concat((0, _utils.safeVar)(relationshipVariableName), ":").concat((0, _utils.safeLabel)(innerSchemaTypeRelation.name)).concat(queryParams, "]-").concat(selectsOutgoingField || isFromField ? '>' : '', "(:").concat((0, _utils.safeLabel)(nestedTypeLabels), ") ").concat(whereClauses.length > 0 ? "WHERE ".concat(whereClauses.join(' AND '), " ") : '', "| ").concat(relationshipVariableName, " {").concat(subSelection[0], "}]").concat(rhsOrdering).concat(!(0, _utils.isArrayType)(fieldType) ? ')' : '').concat(skipLimit, " ").concat(commaIfTail);
  }

  tailParams.initial = translation;
  return [tailParams, subSelection];
};

exports.relationTypeFieldOnNodeType = relationTypeFieldOnNodeType;

var nodeTypeFieldOnRelationType = function nodeTypeFieldOnRelationType(_ref5) {
  var initial = _ref5.initial,
      schemaType = _ref5.schemaType,
      fieldName = _ref5.fieldName,
      fieldType = _ref5.fieldType,
      variableName = _ref5.variableName,
      nestedVariable = _ref5.nestedVariable,
      subSelection = _ref5.subSelection,
      skipLimit = _ref5.skipLimit,
      commaIfTail = _ref5.commaIfTail,
      tailParams = _ref5.tailParams,
      filterParams = _ref5.filterParams,
      neo4jTypeArgs = _ref5.neo4jTypeArgs,
      schemaTypeRelation = _ref5.schemaTypeRelation,
      innerSchemaType = _ref5.innerSchemaType,
      fieldSelectionSet = _ref5.fieldSelectionSet,
      fieldsForTranslation = _ref5.fieldsForTranslation,
      schemaTypeFields = _ref5.schemaTypeFields,
      derivedTypeMap = _ref5.derivedTypeMap,
      isObjectTypeField = _ref5.isObjectTypeField,
      isInterfaceTypeField = _ref5.isInterfaceTypeField,
      isUnionTypeField = _ref5.isUnionTypeField,
      usesFragments = _ref5.usesFragments,
      paramIndex = _ref5.paramIndex,
      parentSelectionInfo = _ref5.parentSelectionInfo,
      resolveInfo = _ref5.resolveInfo,
      selectionFilters = _ref5.selectionFilters,
      fieldArgs = _ref5.fieldArgs,
      cypherParams = _ref5.cypherParams;

  if ((0, _query.isRelationshipMutationOutputType)({
    schemaType: schemaType
  })) {
    var fromArgName = parentSelectionInfo.fromArgName;
    var toArgName = parentSelectionInfo.toArgName;
    var nodeFieldVariableName = decideRootRelationshipTypeNodeVariable({
      parentSelectionInfo: parentSelectionInfo,
      fieldName: fieldName,
      fromArgName: fromArgName,
      toArgName: toArgName
    });

    var _buildMapProjection5 = buildMapProjection({
      schemaType: innerSchemaType,
      isObjectType: isObjectTypeField,
      isInterfaceType: isInterfaceTypeField,
      isUnionType: isUnionTypeField,
      safeVariableName: nodeFieldVariableName,
      subQuery: subSelection[0],
      usesFragments: usesFragments,
      schemaTypeFields: schemaTypeFields,
      derivedTypeMap: derivedTypeMap,
      resolveInfo: resolveInfo
    }),
        _buildMapProjection6 = (0, _slicedToArray2["default"])(_buildMapProjection5, 2),
        mapProjection = _buildMapProjection6[0],
        labelPredicate = _buildMapProjection6[1];

    var translationParams = relationTypeMutationPayloadField({
      initial: initial,
      fieldName: fieldName,
      mapProjection: mapProjection,
      skipLimit: skipLimit,
      commaIfTail: commaIfTail,
      tailParams: tailParams
    });
    return [translationParams, subSelection];
  } // Normal case of schemaType with a relationship directive


  return directedNodeTypeFieldOnRelationType({
    initial: initial,
    schemaType: schemaType,
    fieldName: fieldName,
    fieldType: fieldType,
    variableName: variableName,
    nestedVariable: nestedVariable,
    subSelection: subSelection,
    skipLimit: skipLimit,
    commaIfTail: commaIfTail,
    tailParams: tailParams,
    schemaTypeRelation: schemaTypeRelation,
    innerSchemaType: innerSchemaType,
    fieldSelectionSet: fieldSelectionSet,
    fieldsForTranslation: fieldsForTranslation,
    usesFragments: usesFragments,
    isObjectTypeField: isObjectTypeField,
    isInterfaceTypeField: isInterfaceTypeField,
    isUnionTypeField: isUnionTypeField,
    filterParams: filterParams,
    neo4jTypeArgs: neo4jTypeArgs,
    paramIndex: paramIndex,
    resolveInfo: resolveInfo,
    selectionFilters: selectionFilters,
    schemaTypeFields: schemaTypeFields,
    derivedTypeMap: derivedTypeMap,
    fieldArgs: fieldArgs,
    cypherParams: cypherParams,
    parentSelectionInfo: parentSelectionInfo
  });
};

exports.nodeTypeFieldOnRelationType = nodeTypeFieldOnRelationType;

var decideRootRelationshipTypeNodeVariable = function decideRootRelationshipTypeNodeVariable(_ref6) {
  var _ref6$parentSelection = _ref6.parentSelectionInfo,
      parentSelectionInfo = _ref6$parentSelection === void 0 ? {} : _ref6$parentSelection,
      _ref6$fieldName = _ref6.fieldName,
      fieldName = _ref6$fieldName === void 0 ? '' : _ref6$fieldName,
      _ref6$fromArgName = _ref6.fromArgName,
      fromArgName = _ref6$fromArgName === void 0 ? '' : _ref6$fromArgName,
      _ref6$toArgName = _ref6.toArgName,
      toArgName = _ref6$toArgName === void 0 ? '' : _ref6$toArgName;
  var fromVariable = parentSelectionInfo.from || parentSelectionInfo[fromArgName];
  var toVariable = parentSelectionInfo.to || parentSelectionInfo[toArgName]; // assume incoming

  var variableName = (0, _utils.safeVar)(fromVariable); // else set as outgoing

  if (fieldName === 'to' || fieldName === toArgName) variableName = (0, _utils.safeVar)(toVariable);
  return variableName;
};

var relationTypeMutationPayloadField = function relationTypeMutationPayloadField(_ref7) {
  var initial = _ref7.initial,
      fieldName = _ref7.fieldName,
      mapProjection = _ref7.mapProjection,
      skipLimit = _ref7.skipLimit,
      commaIfTail = _ref7.commaIfTail,
      tailParams = _ref7.tailParams;
  var translation = "".concat(initial).concat(fieldName, ": ").concat(mapProjection).concat(skipLimit, " ").concat(commaIfTail);
  return _objectSpread({
    initial: translation
  }, tailParams);
};

var directedNodeTypeFieldOnRelationType = function directedNodeTypeFieldOnRelationType(_ref8) {
  var initial = _ref8.initial,
      schemaType = _ref8.schemaType,
      fieldName = _ref8.fieldName,
      fieldType = _ref8.fieldType,
      variableName = _ref8.variableName,
      nestedVariable = _ref8.nestedVariable,
      subSelection = _ref8.subSelection,
      skipLimit = _ref8.skipLimit,
      commaIfTail = _ref8.commaIfTail,
      tailParams = _ref8.tailParams,
      schemaTypeRelation = _ref8.schemaTypeRelation,
      innerSchemaType = _ref8.innerSchemaType,
      fieldSelectionSet = _ref8.fieldSelectionSet,
      fieldsForTranslation = _ref8.fieldsForTranslation,
      usesFragments = _ref8.usesFragments,
      isObjectTypeField = _ref8.isObjectTypeField,
      isInterfaceTypeField = _ref8.isInterfaceTypeField,
      isUnionTypeField = _ref8.isUnionTypeField,
      filterParams = _ref8.filterParams,
      neo4jTypeArgs = _ref8.neo4jTypeArgs,
      paramIndex = _ref8.paramIndex,
      resolveInfo = _ref8.resolveInfo,
      selectionFilters = _ref8.selectionFilters,
      schemaTypeFields = _ref8.schemaTypeFields,
      derivedTypeMap = _ref8.derivedTypeMap,
      fieldArgs = _ref8.fieldArgs,
      cypherParams = _ref8.cypherParams,
      parentSelectionInfo = _ref8.parentSelectionInfo;
  var relType = schemaTypeRelation.name;
  var fromTypeName = schemaTypeRelation.from;
  var toTypeName = schemaTypeRelation.to;
  var parentSchemaTypeName = parentSelectionInfo.schemaType.name;
  var innerSchemaTypeName = innerSchemaType.name;
  var isFromField = innerSchemaTypeName === fromTypeName || fieldName === 'from';
  var isToField = innerSchemaTypeName === toTypeName || fieldName === 'to';
  var safeVariableName = nestedVariable;

  var _buildMapProjection7 = buildMapProjection({
    schemaType: innerSchemaType,
    isObjectType: isObjectTypeField,
    isInterfaceType: isInterfaceTypeField,
    isUnionType: isUnionTypeField,
    usesFragments: usesFragments,
    safeVariableName: safeVariableName,
    subQuery: subSelection[0],
    schemaTypeFields: schemaTypeFields,
    derivedTypeMap: derivedTypeMap,
    resolveInfo: resolveInfo
  }),
      _buildMapProjection8 = (0, _slicedToArray2["default"])(_buildMapProjection7, 2),
      mapProjection = _buildMapProjection8[0],
      labelPredicate = _buildMapProjection8[1];

  var allParams = (0, _utils.innerFilterParams)(filterParams, neo4jTypeArgs);
  var queryParams = (0, _utils.paramsToString)(_lodash["default"].filter(allParams, function (param) {
    var value = param.value.value !== undefined ? param.value.value : param.value;
    return !(0, _isArray["default"])(value);
  })); // Since the translations are significantly different,
  // we first check whether the relationship is reflexive

  if (fromTypeName === toTypeName) {
    var relationshipVariableName = "".concat(variableName, "_").concat(isFromField ? 'from' : 'to', "_relation");

    if ((0, _query.isReflexiveRelationshipOutputType)({
      schemaType: schemaType
    })) {
      isFromField = schemaType.astNode.fields[0].name.value === fieldName;
      isToField = schemaType.astNode.fields[1].name.value === fieldName;
      var temporalFieldRelationshipVariableName = "".concat(nestedVariable, "_relation");
      var neo4jTypeClauses = (0, _utils.neo4jTypePredicateClauses)(filterParams, temporalFieldRelationshipVariableName, neo4jTypeArgs);

      var _processFilterArgumen5 = processFilterArgument({
        fieldArgs: fieldArgs,
        schemaType: innerSchemaType,
        variableName: relationshipVariableName,
        resolveInfo: resolveInfo,
        params: selectionFilters,
        paramIndex: paramIndex,
        rootIsRelationType: true
      }),
          _processFilterArgumen6 = (0, _slicedToArray2["default"])(_processFilterArgumen5, 2),
          filterPredicates = _processFilterArgumen6[0],
          serializedFilterParam = _processFilterArgumen6[1];

      var filterParamKey = "".concat(tailParams.paramIndex, "_filter");
      var fieldArgumentParams = subSelection[1];
      var filterParam = fieldArgumentParams[filterParamKey];

      if (filterParam && typeof serializedFilterParam[filterParamKey] !== 'undefined') {
        subSelection[1][filterParamKey] = serializedFilterParam[filterParamKey];
      }

      var arrayPredicates = translateListArguments({
        schemaType: innerSchemaType,
        fieldArgs: fieldArgs,
        filterParams: filterParams,
        safeVariableName: (0, _utils.safeVar)(relationshipVariableName),
        resolveInfo: resolveInfo
      });

      var _translateNestedOrder5 = translateNestedOrderingArgument({
        schemaType: innerSchemaType,
        selections: fieldsForTranslation,
        fieldSelectionSet: fieldSelectionSet,
        filterParams: filterParams
      }),
          _translateNestedOrder6 = (0, _slicedToArray2["default"])(_translateNestedOrder5, 2),
          lhsOrdering = _translateNestedOrder6[0],
          rhsOrdering = _translateNestedOrder6[1];

      var whereClauses = [].concat((0, _toConsumableArray2["default"])(neo4jTypeClauses), (0, _toConsumableArray2["default"])(filterPredicates), (0, _toConsumableArray2["default"])(arrayPredicates));
      tailParams.initial = "".concat(initial).concat(fieldName, ": ").concat(!(0, _utils.isArrayType)(fieldType) ? 'head(' : '').concat(lhsOrdering, "[(").concat((0, _utils.safeVar)(variableName), ")").concat(isFromField ? '<' : '', "-[").concat((0, _utils.safeVar)(relationshipVariableName), ":").concat((0, _utils.safeLabel)(relType)).concat(queryParams, "]-").concat(isToField ? '>' : '', "(").concat((0, _utils.safeVar)(nestedVariable), ":").concat((0, _utils.safeLabel)([parentSchemaTypeName].concat((0, _toConsumableArray2["default"])((0, _utils.getAdditionalLabels)(resolveInfo.schema.getType(parentSchemaTypeName), cypherParams)))), ") ").concat(whereClauses.length > 0 ? "WHERE ".concat(whereClauses.join(' AND '), " ") : '', "| ").concat(relationshipVariableName, " {").concat(subSelection[0], "}]").concat(rhsOrdering).concat(!(0, _utils.isArrayType)(fieldType) ? ')' : '').concat(skipLimit, " ").concat(commaIfTail);
      return [tailParams, subSelection];
    } else {
      // Case of a renamed directed field
      // e.g., 'from: Movie' -> 'Movie: Movie'
      tailParams.initial = "".concat(initial).concat(fieldName, ": ").concat(mapProjection).concat(skipLimit, " ").concat(commaIfTail);
      return [tailParams, subSelection];
    }
  } else {
    var _whereClauses = [labelPredicate].filter(function (predicate) {
      return !!predicate;
    });

    var safeRelationshipVar = (0, _utils.safeVar)("".concat(variableName, "_relation"));
    tailParams.initial = "".concat(initial).concat(fieldName, ": ").concat(!(0, _utils.isArrayType)(fieldType) ? 'head(' : '', "[(:").concat((0, _utils.safeLabel)(isFromField ? [toTypeName].concat((0, _toConsumableArray2["default"])((0, _utils.getAdditionalLabels)(resolveInfo.schema.getType(toTypeName), cypherParams))) : [fromTypeName].concat((0, _toConsumableArray2["default"])((0, _utils.getAdditionalLabels)(resolveInfo.schema.getType(fromTypeName), cypherParams)))), ")").concat(isUnionTypeField ? "--" : "".concat(isFromField ? '<' : '', "-[").concat(safeRelationshipVar, "]-").concat(isToField ? '>' : ''), "(").concat((0, _utils.safeVar)(nestedVariable), ":").concat((0, _utils.safeLabel)([innerSchemaType.name].concat((0, _toConsumableArray2["default"])((0, _utils.getAdditionalLabels)(resolveInfo.schema.getType(innerSchemaType.name), cypherParams))))).concat(queryParams, ")").concat(_whereClauses.length > 0 ? " WHERE ".concat(_whereClauses.join(' AND ')) : '', " | ").concat(mapProjection, "]").concat(!(0, _utils.isArrayType)(fieldType) ? ')' : '').concat(skipLimit, " ").concat(commaIfTail);
    return [tailParams, subSelection];
  }
};

var neo4jTypeField = function neo4jTypeField(_ref9) {
  var initial = _ref9.initial,
      fieldName = _ref9.fieldName,
      commaIfTail = _ref9.commaIfTail,
      tailParams = _ref9.tailParams,
      parentSelectionInfo = _ref9.parentSelectionInfo,
      secondParentSelectionInfo = _ref9.secondParentSelectionInfo;
  var parentFieldName = parentSelectionInfo.fieldName;
  var parentFieldType = parentSelectionInfo.fieldType;
  var parentSchemaType = parentSelectionInfo.schemaType;
  var parentVariableName = parentSelectionInfo.variableName;
  var secondParentVariableName = secondParentSelectionInfo.variableName; // Initially assume that the parent type of the temporal type
  // containing this temporal field was a node

  var variableName = parentVariableName;
  var fieldIsArray = (0, _utils.isArrayType)(parentFieldType);

  if (parentSchemaType && !(0, _utils.isNodeType)(parentSchemaType.astNode)) {
    // initial assumption wrong, build appropriate relationship variable
    if ((0, _query.isRelationshipMutationOutputType)({
      schemaType: parentSchemaType
    })) {
      // If the second parent selection scope above is the root
      // then we need to use the root variableName
      variableName = "".concat(secondParentVariableName, "_relation");
    } else if ((0, _utils.isRelationTypePayload)(parentSchemaType)) {
      var parentSchemaTypeRelation = (0, _utils.getRelationTypeDirective)(parentSchemaType.astNode);

      if (parentSchemaTypeRelation.from === parentSchemaTypeRelation.to) {
        variableName = "".concat(variableName, "_relation");
      } else {
        variableName = "".concat(variableName, "_relation");
      }
    }
  }

  return _objectSpread({
    initial: "".concat(initial, " ").concat(fieldName, ": ").concat(fieldIsArray ? "".concat(fieldName === 'formatted' ? "toString(INSTANCE)" : "INSTANCE.".concat(fieldName), " ").concat(commaIfTail) : "".concat(fieldName === 'formatted' ? "toString(".concat((0, _utils.safeVar)(variableName), ".").concat(parentFieldName, ") ").concat(commaIfTail) : "".concat((0, _utils.safeVar)(variableName), ".").concat(parentFieldName, ".").concat(fieldName, " ").concat(commaIfTail)))
  }, tailParams);
};

exports.neo4jTypeField = neo4jTypeField;

var neo4jType = function neo4jType(_ref10) {
  var initial = _ref10.initial,
      fieldName = _ref10.fieldName,
      subSelection = _ref10.subSelection,
      commaIfTail = _ref10.commaIfTail,
      tailParams = _ref10.tailParams,
      variableName = _ref10.variableName,
      nestedVariable = _ref10.nestedVariable,
      fieldType = _ref10.fieldType,
      schemaType = _ref10.schemaType,
      schemaTypeRelation = _ref10.schemaTypeRelation,
      parentSelectionInfo = _ref10.parentSelectionInfo;
  var parentVariableName = parentSelectionInfo.variableName;
  var parentFilterParams = parentSelectionInfo.filterParams;
  var parentSchemaType = parentSelectionInfo.schemaType;
  var relationshipVariableSuffix = "relation";
  var fieldIsArray = (0, _utils.isArrayType)(fieldType);
  var isOrderedForNodeType = temporalOrderingFieldExists(parentSchemaType, parentFilterParams);
  var isOrderedForRelationshipType = temporalOrderingFieldExists(schemaType, parentFilterParams);

  if (!(0, _utils.isNodeType)(schemaType.astNode)) {
    if ((0, _utils.isRelationTypePayload)(schemaType) && schemaTypeRelation.from === schemaTypeRelation.to) {
      variableName = "".concat(nestedVariable, "_").concat(relationshipVariableSuffix);
    } else {
      if (fieldIsArray) {
        if ((0, _query.isRelationshipMutationOutputType)({
          schemaType: schemaType
        })) {
          variableName = "".concat(parentVariableName, "_").concat(relationshipVariableSuffix);
        } else {
          variableName = "".concat(variableName, "_").concat(relationshipVariableSuffix);
        }
      } else {
        if (isOrderedForRelationshipType) {
          variableName = "".concat(variableName, "_").concat(relationshipVariableSuffix);
        } else {
          variableName = "".concat(nestedVariable, "_").concat(relationshipVariableSuffix);
        }
      }
    }
  }

  var safeVariableName = (0, _utils.safeVar)(variableName);
  var usesTemporalOrdering = isOrderedForNodeType || isOrderedForRelationshipType;
  return _objectSpread({
    initial: "".concat(initial).concat(fieldName, ": ").concat(fieldIsArray ? "reduce(a = [], INSTANCE IN ".concat(variableName, ".").concat(fieldName, " | a + {").concat(subSelection[0], "})").concat(commaIfTail) : usesTemporalOrdering ? "".concat(safeVariableName, ".").concat(fieldName).concat(commaIfTail) : "{".concat(subSelection[0], "}").concat(commaIfTail))
  }, tailParams);
}; // Query API root operation branch


exports.neo4jType = neo4jType;

var translateQuery = function translateQuery(_ref11) {
  var resolveInfo = _ref11.resolveInfo,
      context = _ref11.context,
      first = _ref11.first,
      offset = _ref11.offset,
      _id = _ref11._id,
      orderBy = _ref11.orderBy,
      otherParams = _ref11.otherParams;

  var _typeIdentifiers = (0, _utils.typeIdentifiers)(resolveInfo.returnType),
      typeName = _typeIdentifiers.typeName,
      variableName = _typeIdentifiers.variableName;

  var schemaType = resolveInfo.schema.getType(typeName);
  var typeMap = resolveInfo.schema.getTypeMap();
  var selections = (0, _utils.getPayloadSelections)(resolveInfo);
  var isInterfaceType = (0, _utils.isGraphqlInterfaceType)(schemaType);
  var isUnionType = (0, _utils.isGraphqlUnionType)(schemaType);
  var isObjectType = (0, _utils.isGraphqlObjectType)(schemaType);

  var _filterNullParams = (0, _utils.filterNullParams)({
    offset: offset,
    first: first,
    otherParams: otherParams
  }),
      _filterNullParams2 = (0, _slicedToArray2["default"])(_filterNullParams, 2),
      nullParams = _filterNullParams2[0],
      nonNullParams = _filterNullParams2[1]; // Check is this is a federated operation, in which case get the lookup keys


  var operation = resolveInfo.operation || {}; // check if the operation name is the name used for generated queries

  var isFederatedOperation = operation.name && operation.name.value === _federation.NEO4j_GRAPHQL_SERVICE;
  var queryTypeCypherDirective = (0, _utils.getQueryCypherDirective)(resolveInfo, isFederatedOperation);
  var scalarKeys = {};
  var compoundKeys = {};
  var requiredData = {};

  if (isFederatedOperation) {
    var operationData = (0, _federation.getFederatedOperationData)({
      context: context
    });
    scalarKeys = operationData.scalarKeys;
    compoundKeys = operationData.compoundKeys;
    requiredData = operationData.requiredData;

    if (queryTypeCypherDirective) {
      // all nonnull keys become available as cypher variables
      nonNullParams = _objectSpread({}, scalarKeys, {}, compoundKeys, {}, requiredData);
    } else {
      // all scalar keys get used as field arguments, while relationship
      // field keys being translated as a filter argument
      nonNullParams = _objectSpread({}, scalarKeys);
    }
  }

  var filterParams = (0, _utils.getFilterParams)(nonNullParams);
  var queryArgs = (0, _utils.getQueryArguments)(resolveInfo, isFederatedOperation);
  var neo4jTypeArgs = (0, _utils.getNeo4jTypeArguments)(queryArgs);
  var cypherParams = getCypherParams(context);
  var queryParams = (0, _utils.paramsToString)((0, _utils.innerFilterParams)(filterParams, neo4jTypeArgs, null, queryTypeCypherDirective ? true : false), cypherParams);
  var safeVariableName = (0, _utils.safeVar)(variableName);
  var neo4jTypeClauses = (0, _utils.neo4jTypePredicateClauses)(filterParams, safeVariableName, neo4jTypeArgs);
  var outerSkipLimit = (0, _utils.getOuterSkipLimit)(first, offset);
  var orderByValue = (0, _utils.computeOrderBy)(resolveInfo, schemaType);
  var usesFragments = (0, _selections.isFragmentedSelection)({
    selections: selections
  });
  var isFragmentedInterfaceType = usesFragments && isInterfaceType;
  var isFragmentedObjectType = usesFragments && isObjectType;

  var _mergeSelectionFragme = (0, _selections.mergeSelectionFragments)({
    schemaType: schemaType,
    selections: selections,
    isFragmentedObjectType: isFragmentedObjectType,
    isFragmentedInterfaceType: isFragmentedInterfaceType,
    isUnionType: isUnionType,
    typeMap: typeMap,
    resolveInfo: resolveInfo
  }),
      _mergeSelectionFragme2 = (0, _slicedToArray2["default"])(_mergeSelectionFragme, 2),
      schemaTypeFields = _mergeSelectionFragme2[0],
      derivedTypeMap = _mergeSelectionFragme2[1];

  var hasOnlySchemaTypeFragments = schemaTypeFields.length > 0 && (0, _keys["default"])(derivedTypeMap).length === 0;

  if (hasOnlySchemaTypeFragments) {
    usesFragments = false;
  }

  var translation = "";
  var translationParams = {};

  if (queryTypeCypherDirective) {
    var _customQuery = customQuery({
      resolveInfo: resolveInfo,
      cypherParams: cypherParams,
      schemaType: schemaType,
      argString: queryParams,
      selections: selections,
      variableName: variableName,
      safeVariableName: safeVariableName,
      isObjectType: isObjectType,
      isInterfaceType: isInterfaceType,
      isUnionType: isUnionType,
      isFragmentedInterfaceType: isFragmentedInterfaceType,
      usesFragments: usesFragments,
      schemaTypeFields: schemaTypeFields,
      derivedTypeMap: derivedTypeMap,
      orderByValue: orderByValue,
      outerSkipLimit: outerSkipLimit,
      queryTypeCypherDirective: queryTypeCypherDirective,
      nonNullParams: nonNullParams
    });

    var _customQuery2 = (0, _slicedToArray2["default"])(_customQuery, 2);

    translation = _customQuery2[0];
    translationParams = _customQuery2[1];
  } else {
    var additionalLabels = (0, _utils.getAdditionalLabels)(schemaType, cypherParams);

    if (isFederatedOperation) {
      nonNullParams = (0, _federation.setCompoundKeyFilter)({
        params: nonNullParams,
        compoundKeys: compoundKeys
      });
      nonNullParams = _objectSpread({}, nonNullParams, {}, otherParams, {}, requiredData);
    }

    var _nodeQuery = nodeQuery({
      resolveInfo: resolveInfo,
      isFederatedOperation: isFederatedOperation,
      context: context,
      cypherParams: cypherParams,
      schemaType: schemaType,
      argString: queryParams,
      selections: selections,
      variableName: variableName,
      typeName: typeName,
      isObjectType: isObjectType,
      isInterfaceType: isInterfaceType,
      isUnionType: isUnionType,
      isFragmentedInterfaceType: isFragmentedInterfaceType,
      isFragmentedObjectType: isFragmentedObjectType,
      usesFragments: usesFragments,
      schemaTypeFields: schemaTypeFields,
      derivedTypeMap: derivedTypeMap,
      additionalLabels: additionalLabels,
      neo4jTypeClauses: neo4jTypeClauses,
      orderByValue: orderByValue,
      outerSkipLimit: outerSkipLimit,
      nullParams: nullParams,
      nonNullParams: nonNullParams,
      filterParams: filterParams,
      neo4jTypeArgs: neo4jTypeArgs,
      _id: _id
    });

    var _nodeQuery2 = (0, _slicedToArray2["default"])(_nodeQuery, 2);

    translation = _nodeQuery2[0];
    translationParams = _nodeQuery2[1];
  }

  return [translation, translationParams];
};

exports.translateQuery = translateQuery;

var buildTypeCompositionPredicate = function buildTypeCompositionPredicate(_ref12) {
  var schemaType = _ref12.schemaType,
      schemaTypeFields = _ref12.schemaTypeFields,
      _ref12$listVariable = _ref12.listVariable,
      listVariable = _ref12$listVariable === void 0 ? 'x' : _ref12$listVariable,
      derivedTypeMap = _ref12.derivedTypeMap,
      safeVariableName = _ref12.safeVariableName,
      isInterfaceType = _ref12.isInterfaceType,
      isUnionType = _ref12.isUnionType,
      isComputedQuery = _ref12.isComputedQuery,
      isComputedMutation = _ref12.isComputedMutation,
      isComputedField = _ref12.isComputedField,
      usesFragments = _ref12.usesFragments,
      resolveInfo = _ref12.resolveInfo;
  var schemaTypeName = schemaType.name;
  var isFragmentedInterfaceType = usesFragments && isInterfaceType;
  var labelPredicate = '';

  if (isFragmentedInterfaceType || isUnionType) {
    var derivedTypes = []; // If shared fields are selected then the translation builds
    // a type specific list comprehension for each interface implementing
    // type. Because of this, the type selecting predicate applied to
    // the interface type path pattern should allow for all possible
    // implementing types

    if (schemaTypeFields.length) {
      derivedTypes = (0, _selections.getDerivedTypes)({
        schemaTypeName: schemaTypeName,
        derivedTypeMap: derivedTypeMap,
        isUnionType: isUnionType,
        isFragmentedInterfaceType: isFragmentedInterfaceType,
        resolveInfo: resolveInfo
      });
    } else if (isUnionType) {
      derivedTypes = (0, _selections.getUnionDerivedTypes)({
        derivedTypeMap: derivedTypeMap,
        resolveInfo: resolveInfo
      });
    } else {
      // Otherwise, use only those types provided in fragments
      derivedTypes = (0, _keys["default"])(derivedTypeMap);
    }

    var typeSelectionPredicates = derivedTypes.map(function (selectedType) {
      return "\"".concat(selectedType, "\" IN labels(").concat(safeVariableName, ")");
    });

    if (typeSelectionPredicates.length) {
      labelPredicate = "(".concat(typeSelectionPredicates.join(' OR '), ")");
    }
  }

  if (labelPredicate) {
    if (isComputedQuery) {
      labelPredicate = "WITH [".concat(safeVariableName, " IN ").concat(listVariable, " WHERE ").concat(labelPredicate, " | ").concat(safeVariableName, "] AS ").concat(listVariable, " ");
    } else if (isComputedMutation) {
      labelPredicate = "UNWIND [".concat(safeVariableName, " IN ").concat(listVariable, " WHERE ").concat(labelPredicate, " | ").concat(safeVariableName, "] ");
    } else if (isComputedField) {
      labelPredicate = "WHERE ".concat(labelPredicate, " ");
    }
  }

  return labelPredicate;
};

var getCypherParams = function getCypherParams(context) {
  return context && context.cypherParams && context.cypherParams instanceof Object && (0, _keys["default"])(context.cypherParams).length > 0 ? context.cypherParams : undefined;
}; // Custom read operation


var customQuery = function customQuery(_ref13) {
  var resolveInfo = _ref13.resolveInfo,
      cypherParams = _ref13.cypherParams,
      schemaType = _ref13.schemaType,
      argString = _ref13.argString,
      selections = _ref13.selections,
      variableName = _ref13.variableName,
      isObjectType = _ref13.isObjectType,
      isInterfaceType = _ref13.isInterfaceType,
      isUnionType = _ref13.isUnionType,
      usesFragments = _ref13.usesFragments,
      schemaTypeFields = _ref13.schemaTypeFields,
      derivedTypeMap = _ref13.derivedTypeMap,
      orderByValue = _ref13.orderByValue,
      outerSkipLimit = _ref13.outerSkipLimit,
      queryTypeCypherDirective = _ref13.queryTypeCypherDirective,
      nonNullParams = _ref13.nonNullParams;
  var safeVariableName = (0, _utils.safeVar)(variableName);

  var _buildCypherSelection = (0, _selections.buildCypherSelection)({
    cypherParams: cypherParams,
    selections: selections,
    variableName: variableName,
    schemaType: schemaType,
    resolveInfo: resolveInfo
  }),
      _buildCypherSelection2 = (0, _slicedToArray2["default"])(_buildCypherSelection, 2),
      subQuery = _buildCypherSelection2[0],
      subParams = _buildCypherSelection2[1];

  var params = _objectSpread({}, nonNullParams, {}, subParams);

  if (cypherParams) {
    params['cypherParams'] = cypherParams;
  } // QueryType with a @cypher directive


  var cypherQueryArg = queryTypeCypherDirective.arguments.find(function (x) {
    return x.name.value === 'statement';
  });
  var isScalarType = (0, _utils.isGraphqlScalarType)(schemaType);
  var isNeo4jTypeOutput = (0, _utils.isNeo4jType)(schemaType.name);
  var orderByClause = orderByValue.cypherPart; // Don't add subQuery for scalar type payloads

  var isScalarPayload = isNeo4jTypeOutput || isScalarType;
  var fragmentTypeParams = derivedTypesParams({
    isInterfaceType: isInterfaceType,
    isUnionType: isUnionType,
    schema: resolveInfo.schema,
    schemaTypeName: schemaType.name,
    usesFragments: usesFragments
  });

  var _buildMapProjection9 = buildMapProjection({
    isComputedQuery: true,
    schemaType: schemaType,
    schemaTypeFields: schemaTypeFields,
    derivedTypeMap: derivedTypeMap,
    isObjectType: isObjectType,
    isInterfaceType: isInterfaceType,
    isUnionType: isUnionType,
    isScalarPayload: isScalarPayload,
    usesFragments: usesFragments,
    safeVariableName: safeVariableName,
    subQuery: subQuery,
    resolveInfo: resolveInfo
  }),
      _buildMapProjection10 = (0, _slicedToArray2["default"])(_buildMapProjection9, 2),
      mapProjection = _buildMapProjection10[0],
      labelPredicate = _buildMapProjection10[1];

  var query = "WITH apoc.cypher.runFirstColumn(\"".concat(cypherQueryArg.value.value, "\", ").concat(argString || 'null', ", True) AS x ").concat(labelPredicate, "UNWIND x AS ").concat(safeVariableName, " RETURN ").concat(isScalarPayload ? "".concat(mapProjection, " ") : "".concat(mapProjection, " AS ").concat(safeVariableName).concat(orderByClause)).concat(outerSkipLimit);
  return [query, _objectSpread({}, params, {}, fragmentTypeParams)];
}; // Generated API


var nodeQuery = function nodeQuery(_ref14) {
  var resolveInfo = _ref14.resolveInfo,
      isFederatedOperation = _ref14.isFederatedOperation,
      context = _ref14.context,
      cypherParams = _ref14.cypherParams,
      schemaType = _ref14.schemaType,
      selections = _ref14.selections,
      variableName = _ref14.variableName,
      typeName = _ref14.typeName,
      isObjectType = _ref14.isObjectType,
      isInterfaceType = _ref14.isInterfaceType,
      isUnionType = _ref14.isUnionType,
      usesFragments = _ref14.usesFragments,
      schemaTypeFields = _ref14.schemaTypeFields,
      derivedTypeMap = _ref14.derivedTypeMap,
      _ref14$additionalLabe = _ref14.additionalLabels,
      additionalLabels = _ref14$additionalLabe === void 0 ? [] : _ref14$additionalLabe,
      neo4jTypeClauses = _ref14.neo4jTypeClauses,
      orderByValue = _ref14.orderByValue,
      outerSkipLimit = _ref14.outerSkipLimit,
      nullParams = _ref14.nullParams,
      nonNullParams = _ref14.nonNullParams,
      filterParams = _ref14.filterParams,
      neo4jTypeArgs = _ref14.neo4jTypeArgs,
      _id = _ref14._id;
  var safeVariableName = (0, _utils.safeVar)(variableName);
  var safeLabelName = (0, _utils.safeLabel)([typeName].concat((0, _toConsumableArray2["default"])(additionalLabels)));
  var rootParamIndex = 1;

  var _buildCypherSelection3 = (0, _selections.buildCypherSelection)({
    cypherParams: cypherParams,
    selections: selections,
    variableName: variableName,
    schemaType: schemaType,
    resolveInfo: resolveInfo,
    paramIndex: rootParamIndex,
    isFederatedOperation: isFederatedOperation,
    context: context
  }),
      _buildCypherSelection4 = (0, _slicedToArray2["default"])(_buildCypherSelection3, 2),
      subQuery = _buildCypherSelection4[0],
      subParams = _buildCypherSelection4[1];

  var _buildMapProjection11 = buildMapProjection({
    schemaType: schemaType,
    schemaTypeFields: schemaTypeFields,
    derivedTypeMap: derivedTypeMap,
    isObjectType: isObjectType,
    isInterfaceType: isInterfaceType,
    isUnionType: isUnionType,
    usesFragments: usesFragments,
    safeVariableName: safeVariableName,
    subQuery: subQuery,
    resolveInfo: resolveInfo
  }),
      _buildMapProjection12 = (0, _slicedToArray2["default"])(_buildMapProjection11, 2),
      mapProjection = _buildMapProjection12[0],
      labelPredicate = _buildMapProjection12[1];

  var fieldArgs = (0, _utils.getQueryArguments)(resolveInfo, isFederatedOperation);

  var _processFilterArgumen7 = processFilterArgument({
    fieldArgs: fieldArgs,
    isFederatedOperation: isFederatedOperation,
    schemaType: schemaType,
    variableName: variableName,
    resolveInfo: resolveInfo,
    params: nonNullParams,
    paramIndex: rootParamIndex
  }),
      _processFilterArgumen8 = (0, _slicedToArray2["default"])(_processFilterArgumen7, 2),
      filterPredicates = _processFilterArgumen8[0],
      serializedFilter = _processFilterArgumen8[1];

  var params = _objectSpread({}, serializedFilter, {}, subParams);

  if (cypherParams) {
    params['cypherParams'] = cypherParams;
  }

  var args = (0, _utils.innerFilterParams)(filterParams, neo4jTypeArgs);
  var argString = (0, _utils.paramsToString)(_lodash["default"].filter(args, function (arg) {
    return !(0, _isArray["default"])(arg.value);
  }));
  var idWherePredicate = typeof _id !== 'undefined' ? "ID(".concat(safeVariableName, ")=").concat(_id) : '';
  var nullFieldPredicates = (0, _keys["default"])(nullParams).map(function (key) {
    return "".concat(variableName, ".").concat(key, " IS NULL");
  });
  var arrayPredicates = translateListArguments({
    schemaType: schemaType,
    fieldArgs: fieldArgs,
    filterParams: filterParams,
    safeVariableName: safeVariableName,
    resolveInfo: resolveInfo
  });
  var fragmentTypeParams = derivedTypesParams({
    isInterfaceType: isInterfaceType,
    isUnionType: isUnionType,
    schema: resolveInfo.schema,
    schemaTypeName: schemaType.name,
    usesFragments: usesFragments
  });
  var predicateClauses = [idWherePredicate, labelPredicate].concat((0, _toConsumableArray2["default"])(filterPredicates), (0, _toConsumableArray2["default"])(nullFieldPredicates), (0, _toConsumableArray2["default"])(neo4jTypeClauses), (0, _toConsumableArray2["default"])(arrayPredicates)).filter(function (predicate) {
    return !!predicate;
  }).join(' AND ');
  var predicate = predicateClauses ? "WHERE ".concat(predicateClauses, " ") : '';
  var optimization = orderByValue.optimization,
      orderByClause = orderByValue.cypherPart;
  var query = "MATCH (".concat(safeVariableName, ":").concat(safeLabelName).concat(argString ? " ".concat(argString) : '', ") ").concat(predicate).concat(optimization.earlyOrderBy ? "WITH ".concat(safeVariableName).concat(orderByClause) : '', "RETURN ").concat(mapProjection, " AS ").concat(safeVariableName).concat(optimization.earlyOrderBy ? '' : orderByClause).concat(outerSkipLimit);
  return [query, _objectSpread({}, params, {}, fragmentTypeParams)];
};

var buildMapProjection = function buildMapProjection(_ref15) {
  var schemaType = _ref15.schemaType,
      schemaTypeFields = _ref15.schemaTypeFields,
      listVariable = _ref15.listVariable,
      derivedTypeMap = _ref15.derivedTypeMap,
      isObjectType = _ref15.isObjectType,
      isInterfaceType = _ref15.isInterfaceType,
      isUnionType = _ref15.isUnionType,
      isScalarPayload = _ref15.isScalarPayload,
      isComputedQuery = _ref15.isComputedQuery,
      isComputedMutation = _ref15.isComputedMutation,
      isComputedField = _ref15.isComputedField,
      usesFragments = _ref15.usesFragments,
      safeVariableName = _ref15.safeVariableName,
      subQuery = _ref15.subQuery,
      resolveInfo = _ref15.resolveInfo;
  var labelPredicate = buildTypeCompositionPredicate({
    schemaType: schemaType,
    schemaTypeFields: schemaTypeFields,
    listVariable: listVariable,
    derivedTypeMap: derivedTypeMap,
    safeVariableName: safeVariableName,
    isInterfaceType: isInterfaceType,
    isUnionType: isUnionType,
    isComputedQuery: isComputedQuery,
    isComputedMutation: isComputedMutation,
    isComputedField: isComputedField,
    usesFragments: usesFragments,
    resolveInfo: resolveInfo
  });
  var isFragmentedInterfaceType = usesFragments && isInterfaceType;
  var isFragmentedUnionType = usesFragments && isUnionType;
  var mapProjection = '';

  if (isScalarPayload) {
    // A scalar type payload has no map projection
    mapProjection = safeVariableName;
  } else if (isObjectType) {
    mapProjection = "".concat(safeVariableName, " {").concat(subQuery, "}");
  } else if (isFragmentedInterfaceType || isFragmentedUnionType) {
    // An interface type possibly uses fragments and a
    // union type necessarily uses fragments
    mapProjection = subQuery;
  } else if (isInterfaceType || isUnionType) {
    // If no fragments are used, then this is an interface type
    // with only interface fields selected
    mapProjection = "".concat(safeVariableName, " {").concat(fragmentType(safeVariableName, schemaType.name)).concat(subQuery ? ",".concat(subQuery) : '', "}");
  }

  return [mapProjection, labelPredicate];
};

var getUnionLabels = function getUnionLabels(_ref16) {
  var _ref16$typeName = _ref16.typeName,
      typeName = _ref16$typeName === void 0 ? '' : _ref16$typeName,
      _ref16$typeMap = _ref16.typeMap,
      typeMap = _ref16$typeMap === void 0 ? {} : _ref16$typeMap;
  var unionLabels = [];
  (0, _keys["default"])(typeMap).map(function (key) {
    var definition = typeMap[key];
    var astNode = definition.astNode;

    if ((0, _types.isUnionTypeDefinition)({
      definition: astNode
    })) {
      var types = definition.getTypes();
      var unionTypeName = definition.name;

      if (types.find(function (type) {
        return type.name === typeName;
      })) {
        unionLabels.push(unionTypeName);
      }
    }
  });
  return unionLabels;
}; // Mutation API root operation branch


var translateMutation = function translateMutation(_ref17) {
  var resolveInfo = _ref17.resolveInfo,
      context = _ref17.context,
      first = _ref17.first,
      offset = _ref17.offset,
      otherParams = _ref17.otherParams;
  var typeMap = resolveInfo.schema.getTypeMap();

  var _typeIdentifiers2 = (0, _utils.typeIdentifiers)(resolveInfo.returnType),
      typeName = _typeIdentifiers2.typeName,
      variableName = _typeIdentifiers2.variableName;

  var schemaType = resolveInfo.schema.getType(typeName);
  var selections = (0, _utils.getPayloadSelections)(resolveInfo);
  var outerSkipLimit = (0, _utils.getOuterSkipLimit)(first, offset);
  var orderByValue = (0, _utils.computeOrderBy)(resolveInfo, schemaType);
  var additionalNodeLabels = (0, _utils.getAdditionalLabels)(schemaType, getCypherParams(context));
  var mutationTypeCypherDirective = (0, _utils.getMutationCypherDirective)(resolveInfo);
  var mutationMeta = resolveInfo.schema.getMutationType().getFields()[resolveInfo.fieldName].astNode.directives.find(function (x) {
    return x.name.value === 'MutationMeta';
  });
  var fieldArguments = (0, _utils.getMutationArguments)(resolveInfo);
  var serializedParams = (0, _inputValues.analyzeMutationArguments)({
    fieldArguments: fieldArguments,
    values: otherParams,
    resolveInfo: resolveInfo
  });
  var params = (0, _utils.initializeMutationParams)({
    mutationMeta: mutationMeta,
    resolveInfo: resolveInfo,
    mutationTypeCypherDirective: mutationTypeCypherDirective,
    first: first,
    otherParams: serializedParams,
    offset: offset
  });
  var isInterfaceType = (0, _utils.isGraphqlInterfaceType)(schemaType);
  var isObjectType = (0, _utils.isGraphqlObjectType)(schemaType);
  var isUnionType = (0, _utils.isGraphqlUnionType)(schemaType);
  var usesFragments = (0, _selections.isFragmentedSelection)({
    selections: selections
  });
  var isFragmentedObjectType = usesFragments && isObjectType;
  var isFragmentedInterfaceType = usesFragments && isInterfaceType;
  var interfaceLabels = typeof schemaType.getInterfaces === 'function' ? schemaType.getInterfaces().map(function (i) {
    return i.name;
  }) : [];
  var unionLabels = getUnionLabels({
    typeName: typeName,
    typeMap: typeMap
  });
  var additionalLabels = [].concat((0, _toConsumableArray2["default"])(additionalNodeLabels), (0, _toConsumableArray2["default"])(interfaceLabels), (0, _toConsumableArray2["default"])(unionLabels));

  var _mergeSelectionFragme3 = (0, _selections.mergeSelectionFragments)({
    schemaType: schemaType,
    selections: selections,
    isFragmentedObjectType: isFragmentedObjectType,
    isFragmentedInterfaceType: isFragmentedInterfaceType,
    isUnionType: isUnionType,
    typeMap: typeMap,
    resolveInfo: resolveInfo
  }),
      _mergeSelectionFragme4 = (0, _slicedToArray2["default"])(_mergeSelectionFragme3, 2),
      schemaTypeFields = _mergeSelectionFragme4[0],
      derivedTypeMap = _mergeSelectionFragme4[1];

  var translation = "";
  var translationParams = {};

  if (mutationTypeCypherDirective) {
    var _customMutation = customMutation({
      resolveInfo: resolveInfo,
      schemaType: schemaType,
      schemaTypeFields: schemaTypeFields,
      derivedTypeMap: derivedTypeMap,
      isObjectType: isObjectType,
      isInterfaceType: isInterfaceType,
      isUnionType: isUnionType,
      usesFragments: usesFragments,
      selections: selections,
      params: params,
      context: context,
      mutationTypeCypherDirective: mutationTypeCypherDirective,
      variableName: variableName,
      orderByValue: orderByValue,
      outerSkipLimit: outerSkipLimit
    });

    var _customMutation2 = (0, _slicedToArray2["default"])(_customMutation, 2);

    translation = _customMutation2[0];
    translationParams = _customMutation2[1];
  } else if ((0, _utils.isCreateMutation)(resolveInfo)) {
    var _nodeCreate = nodeCreate({
      resolveInfo: resolveInfo,
      schemaType: schemaType,
      selections: selections,
      params: params,
      context: context,
      variableName: variableName,
      typeName: typeName,
      additionalLabels: additionalLabels,
      typeMap: typeMap
    });

    var _nodeCreate2 = (0, _slicedToArray2["default"])(_nodeCreate, 2);

    translation = _nodeCreate2[0];
    translationParams = _nodeCreate2[1];
  } else if ((0, _utils.isDeleteMutation)(resolveInfo)) {
    var _nodeDelete = nodeDelete({
      resolveInfo: resolveInfo,
      schemaType: schemaType,
      selections: selections,
      params: params,
      variableName: variableName,
      typeName: typeName
    });

    var _nodeDelete2 = (0, _slicedToArray2["default"])(_nodeDelete, 2);

    translation = _nodeDelete2[0];
    translationParams = _nodeDelete2[1];
  } else if ((0, _utils.isAddMutation)(resolveInfo)) {
    var _relationshipCreate = relationshipCreate({
      resolveInfo: resolveInfo,
      schemaType: schemaType,
      selections: selections,
      params: params,
      context: context
    });

    var _relationshipCreate2 = (0, _slicedToArray2["default"])(_relationshipCreate, 2);

    translation = _relationshipCreate2[0];
    translationParams = _relationshipCreate2[1];
  } else if ((0, _utils.isUpdateMutation)(resolveInfo) || (0, _utils.isMergeMutation)(resolveInfo)) {
    /**
     * TODO: Once we are no longer using the @MutationMeta directive
     * on relationship mutations, we will need to more directly identify
     * whether this Merge mutation if for a node or relationship
     */
    if (mutationMeta) {
      var _relationshipMergeOrU = relationshipMergeOrUpdate({
        mutationMeta: mutationMeta,
        resolveInfo: resolveInfo,
        selections: selections,
        schemaType: schemaType,
        params: params,
        context: context
      });

      var _relationshipMergeOrU2 = (0, _slicedToArray2["default"])(_relationshipMergeOrU, 2);

      translation = _relationshipMergeOrU2[0];
      translationParams = _relationshipMergeOrU2[1];
    } else {
      var _nodeMergeOrUpdate = nodeMergeOrUpdate({
        resolveInfo: resolveInfo,
        variableName: variableName,
        typeName: typeName,
        selections: selections,
        schemaType: schemaType,
        additionalLabels: additionalLabels,
        params: params,
        context: context,
        typeMap: typeMap
      });

      var _nodeMergeOrUpdate2 = (0, _slicedToArray2["default"])(_nodeMergeOrUpdate, 2);

      translation = _nodeMergeOrUpdate2[0];
      translationParams = _nodeMergeOrUpdate2[1];
    }
  } else if ((0, _utils.isRemoveMutation)(resolveInfo)) {
    var _relationshipDelete = relationshipDelete({
      resolveInfo: resolveInfo,
      schemaType: schemaType,
      selections: selections,
      params: params,
      context: context
    });

    var _relationshipDelete2 = (0, _slicedToArray2["default"])(_relationshipDelete, 2);

    translation = _relationshipDelete2[0];
    translationParams = _relationshipDelete2[1];
  } else {
    // throw error - don't know how to handle this type of mutation
    throw new Error('Do not know how to handle this type of mutation. Mutation does not follow naming convention.');
  }

  return [translation, translationParams];
}; // Custom write operation


exports.translateMutation = translateMutation;

var customMutation = function customMutation(_ref18) {
  var params = _ref18.params,
      context = _ref18.context,
      mutationTypeCypherDirective = _ref18.mutationTypeCypherDirective,
      selections = _ref18.selections,
      variableName = _ref18.variableName,
      schemaType = _ref18.schemaType,
      schemaTypeFields = _ref18.schemaTypeFields,
      derivedTypeMap = _ref18.derivedTypeMap,
      isObjectType = _ref18.isObjectType,
      isInterfaceType = _ref18.isInterfaceType,
      isUnionType = _ref18.isUnionType,
      usesFragments = _ref18.usesFragments,
      resolveInfo = _ref18.resolveInfo,
      orderByValue = _ref18.orderByValue,
      outerSkipLimit = _ref18.outerSkipLimit;
  var cypherParams = getCypherParams(context);
  var safeVariableName = (0, _utils.safeVar)(variableName); // FIXME: support IN for multiple values -> WHERE

  var argString = (0, _utils.paramsToString)((0, _utils.innerFilterParams)((0, _utils.getFilterParams)(params.params || params), null, null, true), cypherParams);
  var cypherQueryArg = mutationTypeCypherDirective.arguments.find(function (x) {
    return x.name.value === 'statement';
  });

  var _buildCypherSelection5 = (0, _selections.buildCypherSelection)({
    selections: selections,
    variableName: variableName,
    schemaType: schemaType,
    resolveInfo: resolveInfo,
    cypherParams: cypherParams
  }),
      _buildCypherSelection6 = (0, _slicedToArray2["default"])(_buildCypherSelection5, 2),
      subQuery = _buildCypherSelection6[0],
      subParams = _buildCypherSelection6[1];

  var isScalarType = (0, _utils.isGraphqlScalarType)(schemaType);
  var isNeo4jTypeOutput = (0, _utils.isNeo4jType)(schemaType.name);
  var isScalarField = isNeo4jTypeOutput || isScalarType;
  var orderByClause = orderByValue.cypherPart;
  var listVariable = "apoc.map.values(value, [keys(value)[0]])[0] ";

  var _buildMapProjection13 = buildMapProjection({
    isComputedMutation: true,
    listVariable: listVariable,
    schemaType: schemaType,
    schemaTypeFields: schemaTypeFields,
    derivedTypeMap: derivedTypeMap,
    isObjectType: isObjectType,
    isInterfaceType: isInterfaceType,
    isUnionType: isUnionType,
    usesFragments: usesFragments,
    safeVariableName: safeVariableName,
    subQuery: subQuery,
    resolveInfo: resolveInfo
  }),
      _buildMapProjection14 = (0, _slicedToArray2["default"])(_buildMapProjection13, 2),
      mapProjection = _buildMapProjection14[0],
      labelPredicate = _buildMapProjection14[1];

  var query = '';

  if (labelPredicate) {
    query = "CALL apoc.cypher.doIt(\"".concat(cypherQueryArg.value.value, "\", ").concat(argString, ") YIELD value\n    ").concat(!isScalarField ? labelPredicate : '', "AS ").concat(safeVariableName, "\n    RETURN ").concat(!isScalarField ? "".concat(mapProjection, " AS ").concat(safeVariableName).concat(orderByClause).concat(outerSkipLimit) : '');
  } else {
    query = "CALL apoc.cypher.doIt(\"".concat(cypherQueryArg.value.value, "\", ").concat(argString, ") YIELD value\n    WITH ").concat(listVariable, "AS ").concat(safeVariableName, "\n    RETURN ").concat(safeVariableName, " ").concat(!isScalarField ? "{".concat(isInterfaceType ? "".concat(fragmentType(safeVariableName, schemaType.name), ",") : '').concat(subQuery, "} AS ").concat(safeVariableName).concat(orderByClause).concat(outerSkipLimit) : '');
  }

  var fragmentTypeParams = derivedTypesParams({
    isInterfaceType: isInterfaceType,
    isUnionType: isUnionType,
    schema: resolveInfo.schema,
    schemaTypeName: schemaType.name,
    usesFragments: usesFragments
  });
  params = _objectSpread({}, params, {}, subParams, {}, fragmentTypeParams);

  if (cypherParams) {
    params['cypherParams'] = cypherParams;
  }

  return [query, _objectSpread({}, params)];
}; // Generated API
// Node Create - Update - Delete


var nodeCreate = function nodeCreate(_ref19) {
  var resolveInfo = _ref19.resolveInfo,
      schemaType = _ref19.schemaType,
      selections = _ref19.selections,
      params = _ref19.params,
      context = _ref19.context,
      variableName = _ref19.variableName,
      typeName = _ref19.typeName,
      additionalLabels = _ref19.additionalLabels,
      typeMap = _ref19.typeMap;
  var safeVariableName = (0, _utils.safeVar)(variableName);
  var safeLabelName = (0, _utils.safeLabel)([typeName].concat((0, _toConsumableArray2["default"])(additionalLabels)));
  var statements = [];
  var args = (0, _utils.getMutationArguments)(resolveInfo);
  var fieldMap = schemaType.getFields();
  var fields = (0, _values["default"])(fieldMap).map(function (field) {
    return field.astNode;
  });
  var primaryKey = (0, _selection.getPrimaryKey)({
    fields: fields
  });
  var createStatement = "";
  var dataArgument = args.find(function (arg) {
    return arg.name.value === 'data';
  });
  var paramKey = 'params';
  var dataParams = params[paramKey];

  if (dataArgument) {
    // config.experimental
    var unwrappedType = (0, _fields.unwrapNamedType)({
      type: dataArgument.type
    });
    var name = unwrappedType.name;
    var inputType = typeMap[name];
    var inputValues = inputType.getFields(); // get the input value AST definitions of the .data input object

    args = (0, _values["default"])(inputValues).map(function (arg) {
      return arg.astNode;
    }); // use the .data key instead of the existing .params format

    paramKey = 'data';
    dataParams = dataParams[paramKey]; // elevate .data to top level

    params.data = dataParams; // remove .params entry

    delete params.params;
  } else {
    dataParams = params.params;
  } // use apoc.create.uuid() to set a default value for @id field,
  // if no value for it is provided in dataParams


  statements = (0, _utils.setPrimaryKeyValue)({
    args: args,
    statements: statements,
    params: dataParams,
    primaryKey: primaryKey
  });
  var paramStatements = (0, _utils.buildCypherParameters)({
    args: args,
    statements: statements,
    params: params,
    paramKey: paramKey,
    resolveInfo: resolveInfo
  });
  createStatement = "CREATE (".concat(safeVariableName, ":").concat(safeLabelName, " {").concat(paramStatements.join(','), "})");

  var _buildCypherSelection7 = (0, _selections.buildCypherSelection)({
    selections: selections,
    variableName: variableName,
    schemaType: schemaType,
    resolveInfo: resolveInfo,
    cypherParams: getCypherParams(context)
  }),
      _buildCypherSelection8 = (0, _slicedToArray2["default"])(_buildCypherSelection7, 2),
      subQuery = _buildCypherSelection8[0],
      subParams = _buildCypherSelection8[1];

  params = _objectSpread({}, params, {}, subParams);
  var query = "\n    ".concat(createStatement, "\n    RETURN ").concat(safeVariableName, " {").concat(subQuery, "} AS ").concat(safeVariableName, "\n  ");
  return [query, params];
};

var nodeMergeOrUpdate = function nodeMergeOrUpdate(_ref20) {
  var resolveInfo = _ref20.resolveInfo,
      variableName = _ref20.variableName,
      typeName = _ref20.typeName,
      selections = _ref20.selections,
      schemaType = _ref20.schemaType,
      additionalLabels = _ref20.additionalLabels,
      params = _ref20.params,
      context = _ref20.context,
      typeMap = _ref20.typeMap;
  var safeVariableName = (0, _utils.safeVar)(variableName);
  var args = (0, _utils.getMutationArguments)(resolveInfo);
  var selectionArgument = args.find(function (arg) {
    return arg.name.value === 'where';
  });
  var dataArgument = args.find(function (arg) {
    return arg.name.value === 'data';
  });
  var fieldMap = schemaType.getFields();
  var fields = (0, _values["default"])(fieldMap).map(function (field) {
    return field.astNode;
  });
  var primaryKey = (0, _selection.getPrimaryKey)({
    fields: fields
  });
  var primaryKeyArgName = primaryKey.name.value;
  var cypherOperation = '';
  var safeLabelName = (0, _utils.safeLabel)(typeName);

  if ((0, _utils.isMergeMutation)(resolveInfo)) {
    safeLabelName = (0, _utils.safeLabel)([typeName].concat((0, _toConsumableArray2["default"])(additionalLabels)));
    cypherOperation = 'MERGE';
  } else if ((0, _utils.isUpdateMutation)(resolveInfo)) {
    cypherOperation = 'MATCH';
  }

  var query = "";
  var paramUpdateStatements = [];

  if (selectionArgument && dataArgument) {
    // config.experimental
    // no need to use .params key in this argument design
    params = params.params;
    var inputTranslation = translateNodeInputArgument({
      dataArgument: dataArgument,
      variableName: variableName,
      params: params,
      typeMap: typeMap,
      resolveInfo: resolveInfo,
      context: context
    });

    if ((0, _utils.isMergeMutation)(resolveInfo)) {
      var unwrappedType = (0, _fields.unwrapNamedType)({
        type: selectionArgument.type
      });
      var name = unwrappedType.name;
      var inputType = typeMap[name];
      var inputValues = inputType.getFields();
      var selectionArgs = (0, _values["default"])(inputValues).map(function (arg) {
        return arg.astNode;
      });
      var selectionExpression = (0, _utils.buildCypherParameters)({
        args: selectionArgs,
        params: params,
        paramKey: 'where',
        resolveInfo: resolveInfo,
        cypherParams: getCypherParams(context)
      });
      query = "".concat(cypherOperation, " (").concat(safeVariableName, ":").concat(safeLabelName, "{").concat(selectionExpression.join(','), "})").concat(inputTranslation, "\n");
    } else {
      var _translateNodeSelecti = translateNodeSelectionArgument({
        variableName: variableName,
        args: args,
        params: params,
        schemaType: schemaType,
        resolveInfo: resolveInfo
      }),
          _translateNodeSelecti2 = (0, _slicedToArray2["default"])(_translateNodeSelecti, 2),
          predicate = _translateNodeSelecti2[0],
          serializedFilter = _translateNodeSelecti2[1];

      query = "".concat(cypherOperation, " (").concat(safeVariableName, ":").concat(safeLabelName, ")").concat(predicate).concat(inputTranslation, "\n");
      params = _objectSpread({}, params, {}, serializedFilter);
    }
  } else {
    var _splitSelectionParame = (0, _utils.splitSelectionParameters)(params, primaryKeyArgName, 'params'),
        _splitSelectionParame2 = (0, _slicedToArray2["default"])(_splitSelectionParame, 2),
        primaryKeyParam = _splitSelectionParame2[0],
        updateParams = _splitSelectionParame2[1];

    paramUpdateStatements = (0, _utils.buildCypherParameters)({
      args: args,
      params: updateParams,
      paramKey: 'params',
      resolveInfo: resolveInfo,
      cypherParams: getCypherParams(context)
    });
    query = "".concat(cypherOperation, " (").concat(safeVariableName, ":").concat(safeLabelName, "{").concat(primaryKeyArgName, ": $params.").concat(primaryKeyArgName, "})\n  ");

    if (paramUpdateStatements.length > 0) {
      query += "SET ".concat(safeVariableName, " += {").concat(paramUpdateStatements.join(','), "} ");
    }

    if (!params.params) params.params = {};
    params.params[primaryKeyArgName] = primaryKeyParam[primaryKeyArgName];
  }

  var _buildCypherSelection9 = (0, _selections.buildCypherSelection)({
    selections: selections,
    variableName: variableName,
    schemaType: schemaType,
    resolveInfo: resolveInfo,
    cypherParams: getCypherParams(context)
  }),
      _buildCypherSelection10 = (0, _slicedToArray2["default"])(_buildCypherSelection9, 2),
      subQuery = _buildCypherSelection10[0],
      subParams = _buildCypherSelection10[1];

  params = _objectSpread({}, params, {}, subParams);
  query += "RETURN ".concat(safeVariableName, " {").concat(subQuery, "} AS ").concat(safeVariableName);
  return [query, params];
};

var nodeDelete = function nodeDelete(_ref21) {
  var resolveInfo = _ref21.resolveInfo,
      selections = _ref21.selections,
      variableName = _ref21.variableName,
      typeName = _ref21.typeName,
      schemaType = _ref21.schemaType,
      params = _ref21.params;
  var safeVariableName = (0, _utils.safeVar)(variableName);
  var safeLabelName = (0, _utils.safeLabel)(typeName);
  var args = (0, _utils.getMutationArguments)(resolveInfo);
  var fieldMap = schemaType.getFields();
  var fields = (0, _values["default"])(fieldMap).map(function (field) {
    return field.astNode;
  });
  var primaryKey = (0, _selection.getPrimaryKey)({
    fields: fields
  });
  var primaryKeyArgName = primaryKey.name.value;
  var matchStatement = "";
  var selectionArgument = args.find(function (arg) {
    return arg.name.value === 'where';
  });

  if (selectionArgument) {
    var _translateNodeSelecti3 = translateNodeSelectionArgument({
      variableName: variableName,
      args: args,
      params: params,
      schemaType: schemaType,
      resolveInfo: resolveInfo
    }),
        _translateNodeSelecti4 = (0, _slicedToArray2["default"])(_translateNodeSelecti3, 2),
        predicate = _translateNodeSelecti4[0],
        serializedFilter = _translateNodeSelecti4[1];

    matchStatement = "MATCH (".concat(safeVariableName, ":").concat(safeLabelName, ")").concat(predicate);
    params = _objectSpread({}, params, {}, serializedFilter);
  } else {
    matchStatement = "MATCH (".concat(safeVariableName, ":").concat(safeLabelName, " {").concat(primaryKeyArgName, ": $").concat(primaryKeyArgName, "})");
  }

  var _buildCypherSelection11 = (0, _selections.buildCypherSelection)({
    selections: selections,
    variableName: variableName,
    schemaType: schemaType,
    resolveInfo: resolveInfo
  }),
      _buildCypherSelection12 = (0, _slicedToArray2["default"])(_buildCypherSelection11, 2),
      subQuery = _buildCypherSelection12[0],
      subParams = _buildCypherSelection12[1];

  params = _objectSpread({}, params, {}, subParams);
  var deletionVariableName = (0, _utils.safeVar)("".concat(variableName, "_toDelete")); // Cannot execute a map projection on a deleted node in Neo4j
  // so the projection is executed and aliased before the delete

  var query = "".concat(matchStatement, "\nWITH ").concat(safeVariableName, " AS ").concat(deletionVariableName, ", ").concat(safeVariableName, " {").concat(subQuery, "} AS ").concat(safeVariableName, "\nDETACH DELETE ").concat(deletionVariableName, "\nRETURN ").concat(safeVariableName);
  return [query, params];
};

var translateNodeInputArgument = function translateNodeInputArgument(_ref22) {
  var _ref22$dataArgument = _ref22.dataArgument,
      dataArgument = _ref22$dataArgument === void 0 ? {} : _ref22$dataArgument,
      variableName = _ref22.variableName,
      params = _ref22.params,
      typeMap = _ref22.typeMap,
      resolveInfo = _ref22.resolveInfo,
      context = _ref22.context;
  var unwrappedType = (0, _fields.unwrapNamedType)({
    type: dataArgument.type
  });
  var name = unwrappedType.name;
  var inputType = typeMap[name];
  var inputValues = inputType.getFields();
  var updateArgs = (0, _values["default"])(inputValues).map(function (arg) {
    return arg.astNode;
  });
  var translation = '';
  var paramUpdateStatements = (0, _utils.buildCypherParameters)({
    args: updateArgs,
    params: params,
    paramKey: 'data',
    resolveInfo: resolveInfo,
    cypherParams: getCypherParams(context)
  });

  if (paramUpdateStatements.length > 0) {
    translation = "\nSET ".concat((0, _utils.safeVar)(variableName), " += {").concat(paramUpdateStatements.join(','), "} ");
  }

  return translation;
};

var translateNodeSelectionArgument = function translateNodeSelectionArgument(_ref23) {
  var variableName = _ref23.variableName,
      args = _ref23.args,
      params = _ref23.params,
      schemaType = _ref23.schemaType,
      resolveInfo = _ref23.resolveInfo;

  var _processFilterArgumen9 = processFilterArgument({
    argumentName: 'where',
    fieldArgs: args,
    schemaType: schemaType,
    variableName: variableName,
    resolveInfo: resolveInfo,
    params: params
  }),
      _processFilterArgumen10 = (0, _slicedToArray2["default"])(_processFilterArgumen9, 2),
      filterPredicates = _processFilterArgumen10[0],
      serializedFilter = _processFilterArgumen10[1];

  var predicateClauses = (0, _toConsumableArray2["default"])(filterPredicates).filter(function (predicate) {
    return !!predicate;
  }).join(' AND ');
  var predicate = "";

  if ((0, _utils.isMergeMutation)(resolveInfo)) {
    predicate = predicateClauses;
  } else {
    predicate = predicateClauses ? " WHERE ".concat(predicateClauses, " ") : '';
  }

  return [predicate, serializedFilter];
}; // Relation Add / Remove


var relationshipCreate = function relationshipCreate(_ref24) {
  var _parentSelectionInfo;

  var resolveInfo = _ref24.resolveInfo,
      selections = _ref24.selections,
      schemaType = _ref24.schemaType,
      params = _ref24.params,
      context = _ref24.context;
  var mutationMeta, relationshipNameArg, fromTypeArg, toTypeArg;

  try {
    mutationMeta = resolveInfo.schema.getMutationType().getFields()[resolveInfo.fieldName].astNode.directives.find(function (x) {
      return x.name.value === 'MutationMeta';
    });
  } catch (e) {
    throw new Error('Missing required MutationMeta directive on add relationship directive');
  }

  try {
    relationshipNameArg = mutationMeta.arguments.find(function (x) {
      return x.name.value === 'relationship';
    });
    fromTypeArg = mutationMeta.arguments.find(function (x) {
      return x.name.value === 'from';
    });
    toTypeArg = mutationMeta.arguments.find(function (x) {
      return x.name.value === 'to';
    });
  } catch (e) {
    throw new Error('Missing required argument in MutationMeta directive (relationship, from, or to)');
  }

  var schemaTypeName = (0, _utils.safeVar)(schemaType);
  var cypherParams = getCypherParams(context);
  var args = (0, _utils.getMutationArguments)(resolveInfo);
  var typeMap = resolveInfo.schema.getTypeMap();
  var fromType = fromTypeArg.value.value;
  var fromSchemaType = resolveInfo.schema.getType(fromType);
  var fromAdditionalLabels = (0, _utils.getAdditionalLabels)(fromSchemaType, cypherParams);
  var fromLabel = (0, _utils.safeLabel)([fromType].concat((0, _toConsumableArray2["default"])(fromAdditionalLabels)));
  var firstArg = args[0];
  var fromArgName = firstArg.name.value;
  var fromVar = "".concat((0, _utils.lowFirstLetter)(fromType), "_").concat(fromArgName);
  var fromVariable = (0, _utils.safeVar)(fromVar);
  var fromInputArg = firstArg.type;
  var fromInputArgType = (0, _graphql.getNamedType)(fromInputArg).type.name.value;
  var fromInputAst = typeMap[fromInputArgType].astNode;
  var fromFields = fromInputAst.fields;
  var fromCypherParam = fromFields[0].name.value;
  var toType = toTypeArg.value.value;
  var toSchemaType = resolveInfo.schema.getType(toType);
  var toAdditionalLabels = (0, _utils.getAdditionalLabels)(toSchemaType, cypherParams);
  var toLabel = (0, _utils.safeLabel)([toType].concat((0, _toConsumableArray2["default"])(toAdditionalLabels)));
  var secondArg = args[1];
  var toArgName = secondArg.name.value;
  var toVar = "".concat((0, _utils.lowFirstLetter)(toType), "_").concat(toArgName);
  var toVariable = (0, _utils.safeVar)(toVar);
  var toInputArg = secondArg.type;
  var toInputArgType = (0, _graphql.getNamedType)(toInputArg).type.name.value;
  var toInputAst = typeMap[toInputArgType].astNode;
  var toFields = toInputAst.fields;
  var toCypherParam = toFields[0].name.value;
  var relationshipName = relationshipNameArg.value.value;
  var lowercased = relationshipName.toLowerCase();
  var relationshipLabel = (0, _utils.safeLabel)(relationshipName);
  var relationshipVariable = (0, _utils.safeVar)(lowercased + '_relation');
  var dataInputArg = args.find(function (e) {
    return e.name.value === 'data';
  });
  var dataInputAst = dataInputArg ? typeMap[(0, _graphql.getNamedType)(dataInputArg.type).type.name.value].astNode : undefined;
  var dataFields = dataInputAst ? dataInputAst.fields : [];

  var _buildCypherSelection13 = (0, _selections.buildCypherSelection)({
    selections: selections,
    schemaType: schemaType,
    resolveInfo: resolveInfo,
    parentSelectionInfo: (_parentSelectionInfo = {
      fromArgName: fromArgName,
      toArgName: toArgName
    }, (0, _defineProperty3["default"])(_parentSelectionInfo, fromArgName, fromVar), (0, _defineProperty3["default"])(_parentSelectionInfo, toArgName, toVar), (0, _defineProperty3["default"])(_parentSelectionInfo, "variableName", lowercased), _parentSelectionInfo),
    cypherParams: getCypherParams(context)
  }),
      _buildCypherSelection14 = (0, _slicedToArray2["default"])(_buildCypherSelection13, 2),
      subQuery = _buildCypherSelection14[0],
      subParams = _buildCypherSelection14[1];

  var nodeSelectionStatements = "";
  var fromUsesWhereInput = fromInputArgType.startsWith('_') && fromInputArgType.endsWith('Where');
  var toUsesWhereInput = toInputArgType.startsWith('_') && toInputArgType.endsWith('Where');

  if (fromUsesWhereInput && toUsesWhereInput) {
    var _processFilterArgumen11 = processFilterArgument({
      argumentName: fromArgName,
      variableName: fromVar,
      schemaType: fromSchemaType,
      fieldArgs: args,
      resolveInfo: resolveInfo,
      params: params
    }),
        _processFilterArgumen12 = (0, _slicedToArray2["default"])(_processFilterArgumen11, 2),
        fromPredicate = _processFilterArgumen12[0],
        serializedFromFilter = _processFilterArgumen12[1];

    var fromClauses = (0, _toConsumableArray2["default"])(fromPredicate).filter(function (predicate) {
      return !!predicate;
    }).join(' AND ');

    var _processFilterArgumen13 = processFilterArgument({
      argumentName: toArgName,
      variableName: toVar,
      schemaType: toSchemaType,
      fieldArgs: args,
      resolveInfo: resolveInfo,
      params: params
    }),
        _processFilterArgumen14 = (0, _slicedToArray2["default"])(_processFilterArgumen13, 2),
        toPredicate = _processFilterArgumen14[0],
        serializedToFilter = _processFilterArgumen14[1];

    var toClauses = (0, _toConsumableArray2["default"])(toPredicate).filter(function (predicate) {
      return !!predicate;
    }).join(' AND ');
    var sourceNodeSelectionPredicate = fromClauses ? " WHERE ".concat(fromClauses, " ") : '';
    var targetNodeSelectionPredicate = toClauses ? " WHERE ".concat(toClauses, " ") : '';
    params = _objectSpread({}, params, {}, serializedFromFilter);
    params = _objectSpread({}, params, {}, serializedToFilter);
    nodeSelectionStatements = "MATCH (".concat(fromVariable, ":").concat(fromLabel, ")").concat(sourceNodeSelectionPredicate, "\n      MATCH (").concat(toVariable, ":").concat(toLabel, ")").concat(targetNodeSelectionPredicate);
  } else {
    nodeSelectionStatements = "MATCH (".concat(fromVariable, ":").concat(fromLabel, " {").concat(fromCypherParam, ": $").concat(fromArgName, ".").concat(fromCypherParam, "})\n      MATCH (").concat(toVariable, ":").concat(toLabel, " {").concat(toCypherParam, ": $").concat(toArgName, ".").concat(toCypherParam, "})");
  }

  var paramStatements = (0, _utils.buildCypherParameters)({
    args: dataFields,
    params: params,
    paramKey: 'data',
    resolveInfo: resolveInfo
  });
  params = _objectSpread({}, params, {}, subParams);
  var query = "\n      ".concat(nodeSelectionStatements, "\n      CREATE (").concat(fromVariable, ")-[").concat(relationshipVariable, ":").concat(relationshipLabel).concat(paramStatements.length > 0 ? " {".concat(paramStatements.join(','), "}") : '', "]->(").concat(toVariable, ")\n      RETURN ").concat(relationshipVariable, " { ").concat(subQuery, " } AS ").concat(schemaTypeName, ";\n    ");
  return [query, params];
};

var relationshipDelete = function relationshipDelete(_ref25) {
  var _parentSelectionInfo2;

  var resolveInfo = _ref25.resolveInfo,
      selections = _ref25.selections,
      schemaType = _ref25.schemaType,
      params = _ref25.params,
      context = _ref25.context;
  var mutationMeta, relationshipNameArg, fromTypeArg, toTypeArg;

  try {
    mutationMeta = resolveInfo.schema.getMutationType().getFields()[resolveInfo.fieldName].astNode.directives.find(function (x) {
      return x.name.value === 'MutationMeta';
    });
  } catch (e) {
    throw new Error('Missing required MutationMeta directive on add relationship directive');
  }

  try {
    relationshipNameArg = mutationMeta.arguments.find(function (x) {
      return x.name.value === 'relationship';
    });
    fromTypeArg = mutationMeta.arguments.find(function (x) {
      return x.name.value === 'from';
    });
    toTypeArg = mutationMeta.arguments.find(function (x) {
      return x.name.value === 'to';
    });
  } catch (e) {
    throw new Error('Missing required argument in MutationMeta directive (relationship, from, or to)');
  }

  var schemaTypeName = (0, _utils.safeVar)(schemaType);
  var cypherParams = getCypherParams(context);
  var args = (0, _utils.getMutationArguments)(resolveInfo);
  var typeMap = resolveInfo.schema.getTypeMap();
  var fromType = fromTypeArg.value.value;
  var fromSchemaType = resolveInfo.schema.getType(fromType);
  var fromAdditionalLabels = (0, _utils.getAdditionalLabels)(resolveInfo.schema.getType(fromType), cypherParams);
  var fromLabel = (0, _utils.safeLabel)([fromType].concat((0, _toConsumableArray2["default"])(fromAdditionalLabels)));
  var firstArg = args[0];
  var fromArgName = firstArg.name.value;
  var fromVar = "".concat((0, _utils.lowFirstLetter)(fromType), "_").concat(fromArgName);
  var fromVariable = (0, _utils.safeVar)(fromVar);
  var fromInputArg = firstArg.type;
  var fromInputArgType = (0, _graphql.getNamedType)(fromInputArg).type.name.value;
  var fromInputAst = typeMap[fromInputArgType].astNode;
  var fromFields = fromInputAst.fields;
  var fromCypherParam = fromFields[0].name.value;
  var toType = toTypeArg.value.value;
  var toSchemaType = resolveInfo.schema.getType(toType);
  var toAdditionalLabels = (0, _utils.getAdditionalLabels)(resolveInfo.schema.getType(toType), cypherParams);
  var toLabel = (0, _utils.safeLabel)([toType].concat((0, _toConsumableArray2["default"])(toAdditionalLabels)));
  var secondArg = args[1];
  var toArgName = secondArg.name.value;
  var toVar = "".concat((0, _utils.lowFirstLetter)(toType), "_").concat(toArgName);
  var toVariable = (0, _utils.safeVar)(toVar);
  var toInputArg = secondArg.type;
  var toInputArgType = (0, _graphql.getNamedType)(toInputArg).type.name.value;
  var toInputAst = typeMap[toInputArgType].astNode;
  var toFields = toInputAst.fields;
  var toCypherParam = toFields[0].name.value;
  var relationshipName = relationshipNameArg.value.value;
  var relationshipVariable = (0, _utils.safeVar)(fromVar + toVar);
  var relationshipLabel = (0, _utils.safeLabel)(relationshipName);
  var nodeSelectionStatements = "";
  var fromUsesWhereInput = fromInputArgType.startsWith('_') && fromInputArgType.endsWith('Where');
  var toUsesWhereInput = toInputArgType.startsWith('_') && toInputArgType.endsWith('Where');

  if (fromUsesWhereInput && toUsesWhereInput) {
    var _processFilterArgumen15 = processFilterArgument({
      argumentName: fromArgName,
      variableName: fromVar,
      schemaType: fromSchemaType,
      fieldArgs: args,
      resolveInfo: resolveInfo,
      params: params
    }),
        _processFilterArgumen16 = (0, _slicedToArray2["default"])(_processFilterArgumen15, 2),
        fromPredicate = _processFilterArgumen16[0],
        serializedFromFilter = _processFilterArgumen16[1];

    var fromClauses = (0, _toConsumableArray2["default"])(fromPredicate).filter(function (predicate) {
      return !!predicate;
    }).join(' AND ');

    var _processFilterArgumen17 = processFilterArgument({
      argumentName: toArgName,
      variableName: toVar,
      schemaType: toSchemaType,
      fieldArgs: args,
      resolveInfo: resolveInfo,
      params: params
    }),
        _processFilterArgumen18 = (0, _slicedToArray2["default"])(_processFilterArgumen17, 2),
        toPredicate = _processFilterArgumen18[0],
        serializedToFilter = _processFilterArgumen18[1];

    var toClauses = (0, _toConsumableArray2["default"])(toPredicate).filter(function (predicate) {
      return !!predicate;
    }).join(' AND ');
    var sourceNodeSelectionPredicate = fromClauses ? " WHERE ".concat(fromClauses, " ") : '';
    var targetNodeSelectionPredicate = toClauses ? " WHERE ".concat(toClauses, " ") : '';
    params = _objectSpread({}, params, {}, serializedFromFilter);
    params = _objectSpread({}, params, {}, serializedToFilter);
    nodeSelectionStatements = "MATCH (".concat(fromVariable, ":").concat(fromLabel, ")").concat(sourceNodeSelectionPredicate, "\n      MATCH (").concat(toVariable, ":").concat(toLabel, ")").concat(targetNodeSelectionPredicate);
  } else {
    nodeSelectionStatements = "MATCH (".concat(fromVariable, ":").concat(fromLabel, " {").concat(fromCypherParam, ": $").concat(fromArgName, ".").concat(fromCypherParam, "})\n      MATCH (").concat(toVariable, ":").concat(toLabel, " {").concat(toCypherParam, ": $").concat(toArgName, ".").concat(toCypherParam, "})");
  }

  var _buildCypherSelection15 = (0, _selections.buildCypherSelection)({
    selections: selections,
    schemaType: schemaType,
    resolveInfo: resolveInfo,
    parentSelectionInfo: (_parentSelectionInfo2 = {
      fromArgName: fromArgName,
      toArgName: toArgName
    }, (0, _defineProperty3["default"])(_parentSelectionInfo2, fromArgName, '_' + fromVar), (0, _defineProperty3["default"])(_parentSelectionInfo2, toArgName, '_' + toVar), _parentSelectionInfo2),
    cypherParams: getCypherParams(context)
  }),
      _buildCypherSelection16 = (0, _slicedToArray2["default"])(_buildCypherSelection15, 2),
      subQuery = _buildCypherSelection16[0],
      subParams = _buildCypherSelection16[1];

  var query = "\n      ".concat(nodeSelectionStatements, "\n      OPTIONAL MATCH (").concat(fromVariable, ")-[").concat(relationshipVariable, ":").concat(relationshipLabel, "]->(").concat(toVariable, ")\n      DELETE ").concat(relationshipVariable, "\n      WITH COUNT(*) AS scope, ").concat(fromVariable, " AS ").concat((0, _utils.safeVar)("_".concat(fromVar)), ", ").concat(toVariable, " AS ").concat((0, _utils.safeVar)("_".concat(toVar)), "\n      RETURN {").concat(subQuery, "} AS ").concat(schemaTypeName, ";\n    ");
  params = _objectSpread({}, params, {}, subParams);
  return [query, params];
};

var relationshipMergeOrUpdate = function relationshipMergeOrUpdate(_ref26) {
  var mutationMeta = _ref26.mutationMeta,
      resolveInfo = _ref26.resolveInfo,
      selections = _ref26.selections,
      schemaType = _ref26.schemaType,
      params = _ref26.params,
      context = _ref26.context;
  var query = '';
  var relationshipNameArg = undefined;
  var fromTypeArg = undefined;
  var toTypeArg = undefined;

  try {
    relationshipNameArg = mutationMeta.arguments.find(function (x) {
      return x.name.value === 'relationship';
    });
    fromTypeArg = mutationMeta.arguments.find(function (x) {
      return x.name.value === 'from';
    });
    toTypeArg = mutationMeta.arguments.find(function (x) {
      return x.name.value === 'to';
    });
  } catch (e) {
    throw new Error('Missing required argument in MutationMeta directive (relationship, from, or to)');
  }

  if (relationshipNameArg && fromTypeArg && toTypeArg) {
    var _parentSelectionInfo3;

    var schemaTypeName = (0, _utils.safeVar)(schemaType);
    var cypherParams = getCypherParams(context);
    var args = (0, _utils.getMutationArguments)(resolveInfo);
    var typeMap = resolveInfo.schema.getTypeMap();
    var fromType = fromTypeArg.value.value;
    var fromSchemaType = resolveInfo.schema.getType(fromType);
    var fromAdditionalLabels = (0, _utils.getAdditionalLabels)(resolveInfo.schema.getType(fromType), cypherParams);
    var fromLabel = (0, _utils.safeLabel)([fromType].concat((0, _toConsumableArray2["default"])(fromAdditionalLabels)));
    var firstArg = args[0];
    var fromArgName = firstArg.name.value;
    var fromVar = "".concat((0, _utils.lowFirstLetter)(fromType), "_").concat(fromArgName);
    var fromVariable = (0, _utils.safeVar)(fromVar);
    var fromInputArg = firstArg.type;
    var fromInputArgType = (0, _graphql.getNamedType)(fromInputArg).type.name.value;
    var fromInputAst = typeMap[fromInputArgType].astNode;
    var fromFields = fromInputAst.fields;
    var fromCypherParam = fromFields[0].name.value;
    var toType = toTypeArg.value.value;
    var toSchemaType = resolveInfo.schema.getType(toType);
    var toAdditionalLabels = (0, _utils.getAdditionalLabels)(resolveInfo.schema.getType(toType), cypherParams);
    var toLabel = (0, _utils.safeLabel)([toType].concat((0, _toConsumableArray2["default"])(toAdditionalLabels)));
    var secondArg = args[1];
    var toArgName = secondArg.name.value;
    var toVar = "".concat((0, _utils.lowFirstLetter)(toType), "_").concat(toArgName);
    var toVariable = (0, _utils.safeVar)(toVar);
    var toInputArg = secondArg.type;
    var toInputArgType = (0, _graphql.getNamedType)(toInputArg).type.name.value;
    var toInputAst = typeMap[toInputArgType].astNode;
    var toFields = toInputAst.fields;
    var toCypherParam = toFields[0].name.value;
    var relationshipName = relationshipNameArg.value.value;
    var lowercased = relationshipName.toLowerCase();
    var relationshipLabel = (0, _utils.safeLabel)(relationshipName);
    var relationshipVariable = (0, _utils.safeVar)(lowercased + '_relation');
    var dataInputArg = args.find(function (e) {
      return e.name.value === 'data';
    });
    var dataInputAst = dataInputArg ? typeMap[(0, _graphql.getNamedType)(dataInputArg.type).type.name.value].astNode : undefined;
    var dataFields = dataInputAst ? dataInputAst.fields : [];
    var nodeSelectionStatements = "";
    var fromUsesWhereInput = fromInputArgType.startsWith('_') && fromInputArgType.endsWith('Where');
    var toUsesWhereInput = toInputArgType.startsWith('_') && toInputArgType.endsWith('Where');

    if (fromUsesWhereInput && toUsesWhereInput) {
      var _processFilterArgumen19 = processFilterArgument({
        argumentName: fromArgName,
        variableName: fromVar,
        schemaType: fromSchemaType,
        fieldArgs: args,
        resolveInfo: resolveInfo,
        params: params
      }),
          _processFilterArgumen20 = (0, _slicedToArray2["default"])(_processFilterArgumen19, 2),
          fromPredicate = _processFilterArgumen20[0],
          serializedFromFilter = _processFilterArgumen20[1];

      var fromClauses = (0, _toConsumableArray2["default"])(fromPredicate).filter(function (predicate) {
        return !!predicate;
      }).join(' AND ');

      var _processFilterArgumen21 = processFilterArgument({
        argumentName: toArgName,
        variableName: toVar,
        schemaType: toSchemaType,
        fieldArgs: args,
        resolveInfo: resolveInfo,
        params: params
      }),
          _processFilterArgumen22 = (0, _slicedToArray2["default"])(_processFilterArgumen21, 2),
          toPredicate = _processFilterArgumen22[0],
          serializedToFilter = _processFilterArgumen22[1];

      var toClauses = (0, _toConsumableArray2["default"])(toPredicate).filter(function (predicate) {
        return !!predicate;
      }).join(' AND ');
      var sourceNodeSelectionPredicate = fromClauses ? " WHERE ".concat(fromClauses, " ") : '';
      var targetNodeSelectionPredicate = toClauses ? " WHERE ".concat(toClauses, " ") : '';
      params = _objectSpread({}, params, {}, serializedFromFilter);
      params = _objectSpread({}, params, {}, serializedToFilter);
      nodeSelectionStatements = "  MATCH (".concat(fromVariable, ":").concat(fromLabel, ")").concat(sourceNodeSelectionPredicate, "\n      MATCH (").concat(toVariable, ":").concat(toLabel, ")").concat(targetNodeSelectionPredicate);
    } else {
      nodeSelectionStatements = "  MATCH (".concat(fromVariable, ":").concat(fromLabel, " {").concat(fromCypherParam, ": $").concat(fromArgName, ".").concat(fromCypherParam, "})\n      MATCH (").concat(toVariable, ":").concat(toLabel, " {").concat(toCypherParam, ": $").concat(toArgName, ".").concat(toCypherParam, "})");
    }

    var _buildCypherSelection17 = (0, _selections.buildCypherSelection)({
      selections: selections,
      schemaType: schemaType,
      resolveInfo: resolveInfo,
      parentSelectionInfo: (_parentSelectionInfo3 = {
        fromArgName: fromArgName,
        toArgName: toArgName
      }, (0, _defineProperty3["default"])(_parentSelectionInfo3, fromArgName, fromVar), (0, _defineProperty3["default"])(_parentSelectionInfo3, toArgName, toVar), (0, _defineProperty3["default"])(_parentSelectionInfo3, "variableName", lowercased), _parentSelectionInfo3),
      cypherParams: getCypherParams(context)
    }),
        _buildCypherSelection18 = (0, _slicedToArray2["default"])(_buildCypherSelection17, 2),
        subQuery = _buildCypherSelection18[0],
        subParams = _buildCypherSelection18[1];

    var paramStatements = (0, _utils.buildCypherParameters)({
      args: dataFields,
      params: params,
      paramKey: 'data',
      resolveInfo: resolveInfo
    });
    var cypherOperation = '';

    if ((0, _utils.isMergeMutation)(resolveInfo)) {
      cypherOperation = 'MERGE';
    } else if ((0, _utils.isUpdateMutation)(resolveInfo)) {
      cypherOperation = 'MATCH';
    }

    query = "\n    ".concat(nodeSelectionStatements, "\n      ").concat(cypherOperation, " (").concat(fromVariable, ")-[").concat(relationshipVariable, ":").concat(relationshipLabel, "]->(").concat(toVariable, ")").concat(paramStatements.length > 0 ? "\n      SET ".concat(relationshipVariable, " += {").concat(paramStatements.join(','), "} ") : '', "\n      RETURN ").concat(relationshipVariable, " { ").concat(subQuery, " } AS ").concat(schemaTypeName, ";\n    ");
    params = _objectSpread({}, params, {}, subParams);
  }

  return [query, params];
};

var translateNestedOrderingArgument = function translateNestedOrderingArgument(_ref27) {
  var schemaType = _ref27.schemaType,
      selections = _ref27.selections,
      fieldSelectionSet = _ref27.fieldSelectionSet,
      filterParams = _ref27.filterParams;
  var orderByParam = filterParams['orderBy'];
  var usesTemporalOrdering = temporalOrderingFieldExists(schemaType, filterParams);
  var selectedFieldNames = fieldSelectionSet.reduce(function (fieldNames, field) {
    if (field.name) fieldNames.push(field.name.value);
    return fieldNames;
  }, []);
  var neo4jTypeFieldSelections = '';

  if (usesTemporalOrdering) {
    neo4jTypeFieldSelections = selections.reduce(function (temporalTypeFields, innerSelection) {
      // name of temporal type field
      var fieldName = innerSelection.name.value;
      var fieldTypeName = getFieldTypeName(schemaType, fieldName);
      var fieldIsSelected = selectedFieldNames.some(function (name) {
        return name === fieldName;
      });
      var isTemporalTypeField = (0, _utils.isTemporalType)(fieldTypeName);

      if (isTemporalTypeField && fieldIsSelected) {
        var innerSelectedTypes = innerSelection.selectionSet ? innerSelection.selectionSet.selections : [];
        temporalTypeFields.push("".concat(fieldName, ": {").concat(innerSelectedTypes.reduce(function (temporalSubFields, t) {
          // temporal type subfields, year, minute, etc.
          var subFieldName = t.name.value;

          if (subFieldName === 'formatted') {
            temporalSubFields.push("".concat(subFieldName, ": toString(sortedElement.").concat(fieldName, ")"));
          } else {
            temporalSubFields.push("".concat(subFieldName, ": sortedElement.").concat(fieldName, ".").concat(subFieldName));
          }

          return temporalSubFields;
        }, []).join(','), "}"));
      }

      return temporalTypeFields;
    }, []).join(',');
  }

  var lhsOrdering = orderByParam ? usesTemporalOrdering ? "[sortedElement IN apoc.coll.sortMulti(" : "apoc.coll.sortMulti(" : '';
  var rhsOrdering = orderByParam ? ", [".concat(buildSortMultiArgs(orderByParam), "])").concat(usesTemporalOrdering ? " | sortedElement { .* ".concat(neo4jTypeFieldSelections ? ",  ".concat(neo4jTypeFieldSelections) : '', "}]") : "") : '';
  return [lhsOrdering, rhsOrdering];
};

var getFieldTypeName = function getFieldTypeName(schemaType, fieldName) {
  var field = schemaType && fieldName ? schemaType.getFields()[fieldName] : undefined;
  return field ? field.type.name : '';
};

var temporalOrderingFieldExists = function temporalOrderingFieldExists(schemaType, filterParams) {
  var orderByParam = filterParams ? filterParams['orderBy'] : undefined;

  if (orderByParam) {
    orderByParam = orderByParam.value;
    if (!(0, _isArray["default"])(orderByParam)) orderByParam = [orderByParam];
    return orderByParam.find(function (e) {
      var fieldName = e.substring(0, e.lastIndexOf('_'));
      var fieldTypeName = getFieldTypeName(schemaType, fieldName);
      return (0, _utils.isTemporalType)(fieldTypeName);
    });
  }

  return undefined;
};

var buildSortMultiArgs = function buildSortMultiArgs(param) {
  var values = param ? param.value : [];
  var fieldName = '';
  if (!(0, _isArray["default"])(values)) values = [values];
  return values.map(function (e) {
    fieldName = e.substring(0, e.lastIndexOf('_'));
    return e.includes('_asc') ? "'^".concat(fieldName, "'") : "'".concat(fieldName, "'");
  }).join(',');
};

var processFilterArgument = function processFilterArgument(_ref28) {
  var _ref28$argumentName = _ref28.argumentName,
      argumentName = _ref28$argumentName === void 0 ? 'filter' : _ref28$argumentName,
      fieldArgs = _ref28.fieldArgs,
      isFederatedOperation = _ref28.isFederatedOperation,
      schemaType = _ref28.schemaType,
      variableName = _ref28.variableName,
      resolveInfo = _ref28.resolveInfo,
      params = _ref28.params,
      paramIndex = _ref28.paramIndex,
      parentSchemaType = _ref28.parentSchemaType,
      _ref28$rootIsRelation = _ref28.rootIsRelationType,
      rootIsRelationType = _ref28$rootIsRelation === void 0 ? false : _ref28$rootIsRelation;
  var filterArg = fieldArgs.find(function (e) {
    return e.name.value === argumentName;
  });
  var filterValue = (0, _keys["default"])(params).length ? params[argumentName] : undefined;
  var filterParamKey = paramIndex > 1 ? "".concat(paramIndex - 1, "_").concat(argumentName) : argumentName;
  var filterCypherParam = "$".concat(filterParamKey);
  var translations = []; // allows an exception for the existence of the filter argument AST
  // if isFederatedOperation

  if ((filterArg || isFederatedOperation) && filterValue) {
    // if field has both a filter argument and argument data is provided
    var schema = resolveInfo.schema;
    var serializedFilterParam = filterValue;
    var filterFieldMap = {};

    var _analyzeFilterArgumen = analyzeFilterArguments({
      filterValue: filterValue,
      variableName: variableName,
      filterCypherParam: filterCypherParam,
      schemaType: schemaType,
      schema: schema
    });

    var _analyzeFilterArgumen2 = (0, _slicedToArray2["default"])(_analyzeFilterArgumen, 2);

    filterFieldMap = _analyzeFilterArgumen2[0];
    serializedFilterParam = _analyzeFilterArgumen2[1];
    translations = translateFilterArguments({
      filterValue: filterValue,
      filterFieldMap: filterFieldMap,
      filterCypherParam: filterCypherParam,
      rootIsRelationType: rootIsRelationType,
      variableName: variableName,
      schemaType: schemaType,
      parentSchemaType: parentSchemaType,
      schema: schema
    });
    params = _objectSpread({}, params, (0, _defineProperty3["default"])({}, filterParamKey, serializedFilterParam));
  }

  return [translations, params];
};

var analyzeFilterArguments = function analyzeFilterArguments(_ref29) {
  var filterValue = _ref29.filterValue,
      variableName = _ref29.variableName,
      filterCypherParam = _ref29.filterCypherParam,
      schemaType = _ref29.schemaType,
      schema = _ref29.schema;
  return (0, _entries["default"])(filterValue).reduce(function (_ref30, _ref31) {
    var _ref32 = (0, _slicedToArray2["default"])(_ref30, 2),
        filterFieldMap = _ref32[0],
        serializedParams = _ref32[1];

    var _ref33 = (0, _slicedToArray2["default"])(_ref31, 2),
        name = _ref33[0],
        value = _ref33[1];

    var filterParamName = serializeFilterFieldName(name, value);

    var _analyzeFilterArgumen3 = analyzeFilterArgument({
      filterValue: value,
      filterValues: filterValue,
      fieldName: name,
      filterParam: filterCypherParam,
      variableName: variableName,
      schemaType: schemaType,
      schema: schema
    }),
        _analyzeFilterArgumen4 = (0, _slicedToArray2["default"])(_analyzeFilterArgumen3, 2),
        serializedValue = _analyzeFilterArgumen4[0],
        fieldMap = _analyzeFilterArgumen4[1];

    filterFieldMap[filterParamName] = fieldMap;
    serializedParams[filterParamName] = serializedValue;
    return [filterFieldMap, serializedParams];
  }, [{}, {}]);
};

var analyzeFilterArgument = function analyzeFilterArgument(_ref34) {
  var parentFieldName = _ref34.parentFieldName,
      filterValue = _ref34.filterValue,
      fieldName = _ref34.fieldName,
      variableName = _ref34.variableName,
      filterParam = _ref34.filterParam,
      parentSchemaType = _ref34.parentSchemaType,
      schemaType = _ref34.schemaType,
      schema = _ref34.schema;
  var parsedFilterName = parseFilterArgumentName(fieldName);
  var filterOperationField = parsedFilterName.name;
  var filterOperationType = parsedFilterName.type; // defaults

  var filterMapValue = true;
  var serializedFilterParam = filterValue;
  var innerSchemaType = schemaType;
  var typeName = schemaType.name;

  if (filterOperationField !== 'OR' && filterOperationField !== 'AND') {
    var schemaTypeFields = schemaType.getFields();
    var filterField = schemaTypeFields[filterOperationField];
    var filterFieldAst = filterField.astNode;
    var filterType = filterFieldAst.type;
    var innerFieldType = (0, _fields.unwrapNamedType)({
      type: filterType
    });
    typeName = innerFieldType.name;
    innerSchemaType = schema.getType(typeName);
  }

  if ((0, _graphql.isScalarType)(innerSchemaType) || (0, _graphql.isEnumType)(innerSchemaType)) {
    if (isExistentialFilter(filterOperationType, filterValue)) {
      serializedFilterParam = true;
      filterMapValue = null;
    }
  } else if ((0, _graphql.isObjectType)(innerSchemaType) || (0, _graphql.isInterfaceType)(innerSchemaType)) {
    if (fieldName === 'AND' || fieldName === 'OR') {
      // recursion
      var _analyzeNestedFilterA = analyzeNestedFilterArgument({
        filterValue: filterValue,
        filterOperationType: filterOperationType,
        parentFieldName: fieldName,
        parentSchemaType: schemaType,
        schemaType: schemaType,
        variableName: variableName,
        filterParam: filterParam,
        schema: schema
      });

      var _analyzeNestedFilterA2 = (0, _slicedToArray2["default"])(_analyzeNestedFilterA, 2);

      serializedFilterParam = _analyzeNestedFilterA2[0];
      filterMapValue = _analyzeNestedFilterA2[1];
    } else {
      var schemaTypeField = schemaType.getFields()[filterOperationField];

      var _innerSchemaType = (0, _utils.innerType)(schemaTypeField.type);

      var isObjectTypeFilter = (0, _graphql.isObjectType)(_innerSchemaType);
      var isInterfaceTypeFilter = (0, _graphql.isInterfaceType)(_innerSchemaType);

      if (isObjectTypeFilter || isInterfaceTypeFilter) {
        var _decideRelationFilter = decideRelationFilterMetadata({
          fieldName: fieldName,
          parentSchemaType: parentSchemaType,
          schemaType: schemaType,
          variableName: variableName,
          innerSchemaType: _innerSchemaType,
          filterOperationField: filterOperationField
        }),
            _decideRelationFilter2 = (0, _slicedToArray2["default"])(_decideRelationFilter, 9),
            thisType = _decideRelationFilter2[0],
            relatedType = _decideRelationFilter2[1],
            relationLabel = _decideRelationFilter2[2],
            relationDirection = _decideRelationFilter2[3],
            isRelation = _decideRelationFilter2[4],
            isRelationType = _decideRelationFilter2[5],
            isRelationTypeNode = _decideRelationFilter2[6],
            isReflexiveRelationType = _decideRelationFilter2[7],
            isReflexiveTypeDirectedField = _decideRelationFilter2[8];

        if (isReflexiveTypeDirectedField) {
          // for the 'from' and 'to' fields on the payload of a reflexive
          // relation type to use the parent field name, ex: 'knows_some'
          // is used for 'from' and 'to' in 'knows_some: { from: {}, to: {} }'
          var _parsedFilterName = parseFilterArgumentName(parentFieldName);

          filterOperationField = _parsedFilterName.name;
          filterOperationType = _parsedFilterName.type;
        }

        if (isExistentialFilter(filterOperationType, filterValue)) {
          serializedFilterParam = true;
          filterMapValue = null;
        } else if ((0, _utils.isTemporalType)(typeName) || (0, _utils.isSpatialType)(typeName) || (0, _utils.isSpatialDistanceInputType)({
          filterOperationType: filterOperationType
        })) {
          var _analyzeNeo4jTypeFilt = analyzeNeo4jTypeFilter({
            typeName: typeName,
            filterOperationType: filterOperationType,
            filterValue: filterValue,
            parentFieldName: parentFieldName
          });

          var _analyzeNeo4jTypeFilt2 = (0, _slicedToArray2["default"])(_analyzeNeo4jTypeFilt, 2);

          serializedFilterParam = _analyzeNeo4jTypeFilt2[0];
          filterMapValue = _analyzeNeo4jTypeFilt2[1];
        } else if (isRelation || isRelationType || isRelationTypeNode) {
          // recursion
          var _analyzeNestedFilterA3 = analyzeNestedFilterArgument({
            filterValue: filterValue,
            filterOperationType: filterOperationType,
            isRelationType: isRelationType,
            parentFieldName: fieldName,
            parentSchemaType: schemaType,
            schemaType: _innerSchemaType,
            variableName: variableName,
            filterParam: filterParam,
            schema: schema
          });

          var _analyzeNestedFilterA4 = (0, _slicedToArray2["default"])(_analyzeNestedFilterA3, 2);

          serializedFilterParam = _analyzeNestedFilterA4[0];
          filterMapValue = _analyzeNestedFilterA4[1];
        }
      }
    }
  }

  return [serializedFilterParam, filterMapValue];
};

var analyzeNeo4jTypeFilter = function analyzeNeo4jTypeFilter(_ref35) {
  var typeName = _ref35.typeName,
      filterOperationType = _ref35.filterOperationType,
      filterValue = _ref35.filterValue,
      parentFieldName = _ref35.parentFieldName;
  var filterMapValue = {};
  var isListFilterArgument = filterOperationType === 'in' || filterOperationType === 'not_in';

  if (isListFilterArgument) {
    filterMapValue = filterValue.reduce(function (booleanMap, filter) {
      (0, _keys["default"])(filter).forEach(function (key) {
        booleanMap[key] = true;
      });
      return booleanMap;
    }, {});
  } else {
    filterMapValue = (0, _keys["default"])(filterValue).reduce(function (booleanMap, key) {
      booleanMap[key] = true;
      return booleanMap;
    }, {});
  }

  var serializedFilterParam = filterValue;

  if (!(0, _utils.isSpatialDistanceInputType)({
    filterOperationType: filterOperationType
  }) && !(0, _utils.isSpatialType)(typeName)) {
    serializedFilterParam = serializeNeo4jTypeParam({
      filterValue: filterValue,
      filterOperationType: filterOperationType,
      parentFieldName: parentFieldName
    });
  }

  return [serializedFilterParam, filterMapValue];
};

var analyzeNestedFilterArgument = function analyzeNestedFilterArgument(_ref36) {
  var parentSchemaType = _ref36.parentSchemaType,
      parentFieldName = _ref36.parentFieldName,
      schemaType = _ref36.schemaType,
      variableName = _ref36.variableName,
      filterValue = _ref36.filterValue,
      filterParam = _ref36.filterParam,
      schema = _ref36.schema;
  var isList = (0, _isArray["default"])(filterValue); // coersion to array for dynamic iteration of objects and arrays

  if (!isList) filterValue = [filterValue];
  var serializedFilterValue = [];
  var filterValueFieldMap = {};
  filterValue.forEach(function (filter) {
    var serializedValues = {};
    var serializedValue = {};
    var valueFieldMap = {};
    (0, _entries["default"])(filter).forEach(function (_ref37) {
      var _ref38 = (0, _slicedToArray2["default"])(_ref37, 2),
          fieldName = _ref38[0],
          value = _ref38[1];

      fieldName = deserializeFilterFieldName(fieldName);

      var _analyzeFilterArgumen5 = analyzeFilterArgument({
        parentFieldName: parentFieldName,
        filterValue: value,
        filterValues: filter,
        fieldName: fieldName,
        variableName: variableName,
        filterParam: filterParam,
        parentSchemaType: parentSchemaType,
        schemaType: schemaType,
        schema: schema
      });

      var _analyzeFilterArgumen6 = (0, _slicedToArray2["default"])(_analyzeFilterArgumen5, 2);

      serializedValue = _analyzeFilterArgumen6[0];
      valueFieldMap = _analyzeFilterArgumen6[1];
      var filterParamName = serializeFilterFieldName(fieldName, value);
      var filterMapEntry = filterValueFieldMap[filterParamName];
      if (!filterMapEntry) filterValueFieldMap[filterParamName] = valueFieldMap; // deep merges in order to capture differences in objects within nested array filters
      else filterValueFieldMap[filterParamName] = _lodash["default"].merge(filterMapEntry, valueFieldMap);
      serializedValues[filterParamName] = serializedValue;
    });
    serializedFilterValue.push(serializedValues);
  }); // undo array coersion

  if (!isList) serializedFilterValue = serializedFilterValue[0];
  return [serializedFilterValue, filterValueFieldMap];
};

var serializeFilterFieldName = function serializeFilterFieldName(name, value) {
  if (value === null) {
    var parsedFilterName = parseFilterArgumentName(name);
    var filterOperationType = parsedFilterName.type;

    if (!filterOperationType || filterOperationType === 'not') {
      return "_".concat(name, "_null");
    }
  }

  return name;
};

var serializeNeo4jTypeParam = function serializeNeo4jTypeParam(_ref39) {
  var filterValue = _ref39.filterValue,
      filterOperationType = _ref39.filterOperationType,
      parentFieldName = _ref39.parentFieldName;
  var isList = (0, _isArray["default"])(filterValue);
  if (!isList) filterValue = [filterValue];
  var serializedValues = filterValue.reduce(function (serializedValues, filter) {
    var serializedValue = {};

    if (filter['formatted'] && parentFieldName !== 'OR' && parentFieldName !== 'AND' && filterOperationType !== 'in' && filterOperationType !== 'not_in' && !isList) {
      serializedValue = filter['formatted'];
    } else {
      serializedValue = (0, _entries["default"])(filter).reduce(function (serialized, _ref40) {
        var _ref41 = (0, _slicedToArray2["default"])(_ref40, 2),
            key = _ref41[0],
            value = _ref41[1];

        if ((0, _isInteger["default"])(value)) {
          value = _neo4jDriver["default"]["int"](value);
        }

        serialized[key] = value;
        return serialized;
      }, {});
    }

    serializedValues.push(serializedValue);
    return serializedValues;
  }, []);
  if (!isList) serializedValues = serializedValues[0];
  return serializedValues;
};

var deserializeFilterFieldName = function deserializeFilterFieldName(name) {
  if (name.startsWith('_') && name.endsWith('_null')) {
    name = name.substring(1, name.length - 5);
  }

  return name;
};

var translateFilterArguments = function translateFilterArguments(_ref42) {
  var filterValue = _ref42.filterValue,
      filterFieldMap = _ref42.filterFieldMap,
      filterCypherParam = _ref42.filterCypherParam,
      variableName = _ref42.variableName,
      rootIsRelationType = _ref42.rootIsRelationType,
      schemaType = _ref42.schemaType,
      parentSchemaType = _ref42.parentSchemaType,
      schema = _ref42.schema;
  return (0, _entries["default"])(filterFieldMap).reduce(function (translations, _ref43) {
    var _ref44 = (0, _slicedToArray2["default"])(_ref43, 2),
        name = _ref44[0],
        value = _ref44[1];

    // the filter field map uses serialized field names to allow for both field: {} and field: null
    name = deserializeFilterFieldName(name);
    var translation = translateFilterArgument({
      filterParam: filterCypherParam,
      fieldName: name,
      filterValue: value,
      paramValue: filterValue,
      rootIsRelationType: rootIsRelationType,
      variableName: variableName,
      schemaType: schemaType,
      parentSchemaType: parentSchemaType,
      schema: schema
    });

    if (translation) {
      translations.push("(".concat(translation, ")"));
    }

    return translations;
  }, []);
};

var translateFilterArgument = function translateFilterArgument(_ref45) {
  var parentParamPath = _ref45.parentParamPath,
      parentFieldName = _ref45.parentFieldName,
      _ref45$isListFilterAr = _ref45.isListFilterArgument,
      isListFilterArgument = _ref45$isListFilterAr === void 0 ? false : _ref45$isListFilterAr,
      filterValue = _ref45.filterValue,
      paramValue = _ref45.paramValue,
      fieldName = _ref45.fieldName,
      rootIsRelationType = _ref45.rootIsRelationType,
      variableName = _ref45.variableName,
      filterParam = _ref45.filterParam,
      schemaType = _ref45.schemaType,
      parentSchemaType = _ref45.parentSchemaType,
      schema = _ref45.schema;
  // parse field name into prefix (ex: name, company) and
  // possible suffix identifying operation type (ex: _gt, _in)
  var parsedFilterName = parseFilterArgumentName(fieldName);
  var filterOperationField = parsedFilterName.name;
  var filterOperationType = parsedFilterName.type;
  var innerSchemaType = schemaType;
  var typeName = schemaType.name;
  var innerFieldType = {};
  var isListFieldFilter = false;

  if (filterOperationField !== 'OR' && filterOperationField !== 'AND') {
    var schemaTypeFields = schemaType.getFields();
    var filterField = schemaTypeFields[filterOperationField];
    var filterFieldAst = filterField.astNode;
    var filterType = filterFieldAst.type;
    innerFieldType = (0, _fields.unwrapNamedType)({
      type: filterType
    });

    if (innerFieldType.wrappers[_fields.TypeWrappers.LIST_TYPE]) {
      isListFieldFilter = true;
    }

    typeName = innerFieldType.name;
    innerSchemaType = schema.getType(typeName);
  } // build path for parameter data for current filter field


  var parameterPath = "".concat(parentParamPath ? parentParamPath : filterParam, ".").concat(fieldName); // short-circuit evaluation: predicate used to skip a field
  // if processing a list of objects that possibly contain different arguments

  var nullFieldPredicate = decideNullSkippingPredicate({
    parameterPath: parameterPath,
    isListFilterArgument: isListFilterArgument,
    parentParamPath: parentParamPath
  });
  var translation = '';

  if ((0, _graphql.isScalarType)(innerSchemaType) || (0, _graphql.isEnumType)(innerSchemaType)) {
    translation = translateScalarFilter({
      typeName: typeName,
      isListFilterArgument: isListFilterArgument,
      isListFieldFilter: isListFieldFilter,
      filterOperationField: filterOperationField,
      filterOperationType: filterOperationType,
      filterValue: filterValue,
      paramValue: paramValue,
      fieldName: fieldName,
      variableName: variableName,
      parameterPath: parameterPath,
      parentParamPath: parentParamPath,
      filterParam: filterParam,
      nullFieldPredicate: nullFieldPredicate
    });
  } else if ((0, _graphql.isObjectType)(innerSchemaType) || (0, _graphql.isInterfaceType)(innerSchemaType)) {
    translation = translateInputFilter({
      rootIsRelationType: rootIsRelationType,
      isListFilterArgument: isListFilterArgument,
      isListFieldFilter: isListFieldFilter,
      filterOperationField: filterOperationField,
      filterOperationType: filterOperationType,
      filterValue: filterValue,
      paramValue: paramValue,
      variableName: variableName,
      fieldName: fieldName,
      filterParam: filterParam,
      schema: schema,
      parentSchemaType: parentSchemaType,
      schemaType: schemaType,
      parameterPath: parameterPath,
      parentParamPath: parentParamPath,
      parentFieldName: parentFieldName,
      nullFieldPredicate: nullFieldPredicate
    });
  }

  return translation;
};

var parseFilterArgumentName = function parseFilterArgumentName(fieldName) {
  var fieldNameParts = fieldName.split('_');
  var filterTypes = ['_not', '_in', '_not_in', '_contains', '_not_contains', '_starts_with', '_not_starts_with', '_ends_with', '_not_ends_with', '_lt', '_lte', '_gt', '_gte', '_some', '_none', '_single', '_every', '_distance', '_distance_lt', '_distance_lte', '_distance_gt', '_distance_gte'];
  var filterType = '';

  if (fieldNameParts.length > 1) {
    var regExp = [];

    _lodash["default"].each(filterTypes, function (f) {
      regExp.push(f + '$');
    });

    var regExpJoin = '(' + regExp.join('|') + ')';

    var preparedFieldAndFilterField = _lodash["default"].replace(fieldName, new RegExp(regExpJoin), '[::filterFieldSeperator::]$1');

    var _preparedFieldAndFilt = preparedFieldAndFilterField.split('[::filterFieldSeperator::]'),
        _preparedFieldAndFilt2 = (0, _slicedToArray2["default"])(_preparedFieldAndFilt, 2),
        parsedField = _preparedFieldAndFilt2[0],
        parsedFilterField = _preparedFieldAndFilt2[1];

    fieldName = !_lodash["default"].isUndefined(parsedField) ? parsedField : fieldName;
    filterType = !_lodash["default"].isUndefined(parsedFilterField) ? parsedFilterField.substr(1) : ''; // Strip off first underscore
  }

  return {
    name: fieldName,
    type: filterType
  };
};

var translateScalarFilter = function translateScalarFilter(_ref46) {
  var typeName = _ref46.typeName,
      isListFilterArgument = _ref46.isListFilterArgument,
      isListFieldFilter = _ref46.isListFieldFilter,
      filterOperationField = _ref46.filterOperationField,
      filterOperationType = _ref46.filterOperationType,
      filterValue = _ref46.filterValue,
      fieldName = _ref46.fieldName,
      paramValue = _ref46.paramValue,
      variableName = _ref46.variableName,
      parameterPath = _ref46.parameterPath,
      parentParamPath = _ref46.parentParamPath,
      filterParam = _ref46.filterParam,
      nullFieldPredicate = _ref46.nullFieldPredicate;
  // build path to node/relationship property
  var propertyPath = "".concat((0, _utils.safeVar)(variableName), ".").concat(filterOperationField);

  if (isExistentialFilter(filterOperationType, filterValue)) {
    return translateNullFilter({
      filterOperationField: filterOperationField,
      filterOperationType: filterOperationType,
      propertyPath: propertyPath,
      filterParam: filterParam,
      parentParamPath: parentParamPath,
      isListFilterArgument: isListFilterArgument
    });
  }

  if (isListFieldFilter) {
    return translateListArgument({
      typeName: typeName,
      filterValue: paramValue[fieldName],
      filterOperationType: filterOperationType,
      listVariable: propertyPath,
      paramPath: parameterPath
    });
  }

  return "".concat(nullFieldPredicate).concat(buildOperatorExpression({
    filterOperationType: filterOperationType,
    propertyPath: propertyPath
  }), " ").concat(parameterPath);
};

var isExistentialFilter = function isExistentialFilter(type, value) {
  return (!type || type === 'not') && value === null;
};

var decideNullSkippingPredicate = function decideNullSkippingPredicate(_ref47) {
  var parameterPath = _ref47.parameterPath,
      isListFilterArgument = _ref47.isListFilterArgument,
      parentParamPath = _ref47.parentParamPath;
  return isListFilterArgument && parentParamPath ? "".concat(parameterPath, " IS NULL OR ") : '';
};

var translateNullFilter = function translateNullFilter(_ref48) {
  var filterOperationField = _ref48.filterOperationField,
      filterOperationType = _ref48.filterOperationType,
      filterParam = _ref48.filterParam,
      propertyPath = _ref48.propertyPath,
      parentParamPath = _ref48.parentParamPath,
      isListFilterArgument = _ref48.isListFilterArgument;
  var isNegationFilter = filterOperationType === 'not'; // allign with modified parameter names for null filters

  var paramPath = "".concat(parentParamPath ? parentParamPath : filterParam, "._").concat(filterOperationField, "_").concat(isNegationFilter ? "not_" : '', "null"); // build a predicate for checking the existence of a
  // property or relationship

  var predicate = "".concat(paramPath, " = TRUE AND").concat(isNegationFilter ? '' : ' NOT', " EXISTS(").concat(propertyPath, ")"); // skip the field if it is null in the case of it
  // existing within one of many objects in a list filter

  var nullFieldPredicate = decideNullSkippingPredicate({
    parameterPath: paramPath,
    isListFilterArgument: isListFilterArgument,
    parentParamPath: parentParamPath
  });
  return "".concat(nullFieldPredicate).concat(predicate);
};

var buildOperatorExpression = function buildOperatorExpression(_ref49) {
  var filterOperationType = _ref49.filterOperationType,
      propertyPath = _ref49.propertyPath,
      isListFilterArgument = _ref49.isListFilterArgument,
      parameterPath = _ref49.parameterPath;
  if (isListFilterArgument) return "".concat(propertyPath, " =");

  switch (filterOperationType) {
    case 'not':
      return "NOT ".concat(propertyPath, " = ");

    case 'in':
      return "".concat(propertyPath, " IN");

    case 'not_in':
      return "NOT ".concat(propertyPath, " IN");

    case 'contains':
      return "".concat(propertyPath, " CONTAINS");

    case 'not_contains':
      return "NOT ".concat(propertyPath, " CONTAINS");

    case 'starts_with':
      return "".concat(propertyPath, " STARTS WITH");

    case 'not_starts_with':
      return "NOT ".concat(propertyPath, " STARTS WITH");

    case 'ends_with':
      return "".concat(propertyPath, " ENDS WITH");

    case 'not_ends_with':
      return "NOT ".concat(propertyPath, " ENDS WITH");

    case 'distance':
      return "distance(".concat(propertyPath, ", point(").concat(parameterPath, ".point)) =");

    case 'lt':
      return "".concat(propertyPath, " <");

    case 'distance_lt':
      return "distance(".concat(propertyPath, ", point(").concat(parameterPath, ".point)) <");

    case 'lte':
      return "".concat(propertyPath, " <=");

    case 'distance_lte':
      return "distance(".concat(propertyPath, ", point(").concat(parameterPath, ".point)) <=");

    case 'gt':
      return "".concat(propertyPath, " >");

    case 'distance_gt':
      return "distance(".concat(propertyPath, ", point(").concat(parameterPath, ".point)) >");

    case 'gte':
      return "".concat(propertyPath, " >=");

    case 'distance_gte':
      return "distance(".concat(propertyPath, ", point(").concat(parameterPath, ".point)) >=");

    default:
      {
        return "".concat(propertyPath, " =");
      }
  }
};

var translateInputFilter = function translateInputFilter(_ref50) {
  var rootIsRelationType = _ref50.rootIsRelationType,
      isListFilterArgument = _ref50.isListFilterArgument,
      isListFieldFilter = _ref50.isListFieldFilter,
      filterOperationField = _ref50.filterOperationField,
      filterOperationType = _ref50.filterOperationType,
      filterValue = _ref50.filterValue,
      paramValue = _ref50.paramValue,
      variableName = _ref50.variableName,
      fieldName = _ref50.fieldName,
      filterParam = _ref50.filterParam,
      schema = _ref50.schema,
      schemaType = _ref50.schemaType,
      parameterPath = _ref50.parameterPath,
      nullFieldPredicate = _ref50.nullFieldPredicate,
      parentSchemaType = _ref50.parentSchemaType,
      parentParamPath = _ref50.parentParamPath,
      parentFieldName = _ref50.parentFieldName;

  if (fieldName === 'AND' || fieldName === 'OR') {
    return translateLogicalFilter({
      filterValue: filterValue,
      variableName: variableName,
      filterOperationType: filterOperationType,
      filterOperationField: filterOperationField,
      fieldName: fieldName,
      filterParam: filterParam,
      schema: schema,
      schemaType: schemaType,
      parameterPath: parameterPath,
      nullFieldPredicate: nullFieldPredicate
    });
  } else {
    var schemaTypeField = schemaType.getFields()[filterOperationField];
    var innerSchemaType = (0, _utils.innerType)(schemaTypeField.type);
    var typeName = innerSchemaType.name;
    var isObjectTypeFilter = (0, _graphql.isObjectType)(innerSchemaType);
    var isInterfaceTypeFilter = (0, _graphql.isInterfaceType)(innerSchemaType);

    if (isObjectTypeFilter || isInterfaceTypeFilter) {
      var _decideRelationFilter3 = decideRelationFilterMetadata({
        fieldName: fieldName,
        parentSchemaType: parentSchemaType,
        schemaType: schemaType,
        variableName: variableName,
        innerSchemaType: innerSchemaType,
        filterOperationField: filterOperationField
      }),
          _decideRelationFilter4 = (0, _slicedToArray2["default"])(_decideRelationFilter3, 9),
          thisType = _decideRelationFilter4[0],
          relatedType = _decideRelationFilter4[1],
          relationLabel = _decideRelationFilter4[2],
          relationDirection = _decideRelationFilter4[3],
          isRelation = _decideRelationFilter4[4],
          isRelationType = _decideRelationFilter4[5],
          isRelationTypeNode = _decideRelationFilter4[6],
          isReflexiveRelationType = _decideRelationFilter4[7],
          isReflexiveTypeDirectedField = _decideRelationFilter4[8];

      if ((0, _utils.isTemporalType)(typeName) || (0, _utils.isSpatialType)(typeName) || (0, _utils.isSpatialDistanceInputType)({
        filterOperationType: filterOperationType
      })) {
        return translateNeo4jTypeFilter({
          typeName: typeName,
          isRelationTypeNode: isRelationTypeNode,
          filterValue: filterValue,
          paramValue: paramValue,
          variableName: variableName,
          filterOperationField: filterOperationField,
          filterOperationType: filterOperationType,
          fieldName: fieldName,
          filterParam: filterParam,
          parameterPath: parameterPath,
          parentParamPath: parentParamPath,
          isListFilterArgument: isListFilterArgument,
          isListFieldFilter: isListFieldFilter,
          nullFieldPredicate: nullFieldPredicate
        });
      } else if (isRelation || isRelationType || isRelationTypeNode) {
        var filterTranslation = translateRelationFilter({
          rootIsRelationType: rootIsRelationType,
          thisType: thisType,
          relatedType: relatedType,
          relationLabel: relationLabel,
          relationDirection: relationDirection,
          isRelationType: isRelationType,
          isRelationTypeNode: isRelationTypeNode,
          isReflexiveRelationType: isReflexiveRelationType,
          isReflexiveTypeDirectedField: isReflexiveTypeDirectedField,
          filterValue: filterValue,
          variableName: variableName,
          filterOperationField: filterOperationField,
          filterOperationType: filterOperationType,
          fieldName: fieldName,
          filterParam: filterParam,
          schema: schema,
          schemaType: schemaType,
          innerSchemaType: innerSchemaType,
          parameterPath: parameterPath,
          parentParamPath: parentParamPath,
          isListFilterArgument: isListFilterArgument,
          nullFieldPredicate: nullFieldPredicate,
          parentSchemaType: parentSchemaType,
          parentFieldName: parentFieldName
        });
        return filterTranslation;
      }
    }
  }
};

var translateLogicalFilter = function translateLogicalFilter(_ref51) {
  var filterValue = _ref51.filterValue,
      variableName = _ref51.variableName,
      filterOperationType = _ref51.filterOperationType,
      filterOperationField = _ref51.filterOperationField,
      fieldName = _ref51.fieldName,
      filterParam = _ref51.filterParam,
      schema = _ref51.schema,
      schemaType = _ref51.schemaType,
      parameterPath = _ref51.parameterPath,
      nullFieldPredicate = _ref51.nullFieldPredicate;
  var listElementVariable = "_".concat(fieldName); // build predicate expressions for all unique arguments within filterValue
  // isListFilterArgument is true here so that nullFieldPredicate is used

  var predicates = buildFilterPredicates({
    filterOperationType: filterOperationType,
    parentFieldName: fieldName,
    listVariable: listElementVariable,
    parentSchemaType: schemaType,
    isListFilterArgument: true,
    schemaType: schemaType,
    variableName: variableName,
    filterValue: filterValue,
    filterParam: filterParam,
    // typeFields,
    schema: schema
  });
  var predicateListVariable = parameterPath; // decide root predicate function

  var rootPredicateFunction = decidePredicateFunction({
    filterOperationField: filterOperationField
  }); // build root predicate expression

  var translation = buildPredicateFunction({
    nullFieldPredicate: nullFieldPredicate,
    predicateListVariable: predicateListVariable,
    rootPredicateFunction: rootPredicateFunction,
    predicates: predicates,
    listElementVariable: listElementVariable
  });
  return translation;
};

var translateRelationFilter = function translateRelationFilter(_ref52) {
  var rootIsRelationType = _ref52.rootIsRelationType,
      thisType = _ref52.thisType,
      relatedType = _ref52.relatedType,
      relationLabel = _ref52.relationLabel,
      relationDirection = _ref52.relationDirection,
      isRelationType = _ref52.isRelationType,
      isRelationTypeNode = _ref52.isRelationTypeNode,
      isReflexiveRelationType = _ref52.isReflexiveRelationType,
      isReflexiveTypeDirectedField = _ref52.isReflexiveTypeDirectedField,
      filterValue = _ref52.filterValue,
      variableName = _ref52.variableName,
      filterOperationField = _ref52.filterOperationField,
      filterOperationType = _ref52.filterOperationType,
      fieldName = _ref52.fieldName,
      filterParam = _ref52.filterParam,
      schema = _ref52.schema,
      schemaType = _ref52.schemaType,
      innerSchemaType = _ref52.innerSchemaType,
      parameterPath = _ref52.parameterPath,
      parentParamPath = _ref52.parentParamPath,
      isListFilterArgument = _ref52.isListFilterArgument,
      nullFieldPredicate = _ref52.nullFieldPredicate,
      parentSchemaType = _ref52.parentSchemaType,
      parentFieldName = _ref52.parentFieldName;

  if (isReflexiveTypeDirectedField) {
    // when at the 'from' or 'to' fields of a reflexive relation type payload
    // we need to use the name of the parent schema type, ex: 'person' for
    // Person.knows gets used here for reflexive path patterns, rather than
    // the normally set 'person_filter_person' variableName
    variableName = parentSchemaType.name.toLowerCase();
  }

  var pathExistencePredicate = buildRelationExistencePath(variableName, relationLabel, relationDirection, relatedType, isRelationTypeNode);

  if (isExistentialFilter(filterOperationType, filterValue)) {
    return translateNullFilter({
      filterOperationField: filterOperationField,
      filterOperationType: filterOperationType,
      propertyPath: pathExistencePredicate,
      filterParam: filterParam,
      parentParamPath: parentParamPath,
      isListFilterArgument: isListFilterArgument
    });
  }

  var parentFilterOperationField = filterOperationField;
  var parentFilterOperationType = filterOperationType;

  if (isReflexiveTypeDirectedField) {
    // causes the 'from' and 'to' fields on the payload of a reflexive
    // relation type to use the parent field name, ex: 'knows_some'
    // is used for 'from' and 'to' in 'knows_some: { from: {}, to: {} }'
    var parsedFilterName = parseFilterArgumentName(parentFieldName);
    parentFilterOperationField = parsedFilterName.name;
    parentFilterOperationType = parsedFilterName.type;
  } // build a list comprehension containing path pattern for related type


  var predicateListVariable = buildRelatedTypeListComprehension({
    rootIsRelationType: rootIsRelationType,
    variableName: variableName,
    thisType: thisType,
    relatedType: relatedType,
    relationLabel: relationLabel,
    relationDirection: relationDirection,
    isRelationTypeNode: isRelationTypeNode,
    isRelationType: isRelationType
  });
  var rootPredicateFunction = decidePredicateFunction({
    isRelationTypeNode: isRelationTypeNode,
    filterOperationField: parentFilterOperationField,
    filterOperationType: parentFilterOperationType
  });
  return buildRelationPredicate({
    rootIsRelationType: rootIsRelationType,
    parentFieldName: parentFieldName,
    isRelationType: isRelationType,
    isListFilterArgument: isListFilterArgument,
    isReflexiveRelationType: isReflexiveRelationType,
    isReflexiveTypeDirectedField: isReflexiveTypeDirectedField,
    thisType: thisType,
    relatedType: relatedType,
    schemaType: schemaType,
    innerSchemaType: innerSchemaType,
    fieldName: fieldName,
    filterOperationType: filterOperationType,
    filterValue: filterValue,
    filterParam: filterParam,
    schema: schema,
    parameterPath: parameterPath,
    nullFieldPredicate: nullFieldPredicate,
    pathExistencePredicate: pathExistencePredicate,
    predicateListVariable: predicateListVariable,
    rootPredicateFunction: rootPredicateFunction
  });
};

var decideRelationFilterMetadata = function decideRelationFilterMetadata(_ref53) {
  var fieldName = _ref53.fieldName,
      parentSchemaType = _ref53.parentSchemaType,
      schemaType = _ref53.schemaType,
      variableName = _ref53.variableName,
      innerSchemaType = _ref53.innerSchemaType,
      filterOperationField = _ref53.filterOperationField;
  var thisType = '';
  var relatedType = '';
  var isRelation = false;
  var isRelationType = false;
  var isRelationTypeNode = false;
  var isReflexiveRelationType = false;
  var isReflexiveTypeDirectedField = false; // @relation field directive

  var _relationDirective = (0, _utils.relationDirective)(schemaType, filterOperationField),
      relLabel = _relationDirective.name,
      relDirection = _relationDirective.direction; // @relation type directive on node type field


  var innerRelationTypeDirective = (0, _utils.getRelationTypeDirective)(innerSchemaType.astNode); // @relation type directive on this type; node type field on relation type
  // If there is no @relation directive on the schemaType, check the parentSchemaType
  // for the same directive obtained above when the relation type is first seen

  var relationTypeDirective = (0, _utils.getRelationTypeDirective)(schemaType.astNode);

  if (relLabel && relDirection) {
    isRelation = true;
    var typeVariables = (0, _utils.typeIdentifiers)(innerSchemaType);
    thisType = schemaType.name;
    relatedType = typeVariables.typeName;
  } else if (innerRelationTypeDirective) {
    isRelationType = true;
    thisType = innerRelationTypeDirective.from;
    relatedType = innerRelationTypeDirective.to;
    relLabel = innerRelationTypeDirective.name;
    relDirection = 'OUT';

    if (thisType === relatedType) {
      isReflexiveRelationType = true;
      var isReflexiveOutputType = (0, _query.isReflexiveRelationshipOutputType)({
        schemaType: schemaType
      });
      var directedNodeFieldNames = schemaType.astNode.fields.map(function (field) {
        return field.name.value;
      });
      var fromFieldName = directedNodeFieldNames[0];
      var toFieldName = directedNodeFieldNames[1];

      if (fieldName === 'from' || isReflexiveOutputType && fieldName === fromFieldName) {
        isReflexiveTypeDirectedField = true;
        relDirection = 'IN';
      } else if (fieldName === 'to' || isReflexiveOutputType && fieldName === toFieldName) {
        isReflexiveTypeDirectedField = true;
      }
    } else if (thisType !== relatedType) {
      var filteredType = schemaType && schemaType.name ? schemaType.name : '';

      if (filteredType === relatedType) {
        // then a filter argument for the incoming direction is being used
        // when querying the node type it goes out from
        var temp = thisType;
        thisType = relatedType;
        relatedType = temp;
        relDirection = 'IN';
      }
    }
  } else if (relationTypeDirective) {
    isRelationTypeNode = true;
    thisType = relationTypeDirective.from;
    relatedType = relationTypeDirective.to;
    relLabel = variableName;
    relDirection = 'OUT'; // if not a reflexive relationship type

    if (thisType !== relatedType) {
      // When buildFilterPredicates is used in buildRelationPredicate,
      // parentSchemaType is provided and used here to decide whether
      // to filter the incoming or outgoing node type
      var _filteredType = parentSchemaType && parentSchemaType.name ? parentSchemaType.name : ''; // the connecting node type field on a relationship type filter
      // may be incoming or outgoing; thisType could be .from or .to


      if (_filteredType === relatedType) {
        // then this filter argument is being used on a field of the node type
        // the relationship goes .to, so we need to filter for the node types
        // it comes .from
        var _temp = thisType;
        thisType = relatedType;
        relatedType = _temp;
        relDirection = 'IN';
      }
    }
  }

  return [thisType, relatedType, relLabel, relDirection, isRelation, isRelationType, isRelationTypeNode, isReflexiveRelationType, isReflexiveTypeDirectedField];
};

var buildRelationPredicate = function buildRelationPredicate(_ref54) {
  var rootIsRelationType = _ref54.rootIsRelationType,
      isRelationType = _ref54.isRelationType,
      isReflexiveRelationType = _ref54.isReflexiveRelationType,
      isReflexiveTypeDirectedField = _ref54.isReflexiveTypeDirectedField,
      thisType = _ref54.thisType,
      isListFilterArgument = _ref54.isListFilterArgument,
      relatedType = _ref54.relatedType,
      schemaType = _ref54.schemaType,
      innerSchemaType = _ref54.innerSchemaType,
      fieldName = _ref54.fieldName,
      filterOperationType = _ref54.filterOperationType,
      filterValue = _ref54.filterValue,
      filterParam = _ref54.filterParam,
      schema = _ref54.schema,
      parameterPath = _ref54.parameterPath,
      nullFieldPredicate = _ref54.nullFieldPredicate,
      pathExistencePredicate = _ref54.pathExistencePredicate,
      predicateListVariable = _ref54.predicateListVariable,
      rootPredicateFunction = _ref54.rootPredicateFunction;
  var isRelationList = filterOperationType === 'in' || filterOperationType === 'not_in';
  var relationVariable = buildRelationVariable(thisType, relatedType);
  var variableName = relatedType.toLowerCase();
  var listVariable = parameterPath;

  if (rootIsRelationType || isRelationType) {
    // change the variable to be used in filtering
    // to the appropriate relationship variable
    // ex: project -> person_filter_project
    variableName = relationVariable;
  }

  if (isRelationList) {
    // set the base list comprehension variable
    // to point at each array element instead
    // ex: $filter.company_in -> _company_in
    listVariable = "_".concat(fieldName); // set to list to enable null field
    // skipping for all child filters

    isListFilterArgument = true;
  }

  var predicates = buildFilterPredicates({
    parentFieldName: fieldName,
    parentSchemaType: schemaType,
    schemaType: innerSchemaType,
    variableName: variableName,
    isListFilterArgument: isListFilterArgument,
    listVariable: listVariable,
    filterOperationType: filterOperationType,
    isRelationType: isRelationType,
    filterValue: filterValue,
    filterParam: filterParam,
    schema: schema
  });

  if (isRelationList) {
    predicates = buildPredicateFunction({
      predicateListVariable: parameterPath,
      listElementVariable: listVariable,
      rootPredicateFunction: rootPredicateFunction,
      predicates: predicates
    });
    rootPredicateFunction = decidePredicateFunction({
      isRelationList: isRelationList
    });
  }

  if (isReflexiveRelationType && !isReflexiveTypeDirectedField) {
    // At reflexive relation type fields, sufficient predicates and values are already
    // obtained from the above call to the recursive buildFilterPredicates
    // ex: Person.knows, Person.knows_in, etc.
    // Note: Since only the internal 'from' and 'to' fields are translated for reflexive
    // relation types, their translations will use the fieldName and schema type name
    // of this field. See: the top of translateRelationFilter
    return predicates;
  }

  var listElementVariable = (0, _utils.safeVar)(variableName);
  return buildPredicateFunction({
    nullFieldPredicate: nullFieldPredicate,
    pathExistencePredicate: pathExistencePredicate,
    predicateListVariable: predicateListVariable,
    rootPredicateFunction: rootPredicateFunction,
    predicates: predicates,
    listElementVariable: listElementVariable
  });
};

var buildPredicateFunction = function buildPredicateFunction(_ref55) {
  var nullFieldPredicate = _ref55.nullFieldPredicate,
      pathExistencePredicate = _ref55.pathExistencePredicate,
      predicateListVariable = _ref55.predicateListVariable,
      rootPredicateFunction = _ref55.rootPredicateFunction,
      predicates = _ref55.predicates,
      listElementVariable = _ref55.listElementVariable;
  // https://neo4j.com/docs/cypher-manual/current/functions/predicate/
  return "".concat(nullFieldPredicate || '').concat(pathExistencePredicate ? "EXISTS(".concat(pathExistencePredicate, ") AND ") : '').concat(rootPredicateFunction, "(").concat(listElementVariable, " IN ").concat(predicateListVariable, " WHERE ").concat(predicates, ")");
};

var buildRelationVariable = function buildRelationVariable(thisType, relatedType) {
  return "".concat(thisType.toLowerCase(), "_filter_").concat(relatedType.toLowerCase());
};

var decidePredicateFunction = function decidePredicateFunction(_ref56) {
  var filterOperationField = _ref56.filterOperationField,
      filterOperationType = _ref56.filterOperationType,
      isRelationTypeNode = _ref56.isRelationTypeNode,
      isRelationList = _ref56.isRelationList;
  if (filterOperationField === 'AND') return 'ALL';else if (filterOperationField === 'OR') return 'ANY';else if (isRelationTypeNode) return 'ALL';else if (isRelationList) return 'ALL';else {
    switch (filterOperationType) {
      case 'not':
        return 'NONE';

      case 'in':
        return 'ANY';

      case 'not_in':
        return 'NONE';

      case 'some':
        return 'ANY';

      case 'every':
        return 'ALL';

      case 'none':
        return 'NONE';

      case 'single':
        return 'SINGLE';

      case 'distance':
      case 'distance_lt':
      case 'distance_lte':
      case 'distance_gt':
      case 'distance_gte':
        return 'distance';

      default:
        return 'ALL';
    }
  }
};

var buildRelatedTypeListComprehension = function buildRelatedTypeListComprehension(_ref57) {
  var rootIsRelationType = _ref57.rootIsRelationType,
      variableName = _ref57.variableName,
      thisType = _ref57.thisType,
      relatedType = _ref57.relatedType,
      relationLabel = _ref57.relationLabel,
      relationDirection = _ref57.relationDirection,
      isRelationTypeNode = _ref57.isRelationTypeNode,
      isRelationType = _ref57.isRelationType;
  var relationVariable = buildRelationVariable(thisType, relatedType);

  if (rootIsRelationType) {
    relationVariable = variableName;
  }

  var thisTypeVariable = !rootIsRelationType && !isRelationTypeNode ? (0, _utils.safeVar)((0, _utils.lowFirstLetter)(variableName)) : (0, _utils.safeVar)((0, _utils.lowFirstLetter)(thisType)); // prevents related node variable from
  // conflicting with parent variables

  var relatedTypeVariable = (0, _utils.safeVar)("_".concat(relatedType.toLowerCase())); // builds a path pattern within a list comprehension
  // that extracts related nodes

  return "[(".concat(thisTypeVariable, ")").concat(relationDirection === 'IN' ? '<' : '', "-[").concat(isRelationType ? (0, _utils.safeVar)("_".concat(relationVariable)) : isRelationTypeNode ? (0, _utils.safeVar)(relationVariable) : '').concat(!isRelationTypeNode ? ":".concat(relationLabel) : '', "]-").concat(relationDirection === 'OUT' ? '>' : '', "(").concat(isRelationType ? '' : relatedTypeVariable, ":").concat(relatedType, ") | ").concat(isRelationType ? (0, _utils.safeVar)("_".concat(relationVariable)) : relatedTypeVariable, "]");
};

var buildRelationExistencePath = function buildRelationExistencePath(fromVar, relLabel, relDirection, toType, isRelationTypeNode) {
  // because ALL(n IN [] WHERE n) currently returns true
  // an existence predicate is added to make sure a relationship exists
  // otherwise a node returns when it has 0 such relationships, since the
  // predicate function then evaluates an empty list
  var safeFromVar = (0, _utils.safeVar)(fromVar);
  return !isRelationTypeNode ? "(".concat(safeFromVar, ")").concat(relDirection === 'IN' ? '<' : '', "-[:").concat(relLabel, "]-").concat(relDirection === 'OUT' ? '>' : '', "(:").concat(toType, ")") : '';
};

var buildFilterPredicates = function buildFilterPredicates(_ref58) {
  var parentSchemaType = _ref58.parentSchemaType,
      parentFieldName = _ref58.parentFieldName,
      schemaType = _ref58.schemaType,
      variableName = _ref58.variableName,
      listVariable = _ref58.listVariable,
      filterValue = _ref58.filterValue,
      filterParam = _ref58.filterParam,
      schema = _ref58.schema,
      isListFilterArgument = _ref58.isListFilterArgument;
  var predicates = (0, _entries["default"])(filterValue).reduce(function (predicates, _ref59) {
    var _ref60 = (0, _slicedToArray2["default"])(_ref59, 2),
        name = _ref60[0],
        value = _ref60[1];

    name = deserializeFilterFieldName(name);
    var predicate = translateFilterArgument({
      parentParamPath: listVariable,
      fieldName: name,
      filterValue: value,
      paramValue: filterValue,
      parentFieldName: parentFieldName,
      parentSchemaType: parentSchemaType,
      isListFilterArgument: isListFilterArgument,
      variableName: variableName,
      filterParam: filterParam,
      schemaType: schemaType,
      schema: schema
    });

    if (predicate) {
      predicates.push("(".concat(predicate, ")"));
    }

    return predicates;
  }, []).join(' AND ');
  return predicates;
};

var decideNeo4jTypeFilter = function decideNeo4jTypeFilter(_ref61) {
  var filterOperationType = _ref61.filterOperationType,
      typeName = _ref61.typeName;
  var cypherTypeConstructor = '';
  var isTemporalFilter = false;
  var isSpatialFilter = false;

  if (!(0, _utils.isSpatialDistanceInputType)({
    filterOperationType: filterOperationType
  })) {
    switch (typeName) {
      case '_Neo4jTime':
        {
          isTemporalFilter = true;
          cypherTypeConstructor = 'time';
          break;
        }

      case '_Neo4jDate':
        {
          isTemporalFilter = true;
          cypherTypeConstructor = 'date';
          break;
        }

      case '_Neo4jDateTime':
        {
          isTemporalFilter = true;
          cypherTypeConstructor = 'datetime';
          break;
        }

      case '_Neo4jLocalTime':
        {
          isTemporalFilter = true;
          cypherTypeConstructor = 'localtime';
          break;
        }

      case '_Neo4jLocalDateTime':
        {
          isTemporalFilter = true;
          cypherTypeConstructor = 'localdatetime';
          break;
        }

      case '_Neo4jPoint':
        {
          isSpatialFilter = true;
          cypherTypeConstructor = 'point';
          break;
        }
    }
  }

  return [isTemporalFilter, isSpatialFilter, cypherTypeConstructor];
};

var translateNeo4jTypeFilter = function translateNeo4jTypeFilter(_ref62) {
  var typeName = _ref62.typeName,
      isRelationTypeNode = _ref62.isRelationTypeNode,
      filterValue = _ref62.filterValue,
      paramValue = _ref62.paramValue,
      variableName = _ref62.variableName,
      filterOperationField = _ref62.filterOperationField,
      filterOperationType = _ref62.filterOperationType,
      fieldName = _ref62.fieldName,
      filterParam = _ref62.filterParam,
      parameterPath = _ref62.parameterPath,
      parentParamPath = _ref62.parentParamPath,
      isListFilterArgument = _ref62.isListFilterArgument,
      isListFieldFilter = _ref62.isListFieldFilter,
      nullFieldPredicate = _ref62.nullFieldPredicate;
  var safeVariableName = (0, _utils.safeVar)(variableName);
  var propertyPath = "".concat(safeVariableName, ".").concat(filterOperationField);

  var _decideNeo4jTypeFilte = decideNeo4jTypeFilter({
    filterOperationType: filterOperationType,
    typeName: typeName
  }),
      _decideNeo4jTypeFilte2 = (0, _slicedToArray2["default"])(_decideNeo4jTypeFilte, 3),
      isTemporalFilter = _decideNeo4jTypeFilte2[0],
      isSpatialFilter = _decideNeo4jTypeFilte2[1],
      cypherTypeConstructor = _decideNeo4jTypeFilte2[2];

  if (isExistentialFilter(filterOperationType, filterValue)) {
    return translateNullFilter({
      filterOperationField: filterOperationField,
      filterOperationType: filterOperationType,
      propertyPath: propertyPath,
      filterParam: filterParam,
      parentParamPath: parentParamPath,
      isListFilterArgument: isListFilterArgument
    });
  }

  if (isListFieldFilter) {
    return translateListArgument({
      typeName: typeName,
      filterValue: paramValue[fieldName],
      filterOperationType: filterOperationType,
      listVariable: propertyPath,
      paramPath: parameterPath,
      isNeo4jType: true
    });
  }

  var rootPredicateFunction = decidePredicateFunction({
    isRelationTypeNode: isRelationTypeNode,
    filterOperationField: filterOperationField,
    filterOperationType: filterOperationType
  });
  return buildNeo4jTypePredicate({
    fieldName: fieldName,
    filterOperationField: filterOperationField,
    filterOperationType: filterOperationType,
    filterValue: filterValue,
    parameterPath: parameterPath,
    variableName: variableName,
    nullFieldPredicate: nullFieldPredicate,
    rootPredicateFunction: rootPredicateFunction,
    cypherTypeConstructor: cypherTypeConstructor,
    parentIsListArgument: isListFilterArgument,
    isTemporalFilter: isTemporalFilter,
    isSpatialFilter: isSpatialFilter
  });
};

var buildNeo4jTypeTranslation = function buildNeo4jTypeTranslation(_ref63) {
  var filterOperationType = _ref63.filterOperationType,
      listVariable = _ref63.listVariable,
      isTemporalFilter = _ref63.isTemporalFilter,
      isSpatialFilter = _ref63.isSpatialFilter,
      parentIsListArgument = _ref63.parentIsListArgument,
      isListFilterArgument = _ref63.isListFilterArgument,
      filterValue = _ref63.filterValue,
      nullFieldPredicate = _ref63.nullFieldPredicate,
      propertyPath = _ref63.propertyPath,
      cypherTypeConstructor = _ref63.cypherTypeConstructor,
      operatorExpression = _ref63.operatorExpression,
      parameterPath = _ref63.parameterPath,
      rootPredicateFunction = _ref63.rootPredicateFunction;

  if ((0, _utils.isSpatialDistanceInputType)({
    filterOperationType: filterOperationType
  })) {
    listVariable = "".concat(listVariable, ".distance");
  }

  var translation = '';
  var isIdentityFilter = !filterOperationType || filterOperationType === 'not';

  if ((isTemporalFilter || isSpatialFilter) && (isIdentityFilter || isListFilterArgument || parentIsListArgument)) {
    var generalizedComparisonPredicates = (0, _keys["default"])(filterValue).map(function (filterName) {
      var isTemporalFormatted = isTemporalFilter && filterName === 'formatted';

      if (nullFieldPredicate || isListFilterArgument) {
        nullFieldPredicate = "".concat(listVariable, ".").concat(filterName, " IS NULL OR ");
      }

      if (isTemporalFormatted) {
        return "(".concat(nullFieldPredicate).concat(propertyPath, " = ").concat(cypherTypeConstructor, "(").concat(listVariable, ".").concat(filterName, "))");
      } else {
        return "(".concat(nullFieldPredicate).concat(propertyPath, ".").concat(filterName, " = ").concat(listVariable, ".").concat(filterName, ")");
      }
    });
    translation = "(".concat(generalizedComparisonPredicates.join(' AND '), ")");

    if (filterOperationType === 'not') {
      translation = "NOT".concat(translation);
    }
  } else {
    translation = "(".concat(nullFieldPredicate).concat(operatorExpression, " ").concat(cypherTypeConstructor, "(").concat(listVariable, "))");
  }

  if (isListFilterArgument) {
    translation = buildPredicateFunction({
      predicateListVariable: parameterPath,
      listElementVariable: listVariable,
      rootPredicateFunction: rootPredicateFunction,
      predicates: translation
    });
  }

  return translation;
};

var buildNeo4jTypePredicate = function buildNeo4jTypePredicate(_ref64) {
  var fieldName = _ref64.fieldName,
      filterOperationField = _ref64.filterOperationField,
      filterOperationType = _ref64.filterOperationType,
      filterValue = _ref64.filterValue,
      parameterPath = _ref64.parameterPath,
      variableName = _ref64.variableName,
      nullFieldPredicate = _ref64.nullFieldPredicate,
      rootPredicateFunction = _ref64.rootPredicateFunction,
      cypherTypeConstructor = _ref64.cypherTypeConstructor,
      parentIsListArgument = _ref64.parentIsListArgument,
      isTemporalFilter = _ref64.isTemporalFilter,
      isSpatialFilter = _ref64.isSpatialFilter;
  var isListFilterArgument = filterOperationType === 'in' || filterOperationType === 'not_in'; // ex: project -> person_filter_project

  var listVariable = parameterPath; // ex: $filter.datetime_in -> _datetime_in

  if (isListFilterArgument) listVariable = "_".concat(fieldName);
  var safeVariableName = (0, _utils.safeVar)(variableName);
  var propertyPath = "".concat(safeVariableName, ".").concat(filterOperationField);
  var operatorExpression = buildOperatorExpression({
    filterOperationType: filterOperationType,
    propertyPath: propertyPath,
    isListFilterArgument: isListFilterArgument,
    parameterPath: parameterPath
  });
  var translation = buildNeo4jTypeTranslation({
    filterOperationType: filterOperationType,
    listVariable: listVariable,
    isTemporalFilter: isTemporalFilter,
    isSpatialFilter: isSpatialFilter,
    parentIsListArgument: parentIsListArgument,
    isListFilterArgument: isListFilterArgument,
    filterValue: filterValue,
    nullFieldPredicate: nullFieldPredicate,
    propertyPath: propertyPath,
    cypherTypeConstructor: cypherTypeConstructor,
    operatorExpression: operatorExpression,
    parameterPath: parameterPath,
    rootPredicateFunction: rootPredicateFunction
  });
  return translation;
};

var translateListArguments = function translateListArguments(_ref65) {
  var schemaType = _ref65.schemaType,
      fieldArgs = _ref65.fieldArgs,
      filterParams = _ref65.filterParams,
      safeVariableName = _ref65.safeVariableName,
      resolveInfo = _ref65.resolveInfo;
  var arrayPredicates = [];
  fieldArgs.forEach(function (fieldArgument) {
    var argumentName = fieldArgument.name.value;
    var param = filterParams[argumentName];
    var isGeneratedListArgument = argumentName === _inputValues.OrderingArgument.ORDER_BY;
    var usesArgument = param !== undefined;

    if (usesArgument && (0, _fields.isListTypeField)({
      field: fieldArgument
    }) && !isGeneratedListArgument) {
      var filterValue = param.value !== undefined ? param.value : param;
      var indexedParam = filterParams[argumentName];
      var paramIndex = indexedParam.index;
      var field = schemaType.getFields()[argumentName];
      var listVariable = "".concat(safeVariableName, ".").concat((0, _utils.safeVar)(argumentName));
      var paramPath = "$".concat(argumentName); // Possibly use the already generated index used when naming nested parameters

      if (paramIndex >= 1) paramPath = "$".concat(paramIndex, "_").concat(argumentName);
      var translation = '';

      if (field) {
        // list argument matches the name of a field
        var type = fieldArgument.type;
        var unwrappedType = (0, _fields.unwrapNamedType)({
          type: type
        });
        var typeName = unwrappedType.name;
        var fieldType = resolveInfo.schema.getType(typeName);

        var _isNeo4jType = (0, _inputValues.isNeo4jTypeArgument)({
          fieldArgument: fieldArgument
        });

        if ((0, _graphql.isScalarType)(fieldType) || (0, _graphql.isEnumType)(fieldType) || _isNeo4jType) {
          var whereClause = '';

          if ((0, _fields.isListTypeField)({
            field: field.astNode
          }) && (0, _isArray["default"])(filterValue)) {
            // The matching field is also a list
            translation = translateListArgument({
              typeName: typeName,
              filterValue: filterValue,
              isNeo4jType: _isNeo4jType,
              listVariable: listVariable,
              paramPath: paramPath
            });
          } else {
            // the matching field is not also a list
            if (_isNeo4jType) {
              whereClause = translateCustomTypeListArgument({
                typeName: typeName,
                propertyVariable: listVariable,
                filterValue: filterValue
              });
              translation = cypherList({
                listVariable: paramPath,
                whereClause: whereClause
              });
            } else translation = cypherList({
              variable: listVariable,
              listVariable: paramPath
            });
          }
        }
      } else {
        // list argument does not match a field on the queried type
        translation = cypherList({
          variable: listVariable,
          listVariable: paramPath
        });
      }

      arrayPredicates.push(translation);
    }
  });
  return arrayPredicates;
};

exports.translateListArguments = translateListArguments;

var translateListArgument = function translateListArgument(_ref66) {
  var typeName = _ref66.typeName,
      filterValue = _ref66.filterValue,
      filterOperationType = _ref66.filterOperationType,
      isNeo4jType = _ref66.isNeo4jType,
      listVariable = _ref66.listVariable,
      paramPath = _ref66.paramPath;
  var parameterPath = 'value';
  var propertyPath = 'prop';
  var whereClause = '';
  var translation = '';

  if (filterValue.length) {
    // When a list is evaludated as a predicate, an empty list is false
    // So we use list comprehensions to filter list properties
    if (isNeo4jType) {
      // The deeper scope of custom neo4j temporal and spatial types
      // require another layer of iteration
      whereClause = translateCustomTypeListArgument({
        typeName: typeName,
        filterValue: filterValue,
        filterOperationType: filterOperationType
      });

      if (filterOperationType) {
        if (filterOperationType === 'not') {
          var propertyList = cypherList({
            variable: propertyPath,
            listVariable: listVariable
          });
          whereClause = "[".concat(propertyList, " WHERE ").concat(whereClause, "]");
        } else {
          whereClause = cypherList({
            variable: propertyPath,
            listVariable: listVariable,
            whereClause: whereClause
          });
        }
      } else {
        whereClause = cypherList({
          variable: propertyPath,
          listVariable: listVariable,
          whereClause: whereClause
        });
      }

      if (filterOperationType === 'not') {
        var parameterList = cypherList({
          listVariable: paramPath
        });
        translation = "NONE(".concat(parameterList, " WHERE ").concat(whereClause, ")");
      } else {
        translation = cypherList({
          listVariable: paramPath,
          whereClause: whereClause
        });
      }
    } else {
      if (filterOperationType) {
        var innerOperation = filterOperationType; // negated list filters are wrapped with NONE rather
        // than using NOT on the list comprehension predicate

        if (innerOperation === 'not') innerOperation = '';
        var operatorExpression = buildOperatorExpression({
          filterOperationType: innerOperation,
          propertyPath: propertyPath,
          parameterPath: parameterPath
        });
        whereClause = "".concat(operatorExpression, " ").concat(parameterPath);
        whereClause = cypherList({
          variable: propertyPath,
          listVariable: listVariable,
          whereClause: whereClause
        });
      } else {
        whereClause = cypherList({
          listVariable: listVariable
        });
      }

      if (filterOperationType === 'not') {
        var _propertyList = cypherList({
          listVariable: paramPath
        });

        translation = "NONE(".concat(_propertyList, " WHERE ").concat(whereClause, ")");
      } else {
        translation = cypherList({
          listVariable: paramPath,
          whereClause: whereClause
        });
      }
    }
  } else {
    var sizeOperator = "=";
    if (filterOperationType === 'not') sizeOperator = ">";
    translation = "(size(".concat(listVariable, ") ").concat(sizeOperator, " 0)");
  }

  return translation;
};

var translateCustomTypeListArgument = function translateCustomTypeListArgument(_ref67) {
  var typeName = _ref67.typeName,
      _ref67$variable = _ref67.variable,
      variable = _ref67$variable === void 0 ? 'value' : _ref67$variable,
      _ref67$propertyVariab = _ref67.propertyVariable,
      propertyVariable = _ref67$propertyVariab === void 0 ? 'prop' : _ref67$propertyVariab,
      _ref67$filterValue = _ref67.filterValue,
      filterValue = _ref67$filterValue === void 0 ? [] : _ref67$filterValue,
      _ref67$filterOperatio = _ref67.filterOperationType,
      filterOperationType = _ref67$filterOperatio === void 0 ? '' : _ref67$filterOperatio;
  var translation = '';

  if ((0, _utils.isSpatialDistanceInputType)({
    filterOperationType: filterOperationType
  })) {
    // exception to ignore the inner fields of the distance filter input type
    var operatorExpression = buildOperatorExpression({
      filterOperationType: filterOperationType,
      propertyPath: propertyVariable,
      parameterPath: variable
    });
    translation = "(".concat(operatorExpression).concat(variable, ".distance)");
  } else {
    // map all unique inner field selections of the given custom property type
    var uniqueFilterMap = filterValue.reduce(function (booleanMap, filter) {
      (0, _keys["default"])(filter).forEach(function (key) {
        booleanMap[key] = true;
      });
      return booleanMap;
    }, {}); // Builds a single predicate used for comparing a list of a custom type (DateTime, etc.)
    // to a matching list property containing values of that type.

    translation = (0, _keys["default"])(uniqueFilterMap).map(function (filterName) {
      var isTemporalFormatted = filterName === 'formatted'; // short-circuit evaluate to let differences in selected fields pass through

      var nullFieldPredicate = "".concat(variable, ".").concat(filterName, " IS NULL OR ");
      var propertyPath = ''; // the path to the argument value of to compare against, e.g. value.year, value.x

      var parameterPath = "".concat(variable, ".").concat(filterName);

      if (isTemporalFormatted) {
        propertyPath = "".concat(propertyVariable);
        var typeConstructor = (0, _utils.decideNeo4jTypeConstructor)(typeName);

        if (!typeConstructor) {
          // list filter arguments pass the type definition corresponding to
          // generated input types, _Neo4jDateTime vs _Neo4jDateTimeInput
          // further generalization of constructor selection can clean this up
          var _decideNeo4jTypeFilte3 = decideNeo4jTypeFilter({
            filterOperationType: filterOperationType,
            typeName: typeName
          }),
              _decideNeo4jTypeFilte4 = (0, _slicedToArray2["default"])(_decideNeo4jTypeFilte3, 3),
              isTemporalFilter = _decideNeo4jTypeFilte4[0],
              isSpatialFilter = _decideNeo4jTypeFilte4[1],
              cypherTypeConstructor = _decideNeo4jTypeFilte4[2];

          typeConstructor = cypherTypeConstructor;
        }

        if (typeConstructor) {
          parameterPath = "".concat(typeConstructor, "(").concat(parameterPath, ")");
        }
      } else {
        // the path to an inner field of the matching property
        // being compared, e.g. prop.year, prop.x
        propertyPath = "".concat(propertyVariable, ".").concat(filterName);
      }

      if (filterOperationType === 'not') filterOperationType = ''; // builds the left hand side of the comparison predicate for list filters

      var operatorExpression = buildOperatorExpression({
        filterOperationType: filterOperationType,
        propertyPath: propertyPath,
        parameterPath: parameterPath
      }); // default comparison operator is =

      return "(".concat(nullFieldPredicate).concat(operatorExpression, " ").concat(parameterPath, ")");
    }).join(' AND ');
  }

  return "(".concat(translation, ")");
};

var cypherList = function cypherList(_ref68) {
  var _ref68$variable = _ref68.variable,
      variable = _ref68$variable === void 0 ? 'value' : _ref68$variable,
      _ref68$listVariable = _ref68.listVariable,
      listVariable = _ref68$listVariable === void 0 ? '' : _ref68$listVariable,
      _ref68$whereClause = _ref68.whereClause,
      whereClause = _ref68$whereClause === void 0 ? '' : _ref68$whereClause,
      _ref68$filterClause = _ref68.filterClause,
      filterClause = _ref68$filterClause === void 0 ? '' : _ref68$filterClause;

  if (whereClause || filterClause) {
    whereClause = whereClause ? " WHERE ".concat(whereClause) : '';
    filterClause = filterClause ? " ".concat(filterClause) : '';
    listVariable = "".concat(listVariable).concat(whereClause).concat(filterClause);
    return "[".concat(variable, " IN ").concat(listVariable, "]");
  }

  return "".concat(variable, " IN ").concat(listVariable);
};