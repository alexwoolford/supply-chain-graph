"use strict";

var _interopRequireDefault = require("@babel/runtime-corejs2/helpers/interopRequireDefault");

var _Object$defineProperty = require("@babel/runtime-corejs2/core-js/object/define-property");

var _Object$defineProperties = require("@babel/runtime-corejs2/core-js/object/define-properties");

var _Object$getOwnPropertyDescriptors = require("@babel/runtime-corejs2/core-js/object/get-own-property-descriptors");

var _Object$getOwnPropertyDescriptor = require("@babel/runtime-corejs2/core-js/object/get-own-property-descriptor");

var _Object$getOwnPropertySymbols = require("@babel/runtime-corejs2/core-js/object/get-own-property-symbols");

var _Object$keys2 = require("@babel/runtime-corejs2/core-js/object/keys");

_Object$defineProperty(exports, "__esModule", {
  value: true
});

exports.parseArgs = parseArgs;
exports.extractQueryResult = extractQueryResult;
exports.typeIdentifiers = typeIdentifiers;
exports.cypherDirectiveArgs = cypherDirectiveArgs;
exports._isNamedMutation = _isNamedMutation;
exports.isMutation = isMutation;
exports.isGraphqlScalarType = isGraphqlScalarType;
exports.isGraphqlObjectType = isGraphqlObjectType;
exports.isGraphqlInterfaceType = isGraphqlInterfaceType;
exports.isGraphqlUnionType = isGraphqlUnionType;
exports.isArrayType = isArrayType;
exports.lowFirstLetter = lowFirstLetter;
exports.innerType = innerType;
exports.filtersFromSelections = filtersFromSelections;
exports.getFilterParams = getFilterParams;
exports.innerFilterParams = innerFilterParams;
exports.paramsToString = paramsToString;
exports.computeSkipLimit = computeSkipLimit;
exports.getInterfaceDerivedTypeNames = exports.removeIgnoredFields = exports.getNeo4jTypeArguments = exports.neo4jTypePredicateClauses = exports.decideNeo4jTypeConstructor = exports.isSpatialDistanceInputType = exports.isSpatialInputType = exports.isSpatialField = exports.isSpatialType = exports.isTemporalInputType = exports.isTemporalField = exports.isTemporalType = exports.isNeo4jTypeInput = exports.isNeo4jType = exports.splitSelectionParameters = exports.filterNullParams = exports.getPayloadSelections = exports.getOuterSkipLimit = exports.initializeMutationParams = exports.decideNestedVariableName = exports.safeLabel = exports.safeVar = exports.getRelationTypeDirective = exports.getMutationCypherDirective = exports.getQueryCypherDirective = exports.getFieldDirective = exports.getTypeDirective = exports.relationDirective = exports.cypherDirective = exports.buildCypherParameters = exports.getAdditionalLabels = exports.getMutationArguments = exports.getQueryArguments = exports.setPrimaryKeyValue = exports.computeOrderBy = exports.isRelationTypePayload = exports.isNodeType = exports.isMergeMutation = exports.isRemoveMutation = exports.isDeleteMutation = exports.isUpdateMutation = exports.isAddMutation = exports.isCreateMutation = exports.parseDirectiveSdl = void 0;

var _values = _interopRequireDefault(require("@babel/runtime-corejs2/core-js/object/values"));

var _assign = _interopRequireDefault(require("@babel/runtime-corejs2/core-js/object/assign"));

var _toConsumableArray2 = _interopRequireDefault(require("@babel/runtime-corejs2/helpers/toConsumableArray"));

var _slicedToArray2 = _interopRequireDefault(require("@babel/runtime-corejs2/helpers/slicedToArray"));

var _entries = _interopRequireDefault(require("@babel/runtime-corejs2/core-js/object/entries"));

var _stringify = _interopRequireDefault(require("@babel/runtime-corejs2/core-js/json/stringify"));

var _keys = _interopRequireDefault(require("@babel/runtime-corejs2/core-js/object/keys"));

var _defineProperty2 = _interopRequireDefault(require("@babel/runtime-corejs2/helpers/defineProperty"));

var _isArray = _interopRequireDefault(require("@babel/runtime-corejs2/core-js/array/is-array"));

var _parseFloat2 = _interopRequireDefault(require("@babel/runtime-corejs2/core-js/parse-float"));

var _parseInt2 = _interopRequireDefault(require("@babel/runtime-corejs2/core-js/parse-int"));

var _graphql = require("graphql");

var _fields = require("./augment/fields");

var _types = require("./augment/types/types");

var _query = require("./augment/types/relationship/query");

var _federation = require("./federation");

var _neo4jDriver = _interopRequireDefault(require("neo4j-driver"));

var _lodash = _interopRequireDefault(require("lodash"));

function ownKeys(object, enumerableOnly) { var keys = _Object$keys2(object); if (_Object$getOwnPropertySymbols) { var symbols = _Object$getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return _Object$getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }

function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(Object(source), true).forEach(function (key) { (0, _defineProperty2["default"])(target, key, source[key]); }); } else if (_Object$getOwnPropertyDescriptors) { _Object$defineProperties(target, _Object$getOwnPropertyDescriptors(source)); } else { ownKeys(Object(source)).forEach(function (key) { _Object$defineProperty(target, key, _Object$getOwnPropertyDescriptor(source, key)); }); } } return target; }

function parseArg(arg, variableValues) {
  switch (arg.value.kind) {
    case 'IntValue':
      {
        return (0, _parseInt2["default"])(arg.value.value);
      }

    case 'FloatValue':
      {
        return (0, _parseFloat2["default"])(arg.value.value);
      }

    case 'Variable':
      {
        return variableValues[arg.value.name.value];
      }

    case 'ObjectValue':
      {
        return parseArgs(arg.value.fields, variableValues);
      }

    case 'ListValue':
      {
        return _lodash["default"].map(arg.value.values, function (value) {
          return parseArg({
            value: value
          }, variableValues);
        });
      }

    case 'NullValue':
      {
        return null;
      }

    default:
      {
        return arg.value.value;
      }
  }
}

function parseArgs(args, variableValues) {
  if (!args || args.length === 0) {
    return {};
  }

  return args.reduce(function (acc, arg) {
    acc[arg.name.value] = parseArg(arg, variableValues);
    return acc;
  }, {});
}

var parseDirectiveSdl = function parseDirectiveSdl(sdl) {
  return sdl ? (0, _graphql.parse)("type Type { field: String ".concat(sdl, " }")).definitions[0].fields[0].directives[0] : {};
};

exports.parseDirectiveSdl = parseDirectiveSdl;

function extractQueryResult(_ref, returnType) {
  var records = _ref.records;

  var _typeIdentifiers = typeIdentifiers(returnType),
      variableName = _typeIdentifiers.variableName;

  var result = null;

  if (isArrayType(returnType)) {
    result = records.map(function (record) {
      return record.get(variableName);
    });
  } else if (records.length) {
    // could be object or scalar
    result = records[0].get(variableName);
    result = (0, _isArray["default"])(result) ? result[0] : result;
  } // handle Integer fields


  result = _lodash["default"].cloneDeepWith(result, function (field) {
    if (_neo4jDriver["default"].isInt(field)) {
      // See: https://neo4j.com/docs/api/javascript-driver/current/class/src/v1/integer.js~Integer.html
      return field.inSafeRange() ? field.toNumber() : field.toString();
    }
  });
  return result;
}

function typeIdentifiers(returnType) {
  var typeName = innerType(returnType).toString();
  return {
    variableName: lowFirstLetter(typeName),
    typeName: typeName
  };
}

function getDefaultArguments(fieldName, schemaType) {
  // get default arguments for this field from schema
  try {
    return schemaType._fields[fieldName].args.reduce(function (acc, arg) {
      acc[arg.name] = arg.defaultValue;
      return acc;
    }, {});
  } catch (err) {
    return {};
  }
}

function cypherDirectiveArgs(variable, headSelection, cypherParams, schemaType, resolveInfo, paramIndex, isFederatedOperation, context) {
  // Get any default arguments or an empty object
  var defaultArgs = getDefaultArguments(headSelection.name.value, schemaType); // Set the $this parameter by default

  var args = ["this: ".concat(variable)]; // If cypherParams are provided, add the parameter

  if (cypherParams) args.push("cypherParams: $cypherParams");
  var federatedOperationParams = {};

  if (isFederatedOperation) {
    var _getFederatedOperatio = (0, _federation.getFederatedOperationData)({
      context: context
    }),
        requiredData = _getFederatedOperatio.requiredData,
        params = _getFederatedOperatio.params;

    federatedOperationParams = _objectSpread(_objectSpread({}, requiredData), params);
    (0, _keys["default"])(federatedOperationParams).forEach(function (name) {
      args.push("".concat(name, ": $").concat(name));
    });
  } // Parse field argument values


  var queryArgs = parseArgs(headSelection.arguments, resolveInfo.variableValues); // Add arguments that have default values, if no value is provided

  (0, _keys["default"])(defaultArgs).forEach(function (e) {
    // Use only if default value exists and no value has been provided
    if (defaultArgs[e] !== undefined && queryArgs[e] === undefined && federatedOperationParams[e] === undefined) {
      // Values are inlined
      var inlineDefaultValue = (0, _stringify["default"])(defaultArgs[e]);
      args.push("".concat(e, ": ").concat(inlineDefaultValue));
    }
  }); // Add arguments that have provided values

  (0, _keys["default"])(queryArgs).forEach(function (e) {
    if (queryArgs[e] !== undefined && federatedOperationParams[e] === undefined) {
      // Use only if value exists
      args.push("".concat(e, ": $").concat(paramIndex, "_").concat(e));
    }
  }); // Return the comma separated join of all param
  // strings, adding a comma to match current test formats

  return args.join(', ');
}

function _isNamedMutation(name) {
  return function (resolveInfo) {
    return isMutation(resolveInfo) && resolveInfo.fieldName.split(/(?=[A-Z])/)[0].toLowerCase() === name.toLowerCase();
  };
}

var isCreateMutation = _isNamedMutation('create');

exports.isCreateMutation = isCreateMutation;

var isAddMutation = _isNamedMutation('add');

exports.isAddMutation = isAddMutation;

var isUpdateMutation = _isNamedMutation('update');

exports.isUpdateMutation = isUpdateMutation;

var isDeleteMutation = _isNamedMutation('delete');

exports.isDeleteMutation = isDeleteMutation;

var isRemoveMutation = _isNamedMutation('remove');

exports.isRemoveMutation = isRemoveMutation;

var isMergeMutation = _isNamedMutation('merge');

exports.isMergeMutation = isMergeMutation;

var isRelationshipUpdateMutation = function isRelationshipUpdateMutation(_ref2) {
  var resolveInfo = _ref2.resolveInfo,
      mutationMeta = _ref2.mutationMeta;
  return isUpdateMutation(resolveInfo) && !mutationMeta;
};

var isRelationshipMergeMutation = function isRelationshipMergeMutation(_ref3) {
  var resolveInfo = _ref3.resolveInfo,
      mutationMeta = _ref3.mutationMeta;
  return isMergeMutation(resolveInfo) && !mutationMeta;
};

function isMutation(resolveInfo) {
  return resolveInfo.operation.operation === 'mutation';
}

function isGraphqlScalarType(type) {
  return type.constructor.name === 'GraphQLScalarType' || type.constructor.name === 'GraphQLEnumType';
}

function isGraphqlObjectType(type) {
  return type.constructor.name === 'GraphQLObjectType';
}

function isGraphqlInterfaceType(type) {
  return type.constructor.name === 'GraphQLInterfaceType';
}

function isGraphqlUnionType(type) {
  return type.constructor.name === 'GraphQLUnionType';
}

function isArrayType(type) {
  return type ? type.toString().startsWith('[') : false;
}

var isNodeType = function isNodeType(astNode) {
  return astNode && // must be graphql object type
  astNode.kind === 'ObjectTypeDefinition' && // is not Query or Mutation type
  astNode.name.value !== 'Query' && astNode.name.value !== 'Mutation' && // does not have relation type directive
  getTypeDirective(astNode, 'relation') === undefined && // does not have from and to fields; not relation type
  astNode.fields && astNode.fields.find(function (e) {
    return e.name.value === 'from';
  }) === undefined && astNode.fields.find(function (e) {
    return e.name.value === 'to';
  }) === undefined;
};

exports.isNodeType = isNodeType;

var isRelationTypePayload = function isRelationTypePayload(schemaType) {
  var astNode = schemaType ? schemaType.astNode : undefined;
  var directive = astNode ? getRelationTypeDirective(astNode) : undefined;
  return astNode && astNode.fields && directive ? astNode.fields.find(function (e) {
    return e.name.value === directive.from || e.name.value === directive.to;
  }) : undefined;
};

exports.isRelationTypePayload = isRelationTypePayload;

function lowFirstLetter(word) {
  return word.charAt(0).toLowerCase() + word.slice(1);
}

function innerType(type) {
  return type.ofType ? innerType(type.ofType) : type;
}

function filtersFromSelections(selections, variableValues) {
  if (selections && selections.length && selections[0].arguments && selections[0].arguments.length) {
    return selections[0].arguments.reduce(function (result, x) {
      (result[x.name.value] = argumentValue(selections[0], x.name.value, variableValues)) || x.value.value;
      return result;
    }, {});
  }

  return {};
}

function getFilterParams(filters, index) {
  return (0, _entries["default"])(filters).reduce(function (result, _ref4) {
    var _ref5 = (0, _slicedToArray2["default"])(_ref4, 2),
        key = _ref5[0],
        value = _ref5[1];

    result[key] = index ? {
      value: value,
      index: index
    } : value;
    return result;
  }, {});
}

function innerFilterParams(filters, neo4jTypeArgs, paramKey, cypherDirective) {
  var temporalArgNames = neo4jTypeArgs ? neo4jTypeArgs.reduce(function (acc, t) {
    acc.push(t.name.value);
    return acc;
  }, []) : []; // don't exclude first, offset, orderBy args for cypher directives

  var excludedKeys = cypherDirective ? [] : ['first', 'offset', 'orderBy', 'filter'];
  return (0, _keys["default"])(filters).length > 0 ? (0, _entries["default"])(filters) // exclude temporal arguments
  .filter(function (_ref6) {
    var _ref7 = (0, _slicedToArray2["default"])(_ref6, 1),
        key = _ref7[0];

    return ![].concat(excludedKeys, (0, _toConsumableArray2["default"])(temporalArgNames)).includes(key);
  }).map(function (_ref8) {
    var _ref9 = (0, _slicedToArray2["default"])(_ref8, 2),
        key = _ref9[0],
        value = _ref9[1];

    return {
      key: key,
      paramKey: paramKey,
      value: value
    };
  }) : [];
}

function paramsToString(params, cypherParams) {
  if (params.length > 0) {
    var strings = _lodash["default"].map(params, function (param) {
      return "".concat(param.key, ":").concat(param.paramKey ? "$".concat(param.paramKey, ".") : '$').concat(!param.value || typeof param.value.index === 'undefined' ? param.key : "".concat(param.value.index, "_").concat(param.key));
    });

    return "{".concat(strings.join(', ')).concat(cypherParams ? ", cypherParams: $cypherParams}" : '}');
  }

  return '';
}

function computeSkipLimit(selection, variableValues) {
  var first = argumentValue(selection, 'first', variableValues);
  var offset = argumentValue(selection, 'offset', variableValues);
  if (first === null && offset === null) return '';
  if (offset === null) return "[..".concat(first, "]");
  if (first === null) return "[".concat(offset, "..]");
  return "[".concat(offset, "..").concat((0, _parseInt2["default"])(offset) + (0, _parseInt2["default"])(first), "]");
}

function splitOrderByArg(orderByVar) {
  var splitIndex = orderByVar.lastIndexOf('_');
  var order = orderByVar.substring(splitIndex + 1);
  var orderBy = orderByVar.substring(0, splitIndex);
  return {
    orderBy: orderBy,
    order: order
  };
}

function orderByStatement(resolveInfo, _ref10) {
  var orderBy = _ref10.orderBy,
      order = _ref10.order;

  var _typeIdentifiers2 = typeIdentifiers(resolveInfo.returnType),
      variableName = _typeIdentifiers2.variableName;

  return " ".concat(variableName, ".").concat(orderBy, " ").concat(order === 'asc' ? 'ASC' : 'DESC', " ");
}

var computeOrderBy = function computeOrderBy(resolveInfo, schemaType) {
  var selection = resolveInfo.operation.selectionSet.selections[0];
  var orderByArgs = argumentValue(selection, 'orderBy', resolveInfo.variableValues);

  if (orderByArgs == undefined) {
    return {
      cypherPart: '',
      optimization: {
        earlyOrderBy: false
      }
    };
  }

  var orderByArray = (0, _isArray["default"])(orderByArgs) ? orderByArgs : [orderByArgs];
  var optimization = {
    earlyOrderBy: true
  };
  var orderByStatements = orderByArray.map(function (orderByVar) {
    var _splitOrderByArg = splitOrderByArg(orderByVar),
        orderBy = _splitOrderByArg.orderBy,
        order = _splitOrderByArg.order;

    var hasNoCypherDirective = _lodash["default"].isEmpty(cypherDirective(schemaType, orderBy));

    optimization.earlyOrderBy = optimization.earlyOrderBy && hasNoCypherDirective;
    return orderByStatement(resolveInfo, {
      orderBy: orderBy,
      order: order
    });
  });
  return {
    cypherPart: " ORDER BY".concat(orderByStatements.join(',')),
    optimization: optimization
  };
};

exports.computeOrderBy = computeOrderBy;

var setPrimaryKeyValue = function setPrimaryKeyValue(_ref11) {
  var _ref11$args = _ref11.args,
      args = _ref11$args === void 0 ? [] : _ref11$args,
      _ref11$statements = _ref11.statements,
      statements = _ref11$statements === void 0 ? [] : _ref11$statements,
      params = _ref11.params,
      primaryKey = _ref11.primaryKey;

  if (primaryKey) {
    var fieldName = primaryKey.name.value;
    var primaryKeyArgument = args.find(function (arg) {
      return arg.name.value === fieldName;
    });

    if (primaryKeyArgument) {
      var type = primaryKeyArgument.type;
      var unwrappedType = (0, _fields.unwrapNamedType)({
        type: type
      });
      var isIDTypePrimaryKey = unwrappedType.name === 'ID';

      if (isIDTypePrimaryKey && params[fieldName] === undefined) {
        statements.push("".concat(fieldName, ": apoc.create.uuid()"));
      }
    }
  }

  return statements;
};

exports.setPrimaryKeyValue = setPrimaryKeyValue;

var getQueryArguments = function getQueryArguments(resolveInfo, isFederatedOperation) {
  if (resolveInfo.fieldName === '_entities' || isFederatedOperation) return [];
  return resolveInfo.schema.getQueryType().getFields()[resolveInfo.fieldName].astNode.arguments;
};

exports.getQueryArguments = getQueryArguments;

var getMutationArguments = function getMutationArguments(resolveInfo) {
  return resolveInfo.schema.getMutationType().getFields()[resolveInfo.fieldName].astNode.arguments;
};

exports.getMutationArguments = getMutationArguments;

var getAdditionalLabels = function getAdditionalLabels(schemaType, cypherParams) {
  var labelDirective = getTypeDirective(schemaType.astNode, 'additionalLabels');

  var _ref12 = labelDirective ? parseArgs(labelDirective.arguments) : {
    labels: []
  },
      rawLabels = _ref12.labels;

  var parsedLabels = rawLabels.map(function (label) {
    return _lodash["default"].template(label, {
      variable: '$cypherParams'
    })(cypherParams);
  });
  return parsedLabels;
};

exports.getAdditionalLabels = getAdditionalLabels;

var buildCypherParameters = function buildCypherParameters(_ref13) {
  var args = _ref13.args,
      _ref13$statements = _ref13.statements,
      statements = _ref13$statements === void 0 ? [] : _ref13$statements,
      params = _ref13.params,
      paramKey = _ref13.paramKey,
      typeMap = _ref13.typeMap;
  var dataParams = paramKey ? params[paramKey] : params;
  var paramKeys = dataParams ? (0, _keys["default"])(dataParams) : [];

  if (args) {
    statements = paramKeys.reduce(function (paramStatements, paramName) {
      var param = paramKey ? params[paramKey][paramName] : params[paramName]; // Get the AST definition for the argument matching this param name

      var fieldAst = args.find(function (arg) {
        return arg.name.value === paramName;
      });

      if (fieldAst) {
        var unwrappedType = (0, _fields.unwrapNamedType)({
          type: fieldAst.type
        });
        var fieldTypeName = unwrappedType.name;
        var innerSchemaType = typeMap[fieldTypeName];

        if (isNeo4jTypeInput(fieldTypeName)) {
          paramStatements = buildNeo4jTypeCypherParameters({
            paramStatements: paramStatements,
            params: params,
            param: param,
            paramKey: paramKey,
            paramName: paramName,
            fieldTypeName: fieldTypeName
          });
        } else if (!(0, _graphql.isInputObjectType)(innerSchemaType)) {
          // normal case
          paramStatements.push("".concat(paramName, ":$").concat(paramKey ? "".concat(paramKey, ".") : '').concat(paramName));
        }
      }

      return paramStatements;
    }, statements);
  }

  return statements;
};

exports.buildCypherParameters = buildCypherParameters;

var buildNeo4jTypeCypherParameters = function buildNeo4jTypeCypherParameters(_ref14) {
  var paramStatements = _ref14.paramStatements,
      params = _ref14.params,
      param = _ref14.param,
      paramKey = _ref14.paramKey,
      paramName = _ref14.paramName,
      fieldTypeName = _ref14.fieldTypeName;
  var formatted = param.formatted;
  var neo4jTypeConstructor = decideNeo4jTypeConstructor(fieldTypeName);

  if (neo4jTypeConstructor) {
    // Prefer only using formatted, if provided
    if (formatted !== undefined) {
      if (paramKey) params[paramKey][paramName] = formatted;else params[paramName] = formatted;
      paramStatements.push("".concat(paramName, ": ").concat(neo4jTypeConstructor, "($").concat(paramKey ? "".concat(paramKey, ".") : '').concat(paramName, ")"));
    } else {
      var neo4jTypeParam = {};

      if ((0, _isArray["default"])(param)) {
        var count = param.length;
        var paramIndex = 0;

        for (; paramIndex < count; ++paramIndex) {
          neo4jTypeParam = param[paramIndex];

          if (neo4jTypeParam.formatted) {
            var _formatted = neo4jTypeParam.formatted;
            if (paramKey) params[paramKey][paramName][paramIndex] = _formatted;else params[paramName][paramIndex] = _formatted;
          }
        }

        paramStatements.push("".concat(paramName, ": [value IN $").concat(paramKey ? "".concat(paramKey, ".") : '').concat(paramName, " | ").concat(neo4jTypeConstructor, "(value)]"));
      } else {
        if (paramKey) neo4jTypeParam = params[paramKey][paramName];else neo4jTypeParam = params[paramName];
        var _formatted2 = neo4jTypeParam.formatted;

        if (neo4jTypeParam.formatted) {
          if (paramKey) params[paramKey][paramName] = _formatted2;else params[paramName] = _formatted2;
        }

        paramStatements.push("".concat(paramName, ": ").concat(neo4jTypeConstructor, "($").concat(paramKey ? "".concat(paramKey, ".") : '').concat(paramName, ")"));
      }
    }
  }

  return paramStatements;
}; // TODO refactor to handle Query/Mutation type schema directives


var directiveWithArgs = function directiveWithArgs(directiveName, args) {
  return function (schemaType, fieldName) {
    function fieldDirective(schemaType, fieldName, directiveName) {
      return !isGraphqlScalarType(schemaType) && !isGraphqlUnionType(schemaType) ? schemaType.getFields() && schemaType.getFields()[fieldName] && schemaType.getFields()[fieldName].astNode.directives.find(function (e) {
        return e.name.value === directiveName;
      }) : {};
    }

    function directiveArgument(directive, name) {
      return directive && directive.arguments ? directive.arguments.find(function (e) {
        return e.name.value === name;
      }).value.value : [];
    }

    var directive = fieldDirective(schemaType, fieldName, directiveName);
    var ret = {};

    if (directive) {
      _assign["default"].apply(Object, [ret].concat((0, _toConsumableArray2["default"])(args.map(function (key) {
        return (0, _defineProperty2["default"])({}, key, directiveArgument(directive, key));
      }))));
    }

    return ret;
  };
};

var cypherDirective = directiveWithArgs('cypher', ['statement']);
exports.cypherDirective = cypherDirective;
var relationDirective = directiveWithArgs('relation', ['name', 'direction']);
exports.relationDirective = relationDirective;

var getTypeDirective = function getTypeDirective(relatedAstNode, name) {
  return relatedAstNode && relatedAstNode.directives ? relatedAstNode.directives.find(function (e) {
    return e.name.value === name;
  }) : undefined;
};

exports.getTypeDirective = getTypeDirective;

var getFieldDirective = function getFieldDirective(field, directive) {
  return field && field.directives && field.directives.find(function (e) {
    return e && e.name && e.name.value === directive;
  });
};

exports.getFieldDirective = getFieldDirective;

var getQueryCypherDirective = function getQueryCypherDirective(resolveInfo, isFederatedOperation) {
  if (resolveInfo.fieldName === '_entities' || isFederatedOperation) return;
  return resolveInfo.schema.getQueryType().getFields()[resolveInfo.fieldName].astNode.directives.find(function (x) {
    return x.name.value === 'cypher';
  });
};

exports.getQueryCypherDirective = getQueryCypherDirective;

var getMutationCypherDirective = function getMutationCypherDirective(resolveInfo) {
  return resolveInfo.schema.getMutationType().getFields()[resolveInfo.fieldName].astNode.directives.find(function (x) {
    return x.name.value === 'cypher';
  });
};

exports.getMutationCypherDirective = getMutationCypherDirective;

function argumentValue(selection, name, variableValues) {
  var args = selection ? selection.arguments : [];
  var arg = args.find(function (a) {
    return a.name.value === name;
  });

  if (!arg) {
    return null;
  } else {
    return parseArg(arg, variableValues);
  }
}

var getRelationTypeDirective = function getRelationTypeDirective(relationshipType) {
  var directive = relationshipType && relationshipType.directives ? relationshipType.directives.find(function (e) {
    return e.name.value === 'relation';
  }) : undefined;
  return directive ? {
    name: directive.arguments.find(function (e) {
      return e.name.value === 'name';
    }).value.value,
    from: directive.arguments.find(function (e) {
      return e.name.value === 'from';
    }).value.value,
    to: directive.arguments.find(function (e) {
      return e.name.value === 'to';
    }).value.value
  } : undefined;
};
/**
 * Render safe a variable name according to cypher rules
 * @param {String} i input variable name
 * @returns {String} escaped text suitable for interpolation in cypher
 */


exports.getRelationTypeDirective = getRelationTypeDirective;

var safeVar = function safeVar(i) {
  // There are rare cases where the var input is an object and has to be stringified
  // to produce the right output.
  var asStr = "".concat(i); // Rules: https://neo4j.com/docs/developer-manual/current/cypher/syntax/naming/

  return '`' + asStr.replace(/[-!$%^&*()_+|~=`{}\[\]:";'<>?,.\/]/g, '_') + '`';
};
/**
 * Render safe a label name by enclosing it in backticks and escaping any
 * existing backtick if present.
 * @param {String | String[]} a label name or an array of labels
 * @returns {String} an escaped label name suitable for cypher concat
 */


exports.safeVar = safeVar;

var safeLabel = function safeLabel(l) {
  if (!(0, _isArray["default"])(l)) {
    l = [l];
  }

  var safeLabels = l.map(function (label) {
    var asStr = "".concat(label);
    var escapeInner = asStr.replace(/\`/g, '\\`');
    return '`' + escapeInner + '`';
  });
  return safeLabels.join(':');
};

exports.safeLabel = safeLabel;

var decideNestedVariableName = function decideNestedVariableName(_ref16) {
  var schemaTypeRelation = _ref16.schemaTypeRelation,
      schemaType = _ref16.schemaType,
      innerSchemaTypeRelation = _ref16.innerSchemaTypeRelation,
      variableName = _ref16.variableName,
      fieldName = _ref16.fieldName,
      parentSelectionInfo = _ref16.parentSelectionInfo;
  var cypherVariable = variableName + '_' + fieldName;

  if ((0, _query.isRelationshipMutationOutputType)({
    schemaType: schemaType
  })) {
    // used for relationship mutation output Payload types
    cypherVariable = parentSelectionInfo[fieldName];
  } else if (schemaTypeRelation) {
    var fromTypeName = schemaTypeRelation.from;
    var toTypeName = schemaTypeRelation.to;

    if (fromTypeName === toTypeName) {
      if ((0, _query.isReflexiveRelationshipOutputType)({
        schemaType: schemaType
      })) {
        cypherVariable = variableName + '_' + fieldName;
      } else {
        // Case of a reflexive relationship type's directed field
        // being renamed to its node type value
        // ex: from: User -> User: User
        cypherVariable = variableName;
      }
    }
  } else {
    // Types without @relation directives are assumed to be node types
    // and only node types can have fields whose values are relation types
    if (innerSchemaTypeRelation) {
      // innerSchemaType is a field payload type using a @relation directive
      if (innerSchemaTypeRelation.from === innerSchemaTypeRelation.to) {
        cypherVariable = variableName;
      }
    } else {
      // related types are different
      cypherVariable = variableName + '_' + fieldName;
    }
  }

  return cypherVariable;
};

exports.decideNestedVariableName = decideNestedVariableName;

var initializeMutationParams = function initializeMutationParams(_ref17) {
  var mutationMeta = _ref17.mutationMeta,
      resolveInfo = _ref17.resolveInfo,
      mutationTypeCypherDirective = _ref17.mutationTypeCypherDirective,
      otherParams = _ref17.otherParams,
      first = _ref17.first,
      offset = _ref17.offset;
  return (isCreateMutation(resolveInfo) || isRelationshipUpdateMutation({
    resolveInfo: resolveInfo,
    mutationMeta: mutationMeta
  }) || isRelationshipMergeMutation({
    resolveInfo: resolveInfo,
    mutationMeta: mutationMeta
  })) && !mutationTypeCypherDirective ? _objectSpread({
    params: otherParams
  }, {
    first: first,
    offset: offset
  }) : _objectSpread(_objectSpread({}, otherParams), {
    first: first,
    offset: offset
  });
};

exports.initializeMutationParams = initializeMutationParams;

var getOuterSkipLimit = function getOuterSkipLimit(first, offset) {
  return "".concat(offset > 0 ? " SKIP toInteger($offset)" : '').concat(first > -1 ? ' LIMIT toInteger($first)' : '');
};

exports.getOuterSkipLimit = getOuterSkipLimit;

var getPayloadSelections = function getPayloadSelections(resolveInfo) {
  var filteredFieldNodes = resolveInfo.fieldNodes.filter(function (n) {
    return function (n) {
      return n.name.value === resolveInfo.fieldName;
    };
  }); // FIXME: how to handle multiple fieldNode matches

  var payloadTypeNode = filteredFieldNodes[0];
  var selections = [];

  if (payloadTypeNode && payloadTypeNode.selectionSet) {
    selections = payloadTypeNode.selectionSet.selections;
  }

  return selections;
};

exports.getPayloadSelections = getPayloadSelections;

var filterNullParams = function filterNullParams(_ref18) {
  var offset = _ref18.offset,
      first = _ref18.first,
      otherParams = _ref18.otherParams;
  return (0, _entries["default"])(_objectSpread(_objectSpread({}, {
    offset: offset,
    first: first
  }), otherParams)).reduce(function (_ref19, _ref20) {
    var _ref21 = (0, _slicedToArray2["default"])(_ref19, 2),
        nulls = _ref21[0],
        nonNulls = _ref21[1];

    var _ref22 = (0, _slicedToArray2["default"])(_ref20, 2),
        key = _ref22[0],
        value = _ref22[1];

    if (value === null) {
      nulls[key] = value;
    } else {
      nonNulls[key] = value;
    }

    return [nulls, nonNulls];
  }, [{}, {}]);
};

exports.filterNullParams = filterNullParams;

var splitSelectionParameters = function splitSelectionParameters(params, primaryKeyArgName, paramKey) {
  var paramKeys = paramKey ? (0, _keys["default"])(params[paramKey]) : (0, _keys["default"])(params);

  var _paramKeys$reduce = paramKeys.reduce(function (acc, t) {
    if (t === primaryKeyArgName) {
      if (paramKey) {
        acc[0][t] = params[paramKey][t];
      } else {
        acc[0][t] = params[t];
      }
    } else {
      if (paramKey) {
        if (acc[1][paramKey] === undefined) acc[1][paramKey] = {};
        acc[1][paramKey][t] = params[paramKey][t];
      } else {
        acc[1][t] = params[t];
      }
    }

    return acc;
  }, [{}, {}]),
      _paramKeys$reduce2 = (0, _slicedToArray2["default"])(_paramKeys$reduce, 2),
      primaryKeyParam = _paramKeys$reduce2[0],
      updateParams = _paramKeys$reduce2[1];

  var first = params.first;
  var offset = params.offset;
  if (first !== undefined) updateParams['first'] = first;
  if (offset !== undefined) updateParams['offset'] = offset;
  return [primaryKeyParam, updateParams];
};

exports.splitSelectionParameters = splitSelectionParameters;

var isNeo4jType = function isNeo4jType(name) {
  return isTemporalType(name) || isSpatialType(name);
};

exports.isNeo4jType = isNeo4jType;

var isNeo4jTypeInput = function isNeo4jTypeInput(name) {
  return isTemporalInputType(name) || isSpatialInputType(name) || isSpatialDistanceInputType(name);
};

exports.isNeo4jTypeInput = isNeo4jTypeInput;

var isTemporalType = function isTemporalType(name) {
  return name === '_Neo4jTime' || name === '_Neo4jDate' || name === '_Neo4jDateTime' || name === '_Neo4jLocalTime' || name === '_Neo4jLocalDateTime';
};

exports.isTemporalType = isTemporalType;

var isTemporalField = function isTemporalField(schemaType, name) {
  var type = schemaType ? schemaType.name : '';
  return isTemporalType(type) && (name === 'year' || name === 'month' || name === 'day' || name === 'hour' || name === 'minute' || name === 'second' || name === 'microsecond' || name === 'millisecond' || name === 'nanosecond' || name === 'timezone' || name === 'formatted');
};

exports.isTemporalField = isTemporalField;

var isTemporalInputType = function isTemporalInputType(name) {
  return name === '_Neo4jTimeInput' || name === '_Neo4jDateInput' || name === '_Neo4jDateTimeInput' || name === '_Neo4jLocalTimeInput' || name === '_Neo4jLocalDateTimeInput';
};

exports.isTemporalInputType = isTemporalInputType;

var isSpatialType = function isSpatialType(name) {
  return name === '_Neo4jPoint';
};

exports.isSpatialType = isSpatialType;

var isSpatialField = function isSpatialField(schemaType, name) {
  var type = schemaType ? schemaType.name : '';
  return isSpatialType(type) && (name === 'x' || name === 'y' || name === 'z' || name === 'longitude' || name === 'latitude' || name === 'height' || name === 'crs' || name === 'srid' || name === 'formatted');
};

exports.isSpatialField = isSpatialField;

var isSpatialInputType = function isSpatialInputType(name) {
  return name === '_Neo4jPointInput';
};

exports.isSpatialInputType = isSpatialInputType;

var isSpatialDistanceInputType = function isSpatialDistanceInputType(_ref23) {
  var _ref23$filterOperatio = _ref23.filterOperationType,
      filterOperationType = _ref23$filterOperatio === void 0 ? '' : _ref23$filterOperatio;

  switch (filterOperationType) {
    case 'distance':
    case 'distance_lt':
    case 'distance_lte':
    case 'distance_gt':
    case 'distance_gte':
      return true;

    default:
      return false;
  }
};

exports.isSpatialDistanceInputType = isSpatialDistanceInputType;

var decideNeo4jTypeConstructor = function decideNeo4jTypeConstructor(typeName) {
  switch (typeName) {
    case '_Neo4jTimeInput':
      return 'time';

    case '_Neo4jDateInput':
      return 'date';

    case '_Neo4jDateTimeInput':
      return 'datetime';

    case '_Neo4jLocalTimeInput':
      return 'localtime';

    case '_Neo4jLocalDateTimeInput':
      return 'localdatetime';

    case '_Neo4jPointInput':
      return 'point';

    default:
      return '';
  }
};

exports.decideNeo4jTypeConstructor = decideNeo4jTypeConstructor;

var neo4jTypePredicateClauses = function neo4jTypePredicateClauses(filters, variableName, fieldArguments, parentParam) {
  return fieldArguments.reduce(function (acc, fieldArgument) {
    if (!(0, _fields.isListTypeField)({
      field: fieldArgument
    })) {
      // For every temporal argument
      var argName = fieldArgument.name.value;
      var argValue = filters[argName];

      if (argValue) {
        var type = fieldArgument.type;
        var unwrappedType = (0, _fields.unwrapNamedType)({
          type: type
        });
        var typeName = unwrappedType.name; // If a parameter value has been provided for it check whether
        // the provided param value is in an indexed object for a nested argument

        var paramIndex = argValue.index;
        var paramValue = argValue.value; // If it is, set and use its .value

        if (paramValue) argValue = paramValue;
        var parentParamPath = parentParam ? "".concat(parentParam, ".") : '';
        var paramPath = "".concat(parentParamPath).concat(paramIndex >= 1 ? "".concat(paramIndex, "_") : '').concat(argName);
        var propertyPath = "".concat(variableName, ".").concat(argName);
        var cypherTypeConstructor = decideNeo4jTypeConstructor(typeName);
        var isTemporalFormattedField = argValue[_types.Neo4jTypeFormatted.FORMATTED];

        if (isTemporalFormattedField) {
          // Only the dedicated 'formatted' arg is used if it is provided
          acc.push("".concat(propertyPath, " = ").concat(cypherTypeConstructor, "($").concat(paramPath, ".").concat(_types.Neo4jTypeFormatted.FORMATTED, ")"));
        } else {
          (0, _keys["default"])(argValue).forEach(function (paramName) {
            acc.push("".concat(propertyPath, ".").concat(paramName, " = $").concat(paramPath, ".").concat(paramName));
          });
        }
      }
    }

    return acc;
  }, []);
};

exports.neo4jTypePredicateClauses = neo4jTypePredicateClauses;

var getNeo4jTypeArguments = function getNeo4jTypeArguments(args) {
  return args ? args.reduce(function (acc, t) {
    if (!t) {
      return acc;
    }

    var fieldType = (0, _fields.unwrapNamedType)({
      type: t.type
    }).name;
    if (isNeo4jTypeInput(fieldType)) acc.push(t);
    return acc;
  }, []) : [];
}; // TODO rename and add logic for @skip and @include directives?


exports.getNeo4jTypeArguments = getNeo4jTypeArguments;

var removeIgnoredFields = function removeIgnoredFields(schemaType, selections) {
  if (!isGraphqlScalarType(schemaType) && selections && selections.length) {
    var schemaTypeFields = schemaType.getFields();
    var schemaTypeField = '';
    selections = selections.filter(function (field) {
      var fieldKind = field.kind;

      if (fieldKind === _graphql.Kind.FIELD) {
        var fieldName = field.name.value; // so check if this field is ignored

        schemaTypeField = schemaTypeFields[fieldName];
        return schemaTypeField && schemaTypeField.astNode && !getFieldDirective(schemaTypeField.astNode, 'neo4j_ignore');
      } // keep element by default


      return true;
    });
  }

  return selections;
};

exports.removeIgnoredFields = removeIgnoredFields;

var getInterfaceDerivedTypeNames = function getInterfaceDerivedTypeNames(schema, interfaceName) {
  var implementingTypeMap = schema._implementationsMap ? schema._implementationsMap[interfaceName] : {};
  var implementingTypes = [];

  if (implementingTypeMap && implementingTypeMap.objects) {
    implementingTypes = (0, _values["default"])(implementingTypeMap.objects).map(function (type) {
      return type.name;
    });
  }

  return implementingTypes.sort();
};

exports.getInterfaceDerivedTypeNames = getInterfaceDerivedTypeNames;